diff --git a/drivers/media/dvb-core/Kconfig b/drivers/media/dvb-core/Kconfig
index 2940ded..fa7a249 100755
--- a/drivers/media/dvb-core/Kconfig
+++ b/drivers/media/dvb-core/Kconfig
@@ -18,7 +18,7 @@ config DVB_MAX_ADAPTERS
 config DVB_DYNAMIC_MINORS
 	bool "Dynamic DVB minor allocation"
 	depends on DVB_CORE
-	default y
+	default n
 	help
 	  If you say Y here, the DVB subsystem will use dynamic minor
 	  allocation for any device that uses the DVB major number.
diff --git a/drivers/media/dvb-core/demux.h b/drivers/media/dvb-core/demux.h
index 48939f0..eb91fd8 100755
--- a/drivers/media/dvb-core/demux.h
+++ b/drivers/media/dvb-core/demux.h
@@ -86,7 +86,7 @@ enum dmx_success {
 /* PES type for filters which write to built-in decoder */
 /* these should be kept identical to the types in dmx.h */
 
-typedef enum
+enum dmx_ts_pes
 {  /* also send packets to decoder (if it exists) */
 	DMX_TS_PES_AUDIO0,
 	DMX_TS_PES_VIDEO0,
@@ -113,8 +113,7 @@ typedef enum
 	DMX_TS_PES_PCR3,
 
 	DMX_TS_PES_OTHER
-}dmx_ts_pes_t;
-
+};
 
 #define DMX_TS_PES_AUDIO    DMX_TS_PES_AUDIO0
 #define DMX_TS_PES_VIDEO    DMX_TS_PES_VIDEO0
diff --git a/drivers/media/dvb-core/dmxdev.c b/drivers/media/dvb-core/dmxdev.c
index 0b4616b..8896993 100644
--- a/drivers/media/dvb-core/dmxdev.c
+++ b/drivers/media/dvb-core/dmxdev.c
@@ -377,8 +377,10 @@ static int dvb_dmxdev_section_callback(const u8 *buffer1, size_t buffer1_len,
 		ret = dvb_dmxdev_buffer_write(&dmxdevfilter->buffer, buffer2,
 					      buffer2_len);
 	}
-	if (ret < 0)
+	if (ret < 0) {
+		dvb_ringbuffer_flush(&dmxdevfilter->buffer);
 		dmxdevfilter->buffer.error = ret;
+	}
 	if (dmxdevfilter->params.sec.flags & DMX_ONESHOT)
 		dmxdevfilter->state = DMXDEV_STATE_DONE;
 	spin_unlock(&dmxdevfilter->dev->lock);
@@ -414,8 +416,10 @@ static int dvb_dmxdev_ts_callback(const u8 *buffer1, size_t buffer1_len,
 	ret = dvb_dmxdev_buffer_write(buffer, buffer1, buffer1_len);
 	if (ret == buffer1_len)
 		ret = dvb_dmxdev_buffer_write(buffer, buffer2, buffer2_len);
-	if (ret < 0)
+	if (ret < 0) {
+		dvb_ringbuffer_flush(buffer);
 		buffer->error = ret;
+	}
 	spin_unlock(&dmxdevfilter->dev->lock);
 	wake_up(&buffer->queue);
 	return 0;
@@ -565,7 +569,7 @@ static int dvb_dmxdev_start_feed(struct dmxdev *dmxdev,
 	dmx_output_t otype;
 	int ret;
 	int ts_type;
-	enum dmx_ts_pes ts_pes;
+	dmx_pes_type_t ts_pes;
 	struct dmx_ts_feed *tsfeed;
 
 	feed->ts = NULL;
diff --git a/drivers/media/dvb-core/dvb-usb-ids.h b/drivers/media/dvb-core/dvb-usb-ids.h
index 335a8f4..399e104 100644
--- a/drivers/media/dvb-core/dvb-usb-ids.h
+++ b/drivers/media/dvb-core/dvb-usb-ids.h
@@ -124,7 +124,8 @@
 #define USB_PID_DIBCOM_STK7770P				0x1e80
 #define USB_PID_DIBCOM_NIM7090				0x1bb2
 #define USB_PID_DIBCOM_TFE7090PVR			0x1bb4
-#define USB_PID_DIBCOM_TFE7790P				0x1e6e
+#define USB_PID_DIBCOM_TFE7090E				0x1bb7
+#define USB_PID_DIBCOM_TFE7790E				0x1e6e
 #define USB_PID_DIBCOM_NIM9090M				0x2383
 #define USB_PID_DIBCOM_NIM9090MD			0x2384
 #define USB_PID_DPOSH_M9206_COLD			0x9206
diff --git a/drivers/media/dvb-core/dvb_demux.c b/drivers/media/dvb-core/dvb_demux.c
index 3485655..71641b2 100644
--- a/drivers/media/dvb-core/dvb_demux.c
+++ b/drivers/media/dvb-core/dvb_demux.c
@@ -674,7 +674,7 @@ static int dmx_ts_feed_set(struct dmx_ts_feed *ts_feed, u16 pid, int ts_type,
 		return -ERESTARTSYS;
 
 	if (ts_type & TS_DECODER) {
-		if (pes_type >= DMX_PES_OTHER) {
+		if (pes_type >= DMX_TS_PES_OTHER) {
 			mutex_unlock(&demux->mutex);
 			return -EINVAL;
 		}
@@ -846,7 +846,7 @@ static int dvbdmx_release_ts_feed(struct dmx_demux *dmx,
 
 	feed->pid = 0xffff;
 
-	if (feed->ts_type & TS_DECODER && feed->pes_type < DMX_PES_OTHER)
+	if (feed->ts_type & TS_DECODER && feed->pes_type < DMX_TS_PES_OTHER)
 		demux->pesfilter[feed->pes_type] = NULL;
 
 	mutex_unlock(&demux->mutex);
@@ -1268,7 +1268,7 @@ int dvb_dmx_init(struct dvb_demux *dvbdemux)
 
 	INIT_LIST_HEAD(&dvbdemux->frontend_list);
 
-	for (i = 0; i < DMX_PES_OTHER; i++) {
+	for (i = 0; i < DMX_TS_PES_OTHER; i++) {
 		dvbdemux->pesfilter[i] = NULL;
 		dvbdemux->pids[i] = 0xffff;
 	}
diff --git a/drivers/media/dvb-core/dvb_demux.h b/drivers/media/dvb-core/dvb_demux.h
index ae7fc33..fa7188a 100644
--- a/drivers/media/dvb-core/dvb_demux.h
+++ b/drivers/media/dvb-core/dvb_demux.h
@@ -119,8 +119,8 @@ struct dvb_demux {
 
 	struct list_head frontend_list;
 
-	struct dvb_demux_feed *pesfilter[DMX_PES_OTHER];
-	u16 pids[DMX_PES_OTHER];
+	struct dvb_demux_feed *pesfilter[DMX_TS_PES_OTHER];
+	u16 pids[DMX_TS_PES_OTHER];
 	int playing;
 	int recording;
 
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index 7187ba9..57601c0 100755
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -52,10 +52,6 @@ static int dvb_force_auto_inversion;
 static int dvb_override_tune_delay;
 static int dvb_powerdown_on_sleep = 1;
 static int dvb_mfe_wait_time = 5;
-static int dvb_afc_debug=0;
-static int disable_set_frotend_param=0;
-static int dvb_dtv_debug=0;
-
 
 module_param_named(frontend_debug, dvb_frontend_debug, int, 0644);
 MODULE_PARM_DESC(frontend_debug, "Turn on/off frontend core debugging (default:off).");
@@ -69,18 +65,6 @@ module_param(dvb_powerdown_on_sleep, int, 0644);
 MODULE_PARM_DESC(dvb_powerdown_on_sleep, "0: do not power down, 1: turn LNB voltage off on sleep (default)");
 module_param(dvb_mfe_wait_time, int, 0644);
 MODULE_PARM_DESC(dvb_mfe_wait_time, "Wait up to <mfe_wait_time> seconds on open() for multi-frontend to become available (default:5 seconds)");
-module_param(dvb_afc_debug, int, 0644);
-MODULE_PARM_DESC( dvb_afc_debug,"vb_afc_debug \n");
-module_param(disable_set_frotend_param, int, 0644);
-MODULE_PARM_DESC( disable_set_frotend_param,"disable_set_frotend_param \n");
-module_param(dvb_dtv_debug, int, 0644);
-MODULE_PARM_DESC( dvb_dtv_debug,"vb_afc_debug \n");
-
-
-#define dprintk if (dvb_frontend_debug) printk
-#define pr_afc  if(dvb_afc_debug)printk
-#define dtvprintk  if(dvb_dtv_debug)printk
-
 
 #define FESTATE_IDLE 1
 #define FESTATE_RETUNE 2
@@ -117,22 +101,14 @@ MODULE_PARM_DESC( dvb_dtv_debug,"vb_afc_debug \n");
 #define DVB_FE_DEVICE_REMOVED	2
 
 static DEFINE_MUTEX(frontend_mutex);
-extern unsigned int jiffies_to_msecs(const unsigned long j);
-int jiffiestime;
-//#define LOCK_TIMEOUT 2000
-static int LOCK_TIMEOUT = 2000;
 
 struct dvb_frontend_private {
 
 	/* thread/frontend values */
 	struct dvb_device *dvbdev;
-	struct dvb_frontend_parameters parameters_in;
 	struct dvb_frontend_parameters parameters_out;
 	struct dvb_fe_events events;
 	struct semaphore sem;
-	struct dvbsx_blindscan_events blindscan_events;
-	struct semaphore blindscan_sem;
-	bool in_blindscan;
 	struct list_head list_head;
 	wait_queue_head_t wait_queue;
 	struct task_struct *thread;
@@ -146,12 +122,6 @@ struct dvb_frontend_private {
 	int tone;
 	int voltage;
 
-	/*set_frontend ops async support*/
-	wait_queue_head_t setfrontendasync_wait_queue;
-	unsigned int setfrontendasync_wakeup;
-	unsigned int setfrontendasync_needwakeup;
-	unsigned int setfrontendasync_interruptwakeup;
-
 	/* swzigzag values */
 	unsigned int state;
 	unsigned int bending;
@@ -166,7 +136,6 @@ struct dvb_frontend_private {
 	int quality;
 	unsigned int check_wrapped;
 	enum dvbfe_search algo_status;
-	int user_delay;
 };
 
 static void dvb_frontend_wakeup(struct dvb_frontend *fe);
@@ -191,7 +160,6 @@ enum dvbv3_emulation_type {
 	DVBV3_QAM,
 	DVBV3_OFDM,
 	DVBV3_ATSC,
-	DVBV3_ANALOG
 };
 
 static enum dvbv3_emulation_type dvbv3_type(u32 delivery_system)
@@ -215,8 +183,6 @@ static enum dvbv3_emulation_type dvbv3_type(u32 delivery_system)
 	case SYS_ATSCMH:
 	case SYS_DVBC_ANNEX_B:
 		return DVBV3_ATSC;
-	case SYS_ANALOG:
-		return DVBV3_ANALOG;
 	case SYS_UNDEFINED:
 	case SYS_ISDBC:
 	case SYS_DVBH:
@@ -241,13 +207,8 @@ static void dvb_frontend_add_event(struct dvb_frontend *fe, fe_status_t status)
 
 	dev_dbg(fe->dvb->device, "%s:\n", __func__);
 
-	if(fe->dtv_property_cache.delivery_system == SYS_ANALOG){
-		if ((status & FE_HAS_LOCK) && has_get_frontend(fe))
-			dtv_get_frontend(fe, &fepriv->parameters_out);
-	}else{
-		if (/*(status & FE_HAS_LOCK) && */has_get_frontend(fe))
-			dtv_get_frontend(fe, &fepriv->parameters_out);
-	}
+	if ((status & FE_HAS_LOCK) && has_get_frontend(fe))
+		dtv_get_frontend(fe, &fepriv->parameters_out);
 
 	mutex_lock(&events->mtx);
 
@@ -260,6 +221,7 @@ static void dvb_frontend_add_event(struct dvb_frontend *fe, fe_status_t status)
 	e = &events->events[events->eventw];
 	e->status = status;
 	e->parameters = fepriv->parameters_out;
+
 	events->eventw = wp;
 
 	mutex_unlock(&events->mtx);
@@ -306,92 +268,6 @@ static int dvb_frontend_get_event(struct dvb_frontend *fe,
 	return 0;
 }
 
-static void dvbsx_blindscan_add_event(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-	struct dvbsx_blindscan_events *events = &fepriv->blindscan_events;
-	struct dvbsx_blindscanevent *e;
-	int wp;
-
-	dprintk ("%s\n", __func__);
-
-	if (mutex_lock_interruptible (&events->mtx))
-		return;
-
-	wp = (events->eventw + 1) % MAX_BLINDSCAN_EVENT;
-
-	if (wp == events->eventr) {
-		events->overflow = 1;
-		events->eventr = (events->eventr + 1) % MAX_BLINDSCAN_EVENT;
-	}
-
-	e = &events->events[events->eventw];
-
-	memcpy (e, pbsevent, sizeof (struct dvbsx_blindscanevent));
-
-	events->eventw = wp;
-
-	mutex_unlock(&events->mtx);
-
-	wake_up_interruptible (&events->wait_queue);
-}
-
-static int dvbsx_blindscan_get_event(struct dvb_frontend *fe,
-				struct dvbsx_blindscanevent *event , int flags)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-	struct dvbsx_blindscan_events *events = &fepriv->blindscan_events;
-
-	dprintk ("%s\n", __func__);
-
-	if (events->overflow) {
-		events->overflow = 0;
-		return -EOVERFLOW;
-	}
-
-	if (events->eventw == events->eventr) {
-		int ret;
-
-		if (flags & O_NONBLOCK)
-			return -EWOULDBLOCK;
-
-		up(&fepriv->blindscan_sem);
-
-		ret = wait_event_interruptible_timeout (events->wait_queue,
-												events->eventw != events->eventr, fe->ops.blindscan_ops.info.bspara.timeout * HZ);
-
-		if (down_interruptible (&fepriv->blindscan_sem))
-			return -ERESTARTSYS;
-
-		if (ret < 0)
-			return ret;
-	}
-
-	if (mutex_lock_interruptible (&events->mtx))
-		return -ERESTARTSYS;
-
-	memcpy (event, &events->events[events->eventr],
-		sizeof(struct dvbsx_blindscanevent));
-
-	events->eventr = (events->eventr + 1) % MAX_BLINDSCAN_EVENT;
-
-	mutex_unlock(&events->mtx);
-
-	return 0;
-}
-
-static int dvbsx_blindscan_event_callback(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent)
-{
-	dprintk ("%s\n", __func__);
-
-	if((!fe) || (!pbsevent ))
-		return -1;
-
-	dvbsx_blindscan_add_event(fe, pbsevent);
-
-	return 0;
-}
-
 static void dvb_frontend_clear_events(struct dvb_frontend *fe)
 {
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
@@ -458,7 +334,6 @@ static int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wra
 	int autoinversion;
 	int ready = 0;
 	int fe_set_err = 0;
-	int time=0;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;
 	int original_inversion = c->inversion;
@@ -537,13 +412,8 @@ static int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wra
 	if (autoinversion)
 		c->inversion = fepriv->inversion;
 	tmp = *c;
-	time=jiffies_to_msecs(jiffies)-jiffiestime;
-	dprintk("2---auto tune,time is %d\n",time);
-	if (fe->ops.set_frontend&&(time>=LOCK_TIMEOUT)){
+	if (fe->ops.set_frontend)
 		fe_set_err = fe->ops.set_frontend(fe);
-		jiffiestime=jiffies_to_msecs(jiffies);
-		}
-	fepriv->parameters_out = fepriv->parameters_in;
 	*c = tmp;
 	if (fe_set_err < 0) {
 		fepriv->state = FESTATE_ERROR;
@@ -557,37 +427,12 @@ static int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wra
 	return 0;
 }
 
-#if (defined CONFIG_AM_M6_DEMOD)
-extern u32 dvbc_get_status(void);
-extern unsigned long atsc_read_iqr_reg(void);
-
-#endif
-
-#if 0 
-#if (defined CONFIG_AM_SI2176)
-int si2176_get_strength(void);
-#endif
-#if ((defined CONFIG_AM_SI2177) || (defined CONFIG_AM_SI2157))
-int si2177_get_strength(void);
-#endif
-#endif
-
 static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 {
-	fe_status_t s;
-	int retval;
-	int time;
+	fe_status_t s = 0;
+	int retval = 0;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;
-#if ((defined CONFIG_AM_SI2176) || (defined CONFIG_AM_SI2177) || (defined CONFIG_AM_SI2157))&&(defined CONFIG_AM_M6_DEMOD)
-	int strength;
-#endif
-#if (defined CONFIG_AM_M6_DEMOD)
-	int newcount;
-    int count;
-	count=0;
-#endif
-	s=retval=time=0;
 
 	/* if we've got no parameters, just keep idling */
 	if (fepriv->state & FESTATE_IDLE) {
@@ -619,10 +464,7 @@ static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 	} else {
 		if (fe->ops.read_status)
 			fe->ops.read_status(fe, &s);
-			time=jiffies_to_msecs(jiffies)-jiffiestime;
-		dprintk("1---read status,time is %d, s is %d,fepriv->status is %d\n",time,s,fepriv->status);
-		if (((s != fepriv->status)&&(time>=LOCK_TIMEOUT))||((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))) {
-			printk("1----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
+		if (s != fepriv->status) {
 			dvb_frontend_add_event(fe, s);
 			fepriv->status = s;
 		}
@@ -640,142 +482,6 @@ static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 		}
 		return;
 	}
-//auto_mode qam   201306-rsj
-#if (defined CONFIG_AM_M6_DEMOD)
-//dvbc auto qam
-	if(c->modulation== QAM_AUTO){
-		while((dvbc_get_status()<=3)&&(count<=20)){
-			msleep(30);
-			if(count==20){
-				fe->ops.read_status(fe, &s);
-				printk("!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-				dvb_frontend_add_event(fe, s);
-				fepriv->status = s;
-			}
-			count++;
-		}
-		count=0;
-		while((dvbc_get_status()>3)&&(dvbc_get_status()!=5)&&(count<5)){
-			if(count==0)
-				c->modulation=QAM_64;
-			else if(count==1)
-				c->modulation=QAM_256;
-			else if(count==2)
-				c->modulation=QAM_128;
-			else if(count==3)
-				c->modulation=QAM_16;
-			else
-				c->modulation=QAM_32;
-
-			if (fe->ops.set_qam_mode){
-				fe->ops.set_qam_mode(fe);
-			}
-			for(newcount=0;newcount<6;newcount++){
-				if(dvbc_get_status()==5)
-					break;
-				msleep(50);
-			}
-			newcount=0;
-			count++;
-			if(dvbc_get_status()==5){
-				if (fe->ops.read_status){
-					fe->ops.read_status(fe, &s);
-				}
-				if(((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))){
-					printk("!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					break;
-				}
-			}
-
-		}
-	}else if(c->modulation == QAM_AUTO){
-	//	fepriv->parameters_out = fepriv->parameters_in;
-		msleep(100);
-		#if (defined CONFIG_AM_SI2176)
-		strength=fe->ops.tuner_ops.get_strength(fe)-256;
-		if(strength<=(-85)){
-			s=32;
-			printk("5-strength is %d\n",strength);
-			if(s != fepriv->status){
-					printk("5----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-				}
-			return;
-
-		}
-		#elif ((defined CONFIG_AM_SI2177) || (defined CONFIG_AM_SI2157))
-		strength=fe->ops.tuner_ops.get_strength(fe)-256;
-		if(strength<=(-85)){
-			s=32;
-			printk("5-strength is %d\n",strength);
-			if(s != fepriv->status){
-					printk("5----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-				}
-			return;
-
-		}
-		#endif
-		while(((atsc_read_iqr_reg()>>16)!=0x1f)&&(count<2)){
-			if(count==0){
-				if (fe->ops.set_frontend){
-			//	fe->ops.set_frontend(fe, &fepriv->parameters_in);
-				}
-			}
-	//			fepriv->parameters_in.u.vsb.modulation=QAM_256;
-			else if(count==1){
-				c->modulation=QAM_64;
-				if (fe->ops.set_qam_mode){
-					fe->ops.set_qam_mode(fe);
-				}
-			//	dprintk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
-			}
-			for(newcount=0;newcount<10;newcount++){
-				if((atsc_read_iqr_reg()>>16)==0x1f)
-					break;
-				msleep(50);
-			}
-			newcount=0;
-			count++;
-		if((atsc_read_iqr_reg()>>16)==0x1f){
-				if (fe->ops.read_status){
-					fe->ops.read_status(fe, &s);
-				}
-				if(((s != fepriv->status)&&(s == (FE_HAS_LOCK|FE_HAS_SIGNAL|FE_HAS_CARRIER|FE_HAS_VITERBI|FE_HAS_SYNC)))){
-					printk("3----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					printk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-					return;
-				}
-			}
-			if(count==2&&((atsc_read_iqr_reg()>>16)!=0x1f)){
-				if (fe->ops.read_status){
-					fe->ops.read_status(fe, &s);
-				}
-				if(s != fepriv->status){
-					printk("2----!!!!!!!!!!!!!!!!!!!event s=%d,fepriv->status is %d!!!!!!!!!!!!!!!!!\n",s,fepriv->status);
-					printk("fepriv->parameters_in.frequency is %d\n",fepriv->parameters_in.frequency);
-					dvb_frontend_add_event(fe, s);
-					fepriv->status = s;
-					jiffiestime=jiffies_to_msecs(jiffies);
-					return;
-				}
-			}
-		}
-
-	}
-
-
-//
-#endif
 
 	/* if we are tuned already, check we're still locked */
 	if (fepriv->state & FESTATE_TUNED) {
@@ -820,10 +526,6 @@ static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
 
 	/* fast zigzag. */
 	if ((fepriv->state & FESTATE_SEARCHING_FAST) || (fepriv->state & FESTATE_RETUNE)) {
-
-	  if(fepriv->state & FESTATE_SEARCHING_FAST)
-		fepriv->delay = fepriv->min_delay + HZ/5;/*if not lock signal ,then wait 25 jiffies*/
-	  else
 		fepriv->delay = fepriv->min_delay;
 
 		/* perform a tune */
@@ -897,11 +599,11 @@ static int dvb_frontend_thread(void *data)
 {
 	struct dvb_frontend *fe = data;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-	unsigned long timeout;
 	fe_status_t s;
 	enum dvbfe_algo algo;
 
-	struct dvb_frontend_parameters *params=NULL;
+	bool re_tune = false;
+	bool semheld = false;
 
 	dev_dbg(fe->dvb->device, "%s:\n", __func__);
 
@@ -918,13 +620,15 @@ static int dvb_frontend_thread(void *data)
 	while (1) {
 		up(&fepriv->sem);	    /* is locked when we enter the thread... */
 restart:
-		timeout = wait_event_interruptible_timeout(fepriv->wait_queue,
+		wait_event_interruptible_timeout(fepriv->wait_queue,
 			dvb_frontend_should_wakeup(fe) || kthread_should_stop()
 				|| freezing(current),
 			fepriv->delay);
 
 		if (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {
 			/* got signal or quitting */
+			if (!down_interruptible(&fepriv->sem))
+				semheld = true;
 			fepriv->exit = DVB_FE_NORMAL_EXIT;
 			break;
 		}
@@ -952,15 +656,15 @@ static int dvb_frontend_thread(void *data)
 				dev_dbg(fe->dvb->device, "%s: Frontend ALGO = DVBFE_ALGO_HW\n", __func__);
 
 				if (fepriv->state & FESTATE_RETUNE) {
-					dprintk("%s: Retune requested, FESTATE_RETUNE\n", __func__);
-					params = &fepriv->parameters_in;
+					dev_dbg(fe->dvb->device, "%s: Retune requested, FESTATE_RETUNE\n", __func__);
+					re_tune = true;
 					fepriv->state = FESTATE_TUNED;
+				} else {
+					re_tune = false;
 				}
 
 				if (fe->ops.tune)
-					fe->ops.tune(fe, params, fepriv->tune_mode_flags, &fepriv->delay, &s);
-				if (params)
-					fepriv->parameters_out = *params;
+					fe->ops.tune(fe, re_tune, fepriv->tune_mode_flags, &fepriv->delay, &s);
 
 				if (s != fepriv->status && !(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT)) {
 					dev_dbg(fe->dvb->device, "%s: state changed, adding current state\n", __func__);
@@ -993,17 +697,12 @@ static int dvb_frontend_thread(void *data)
 					}
 				}
 				/* Track the carrier if the search was successful */
-				if (fepriv->algo_status == DVBFE_ALGO_SEARCH_SUCCESS) {
-					if (fe->ops.track)
-						fe->ops.track(fe, &fepriv->parameters_in);
-					s = FE_HAS_LOCK;
-				} else {
+				if (fepriv->algo_status != DVBFE_ALGO_SEARCH_SUCCESS) {
 					fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
 					fepriv->delay = HZ / 2;
-					s = FE_TIMEDOUT;
 				}
 				dtv_property_legacy_params_sync(fe, &fepriv->parameters_out);
-				//fe->ops.read_status(fe, &s);
+				fe->ops.read_status(fe, &s);
 				if (s != fepriv->status) {
 					dvb_frontend_add_event(fe, s); /* update event list */
 					fepriv->status = s;
@@ -1045,6 +744,8 @@ static int dvb_frontend_thread(void *data)
 		fepriv->exit = DVB_FE_NO_EXIT;
 	mb();
 
+	if (semheld)
+		up(&fepriv->sem);
 	dvb_frontend_wakeup(fe);
 	return 0;
 }
@@ -1275,138 +976,6 @@ static int dvb_frontend_clear_cache(struct dvb_frontend *fe)
 	return 0;
 }
 
-static int dvb_frontend_asyncshouldwakeup(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_wakeup);
-
-	return fepriv->setfrontendasync_wakeup;
-}
-
-static int dvb_frontend_asyncnotbusy(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_needwakeup);
-
-	return !fepriv->setfrontendasync_needwakeup;
-}
-
-static void dvb_frontend_asyncwakeup(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return;
-	}
-
-
-	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_needwakeup);
-
-	if(fepriv->setfrontendasync_needwakeup){
-		fepriv->setfrontendasync_wakeup = 1;
-		wake_up_interruptible(&fepriv->setfrontendasync_wait_queue);
-
-		up(&fepriv->sem);
-		wait_event_interruptible(fepriv->setfrontendasync_wait_queue,
-											dvb_frontend_asyncnotbusy(fe));
-		if (down_interruptible (&fepriv->sem))
-			return ;
-	}
-}
-
-static int dvb_frontend_asyncpreproc(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return -1;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return -1;
-	}
-
-	fepriv->setfrontendasync_needwakeup = 1;
-	fepriv->setfrontendasync_wakeup = 0;
-
-	dprintk ("%s:%d\n", __func__, fepriv->setfrontendasync_needwakeup);
-
-	/*enable other frontend ops run*/
-	up(&fepriv->sem);
-
-	return 0;
-}
-
-static int dvb_frontend_asyncwait(struct dvb_frontend *fe, u32 ms_timeout)
-{
-	int ret = 0;
-	unsigned long wait_ret = 0;
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return -1;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return -1;
-	}
-
-	wait_ret= wait_event_interruptible_timeout(fepriv->setfrontendasync_wait_queue,
-											dvb_frontend_asyncshouldwakeup(fe),
-											ms_timeout * HZ /1000);
-
-	dprintk ("%s:%d/%ld\n", __func__, ms_timeout, wait_ret);
-
-	if(wait_ret > 0){
-		ret = 1;
-	}
-	else if(wait_ret == 0){
-		ret = 0;
-	}
-
-	return ret;
-}
-
-static int dvb_frontend_asyncpostproc(struct dvb_frontend *fe, int asyncwait_ret)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	if(!fe){
-		return -1;
-	}
-
-	if(!fe->ops.asyncinfo.set_frontend_asyncenable){
-		return -1;
-	}
-
-	if (down_interruptible (&fepriv->sem))
-		return -1;
-
-	fepriv->setfrontendasync_needwakeup = 0;
-
-	wake_up_interruptible(&fepriv->setfrontendasync_wait_queue);
-
-	if(asyncwait_ret > 0){
-		fepriv->setfrontendasync_interruptwakeup = 1;
-	}
-	else if(asyncwait_ret == 0){
-		fepriv->setfrontendasync_interruptwakeup = 0;
-	}
-	else{
-		fepriv->setfrontendasync_interruptwakeup = 0;
-	}
-
-	dprintk ("%s:%d/%d\n", __func__, asyncwait_ret, fepriv->setfrontendasync_needwakeup);
-
-	return 0;
-}
-
 #define _DTV_CMD(n, s, b) \
 [n] = { \
 	.name = #n, \
@@ -1578,7 +1147,6 @@ static int dtv_property_cache_sync(struct dvb_frontend *fe,
 		c->transmission_mode = p->u.ofdm.transmission_mode;
 		c->guard_interval = p->u.ofdm.guard_interval;
 		c->hierarchy = p->u.ofdm.hierarchy_information;
-		c->ofdm_mode = p->u.ofdm.ofdm_mode;
 		break;
 	case DVBV3_ATSC:
 		dev_dbg(fe->dvb->device, "%s: Preparing ATSC req\n", __func__);
@@ -1590,14 +1158,6 @@ static int dtv_property_cache_sync(struct dvb_frontend *fe,
 		else
 			c->delivery_system = SYS_DVBC_ANNEX_B;
 		break;
-	case DVBV3_ANALOG:
-		c->analog.soundsys  = p->u.analog.soundsys;
-		c->analog.audmode   = p->u.analog.audmode;
-		c->analog.std       = p->u.analog.std;
-		c->analog.flag      = p->u.analog.flag;
-		c->analog.afc_range = p->u.analog.afc_range;
-		c->analog.reserved  = p->u.analog.reserved;
-		break;
 	case DVBV3_UNKNOWN:
 		dev_err(fe->dvb->device,
 				"%s: doesn't know how to handle a DVBv3 call to delivery system %i\n",
@@ -1618,7 +1178,7 @@ static int dtv_property_legacy_params_sync(struct dvb_frontend *fe,
 
 	p->frequency = c->frequency;
 	p->inversion = c->inversion;
-	dtvprintk("[get frontend]p is %d\n",p->frequency);
+
 	switch (dvbv3_type(c->delivery_system)) {
 	case DVBV3_UNKNOWN:
 		dev_err(fe->dvb->device,
@@ -1667,21 +1227,11 @@ static int dtv_property_legacy_params_sync(struct dvb_frontend *fe,
 		p->u.ofdm.transmission_mode = c->transmission_mode;
 		p->u.ofdm.guard_interval = c->guard_interval;
 		p->u.ofdm.hierarchy_information = c->hierarchy;
-		p->u.ofdm.ofdm_mode = c->ofdm_mode;
 		break;
 	case DVBV3_ATSC:
 		dev_dbg(fe->dvb->device, "%s: Preparing VSB req\n", __func__);
 		p->u.vsb.modulation = c->modulation;
 		break;
-	case DVBV3_ANALOG:
-		p->u.analog.soundsys = c->analog.soundsys;
-		p->u.analog.audmode  = c->analog.audmode;
-		p->u.analog.std      = c->analog.std;
-		p->u.analog.flag     = c->analog.flag;
-		p->u.analog.afc_range= c->analog.afc_range;
-		p->u.analog.reserved = c->analog.reserved;
-		break;
-
 	}
 	return 0;
 }
@@ -1954,8 +1504,7 @@ static bool is_dvbv3_delsys(u32 delsys)
 	bool status;
 
 	status = (delsys == SYS_DVBT) || (delsys == SYS_DVBC_ANNEX_A) ||
-		 (delsys == SYS_DVBS) || (delsys == SYS_ATSC) || (delsys == SYS_DTMB) ||
-		 (delsys == SYS_ISDBT)|| (delsys == SYS_ANALOG) || (delsys == SYS_DVBS2);
+		 (delsys == SYS_DVBS) || (delsys == SYS_ATSC);
 
 	return status;
 }
@@ -2350,38 +1899,10 @@ static int dvb_frontend_ioctl(struct file *file,
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
 	int err = -EOPNOTSUPP;
-	int need_lock = 1;
-	int need_blindscan = 0;
 
 	dev_dbg(fe->dvb->device, "%s: (%d)\n", __func__, _IOC_NR(cmd));
-	if (fepriv->exit != DVB_FE_NO_EXIT)
-		return -ENODEV;
-
-	if ((file->f_flags & O_ACCMODE) == O_RDONLY &&
-	    (_IOC_DIR(cmd) != _IOC_READ || cmd == FE_GET_EVENT ||
-	     cmd == FE_DISEQC_RECV_SLAVE_REPLY))
-		return -EPERM;
-
-	if (cmd==FE_READ_STATUS ||
-			cmd==FE_READ_BER ||
-			cmd==FE_READ_SIGNAL_STRENGTH ||
-			cmd==FE_READ_SNR ||
-			cmd==FE_READ_UNCORRECTED_BLOCKS ||
-			cmd==FE_GET_FRONTEND ||
-			cmd==FE_READ_AFC ||
-			cmd==FE_SET_BLINDSCAN ||
-			cmd==FE_GET_BLINDSCANEVENT ||
-			cmd==FE_SET_BLINDSCANCANCEl)
-		need_lock = 0;
-
-	if (cmd==FE_SET_BLINDSCAN ||
-			cmd==FE_GET_BLINDSCANEVENT ||
-			cmd==FE_SET_BLINDSCANCANCEl)
-		need_blindscan = 1;
-
-	if (need_lock)
-		if (down_interruptible(&fepriv->sem))
-			return -ERESTARTSYS;
+	if (down_interruptible(&fepriv->sem))
+		return -ERESTARTSYS;
 
 	if (fepriv->exit != DVB_FE_NO_EXIT) {
 		up(&fepriv->sem);
@@ -2395,14 +1916,6 @@ static int dvb_frontend_ioctl(struct file *file,
 		return -EPERM;
 	}
 
-	if (need_blindscan)
-		if (down_interruptible (&fepriv->blindscan_sem))
-			return -ERESTARTSYS;
-
-	if(cmd==FE_SET_FRONTEND ||
-			cmd==FE_SET_MODE)
-		dvb_frontend_asyncwakeup(fe);
-
 	if ((cmd == FE_SET_PROPERTY) || (cmd == FE_GET_PROPERTY))
 		err = dvb_frontend_ioctl_properties(file, cmd, parg);
 	else {
@@ -2410,12 +1923,7 @@ static int dvb_frontend_ioctl(struct file *file,
 		err = dvb_frontend_ioctl_legacy(file, cmd, parg);
 	}
 
-	if (need_blindscan)
-		up(&fepriv->blindscan_sem);
-
-	if (need_lock)
-		up(&fepriv->sem);
-
+	up(&fepriv->sem);
 	return err;
 }
 
@@ -2525,7 +2033,6 @@ static int dtv_set_frontend(struct dvb_frontend *fe)
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	struct dvb_frontend_tune_settings fetunesettings;
 	u32 rolloff = 0;
-	printk("dtv_set_frontend\n");
 
 	if (dvb_frontend_check_parameters(fe) < 0)
 		return -EINVAL;
@@ -2600,16 +2107,16 @@ static int dtv_set_frontend(struct dvb_frontend *fe)
 		case SYS_DVBC_ANNEX_A:
 		case SYS_DVBC_ANNEX_C:
 			fepriv->min_delay = HZ / 20;
-			fepriv->step_size = 0;
-			fepriv->max_drift = 0;
+			fepriv->step_size = c->symbol_rate / 16000;
+			fepriv->max_drift = c->symbol_rate / 2000;
 			break;
 		case SYS_DVBT:
 		case SYS_DVBT2:
 		case SYS_ISDBT:
 		case SYS_DTMB:
 			fepriv->min_delay = HZ / 20;
-			fepriv->step_size = 0;//fe->ops.info.frequency_stepsize * 2;
-			fepriv->max_drift = 0;//(fe->ops.info.frequency_stepsize * 2) + 1;
+			fepriv->step_size = fe->ops.info.frequency_stepsize * 2;
+			fepriv->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;
 			break;
 		default:
 			/*
@@ -2629,16 +2136,10 @@ static int dtv_set_frontend(struct dvb_frontend *fe)
 
 	/* Request the search algorithm to search */
 	fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
-	if(c->delivery_system==SYS_ANALOG && (c->analog.flag & ANALOG_FLAG_ENABLE_AFC)){
-		dvb_frontend_add_event(fe, 0);
-		dvb_frontend_wakeup(fe);
-	}else if (fe->ops.set_frontend){
-		fe->ops.set_frontend(fe);
-		if(c->delivery_system!=SYS_ANALOG)
-			dvb_frontend_clear_events(fe);
-			dvb_frontend_add_event(fe, 0);
-			dvb_frontend_wakeup(fe);
-	}
+
+	dvb_frontend_clear_events(fe);
+	dvb_frontend_add_event(fe, 0);
+	dvb_frontend_wakeup(fe);
 	fepriv->status = 0;
 
 	return 0;
@@ -2868,21 +2369,16 @@ static int dvb_frontend_ioctl_legacy(struct file *file,
 			err = fe->ops.enable_high_lnb_voltage(fe, (long) parg);
 		break;
 
-	case FE_SET_FRONTEND: {
-		if(disable_set_frotend_param)
-		    break;
-		printk("FE_SET_FRONTEND\n");
+	case FE_SET_FRONTEND:
 		err = dvbv3_set_delivery_system(fe);
 		if (err)
 			break;
+
 		err = dtv_property_cache_sync(fe, c, parg);
 		if (err)
 			break;
-		jiffiestime=jiffies_to_msecs(jiffies);
 		err = dtv_set_frontend(fe);
 		break;
-	}
-
 	case FE_GET_EVENT:
 		err = dvb_frontend_get_event (fe, parg, file->f_flags);
 		break;
@@ -2895,146 +2391,6 @@ static int dvb_frontend_ioctl_legacy(struct file *file,
 		fepriv->tune_mode_flags = (unsigned long) parg;
 		err = 0;
 		break;
-
-	case FE_SET_DELAY:
-		fepriv->user_delay = (int)parg;
-		err = 0;
-		break;
-
-	case FE_SET_MODE:
-		if(fe->ops.set_mode){
-			err = fe->ops.set_mode(fe, (int)parg);
-		if(err == 0){
-			switch((int)parg){
-			case FE_QPSK:
-				c->delivery_system = SYS_DVBS2;//DVBV3_QPSK;
-				break;
-			case FE_QAM:
-				c->delivery_system = SYS_DVBC_ANNEX_A;//DVBV3_QAM;
-				break;
-			case FE_OFDM:
-				c->delivery_system = SYS_DVBT;//DVBV3_OFDM;
-				break;
-			case FE_ATSC:
-				c->delivery_system = SYS_ATSC;//DVBV3_ATSC;
-				break;
-			case FE_ANALOG:
-				c->delivery_system = SYS_ANALOG;//DVBV3_ANALOG;
-				break;
-			case FE_DTMB:
-				c->delivery_system = SYS_DTMB;//DVBV3_OFDM;
-				break;
-			case FE_ISDBT:
-				c->delivery_system = SYS_ISDBT;//DVBV3_OFDM;
-			break;
-				}
-			}
-		}
-		break;
-
-	case FE_READ_TS:
-		if(fe->ops.read_ts){
-			err = fe->ops.read_ts(fe, (int*)parg);
-		}
-		break;
-
-    case FE_FINE_TUNE:
-       if(fe->ops.tuner_ops.fine_tune){
-            err = fe->ops.tuner_ops.fine_tune(fe, *((int*)parg));
-       }
-       break;
-    case FE_READ_TUNER_STATUS:
-       if(fe->ops.tuner_ops.get_tuner_status){
-            tuner_status_t parm_status = {0};
-            tuner_status_t *tmsp = parg;
-            err = fe->ops.tuner_ops.get_tuner_status(fe, &parm_status);
-            memcpy(tmsp,&parm_status,sizeof(tuner_status_t));
-       }
-       break;
-    case FE_READ_ANALOG_STATUS:
-       if(fe->ops.analog_ops.get_atv_status){
-            atv_status_t atv_stats = {0};
-            atv_status_t *tmap = parg;
-            err = fe->ops.analog_ops.get_atv_status(fe, &atv_stats);
-            memcpy(tmap,&atv_stats,sizeof(atv_status_t));
-       }
-       break;
-    case FE_READ_SD_STATUS:
-       if(fe->ops.analog_ops.get_sd_status){
-        sound_status_t sound_sts = {0};
-            err = fe->ops.analog_ops.get_sd_status(fe, &sound_sts);
-            memcpy(parg,&sound_sts,sizeof(sound_status_t));
-       }
-       break;
-    case FE_SET_PARAM_BOX:
-        if(fe->ops.tuner_ops.set_config){
-            tuner_param_t tuner_parm = {0};
-            memcpy(&tuner_parm, parg, sizeof(tuner_param_t));
-            err = fe->ops.tuner_ops.set_config(fe, &tuner_parm);
-            memcpy(parg,&tuner_parm, sizeof(tuner_param_t));
-        }
-        break;
-
-	case  FE_SET_BLINDSCAN:
-		memcpy (&(fe->ops.blindscan_ops.info.bspara), parg, sizeof (struct dvbsx_blindscanpara));
-
-		dprintk("FE_SET_BLINDSCAN %d %d %d %d %d %d %d\n",
-				fe->ops.blindscan_ops.info.bspara.minfrequency,
-				fe->ops.blindscan_ops.info.bspara.maxfrequency,
-				fe->ops.blindscan_ops.info.bspara.minSymbolRate,
-				fe->ops.blindscan_ops.info.bspara.maxSymbolRate,
-				fe->ops.blindscan_ops.info.bspara.frequencyRange,
-				fe->ops.blindscan_ops.info.bspara.frequencyStep,
-				fe->ops.blindscan_ops.info.bspara.timeout);
-
-		/*register*/
-		fe->ops.blindscan_ops.info.blindscan_callback = dvbsx_blindscan_event_callback;
-
-		fepriv->in_blindscan = true;
-
-		if (fe->ops.blindscan_ops.blindscan_scan)
-			err = fe->ops.blindscan_ops.blindscan_scan(fe, &(fe->ops.blindscan_ops.info.bspara));
-		break;
-
-	case  FE_GET_BLINDSCANEVENT:
-		{
-			struct dvbsx_blindscanevent *p_tmp_bsevent = NULL;
-
-			err = dvbsx_blindscan_get_event (fe, (struct dvbsx_blindscanevent*) parg, file->f_flags);
-
-			p_tmp_bsevent = (struct dvbsx_blindscanevent*) parg;
-
-			dprintk("FE_GET_BLINDSCANEVENT status:%d\n", p_tmp_bsevent->status);
-
-			if(p_tmp_bsevent->status == BLINDSCAN_UPDATESTARTFREQ)
-			{
-				dprintk("start freq %d\n", p_tmp_bsevent->u.m_uistartfreq_khz);
-			}
-			else if(p_tmp_bsevent->status == BLINDSCAN_UPDATEPROCESS)
-			{
-				dprintk("process %d\n", p_tmp_bsevent->u.m_uiprogress);
-			}
-			else if(p_tmp_bsevent->status == BLINDSCAN_UPDATERESULTFREQ)
-			{
-				dprintk("result freq %d symb %d\n", p_tmp_bsevent->u.parameters.frequency, p_tmp_bsevent->u.parameters.u.qpsk.symbol_rate);
-			}
-			break;
-		}
-
-	case  FE_SET_BLINDSCANCANCEl:
-		dprintk("FE_SET_BLINDSCANCANCEl\n");
-
-
-		if (fe->ops.blindscan_ops.blindscan_cancel)
-			err = fe->ops.blindscan_ops.blindscan_cancel(fe);
-
-		fepriv->in_blindscan = false;
-
-		/*unregister*/
-		fe->ops.blindscan_ops.info.blindscan_callback = NULL;
-
-		break;
-
 	}
 
 	return err;
@@ -3136,7 +2492,6 @@ static int dvb_frontend_open(struct inode *inode, struct file *file)
 
 		/*  empty event queue */
 		fepriv->events.eventr = fepriv->events.eventw = 0;
-		fepriv->blindscan_events.eventr = fepriv->blindscan_events.eventw = 0;
 	}
 
 	if (adapter->mfe_shared)
@@ -3172,8 +2527,11 @@ static int dvb_frontend_release(struct inode *inode, struct file *file)
 
 	if (dvbdev->users == -1) {
 		wake_up(&fepriv->wait_queue);
-		if (fepriv->exit != DVB_FE_NO_EXIT)
+		if (fepriv->exit != DVB_FE_NO_EXIT) {
+			fops_put(file->f_op);
+			file->f_op = NULL;
 			wake_up(&dvbdev->wait_queue);
+		}
 		if (fe->ops.ts_bus_ctrl)
 			fe->ops.ts_bus_ctrl(fe, 0);
 	}
@@ -3228,25 +2586,6 @@ int dvb_frontend_resume(struct dvb_frontend *fe)
 }
 EXPORT_SYMBOL(dvb_frontend_resume);
 
-
-static ssize_t dvbc_lock_show(struct class *cls,struct class_attribute *attr,char *buf)
-{
-	return sprintf(buf, "dvbc_autoflags: %s\n", LOCK_TIMEOUT?"on":"off");
-}
-static ssize_t dvbc_lock_store(struct class *cls, struct class_attribute *attr, const char *buf, size_t count)
-{
-	int mode = simple_strtol(buf,0,16);
-	printk("autoflags is %d\n",mode);
-	LOCK_TIMEOUT= mode;
-	return count;
-
-}
-
-static CLASS_ATTR(lock_time,0644,dvbc_lock_show,dvbc_lock_store);
-
-struct class *tongfang_clsp;
-#define LOCK_DEVICE_NAME  "tongfang"
-
 int dvb_register_frontend(struct dvb_adapter* dvb,
 			  struct dvb_frontend* fe)
 {
@@ -3259,7 +2598,6 @@ int dvb_register_frontend(struct dvb_adapter* dvb,
 		.kernel_ioctl = dvb_frontend_ioctl
 	};
 
-	int ret;
 	dev_dbg(dvb->device, "%s:\n", __func__);
 
 	if (mutex_lock_interruptible(&frontend_mutex))
@@ -3273,41 +2611,18 @@ int dvb_register_frontend(struct dvb_adapter* dvb,
 	fepriv = fe->frontend_priv;
 
 	sema_init(&fepriv->sem, 1);
-	sema_init(&fepriv->blindscan_sem, 1);
 	init_waitqueue_head (&fepriv->wait_queue);
 	init_waitqueue_head (&fepriv->events.wait_queue);
-	init_waitqueue_head (&fepriv->blindscan_events.wait_queue);
 	mutex_init(&fepriv->events.mtx);
-	mutex_init(&fepriv->blindscan_events.mtx);
 	fe->dvb = dvb;
 	fepriv->inversion = INVERSION_OFF;
 
-	init_waitqueue_head (&fepriv->setfrontendasync_wait_queue);
-	fepriv->setfrontendasync_wakeup = 0;
-	fepriv->setfrontendasync_needwakeup = 0;
-	fepriv->setfrontendasync_interruptwakeup = 0;
-
-	fe->ops.asyncinfo.set_frontend_asyncpreproc = dvb_frontend_asyncpreproc;
-	fe->ops.asyncinfo.set_frontend_asyncwait = dvb_frontend_asyncwait;
-	fe->ops.asyncinfo.set_frontend_asyncpostproc = dvb_frontend_asyncpostproc;
-
 	dev_info(fe->dvb->device,
 			"DVB: registering adapter %i frontend %i (%s)...\n",
 			fe->dvb->num, fe->id, fe->ops.info.name);
 
 	dvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,
 			     fe, DVB_DEVICE_FRONTEND);
-	printk("For tongfang\n");
-	ret=0;
-	tongfang_clsp = class_create(THIS_MODULE,LOCK_DEVICE_NAME);
-	if(!tongfang_clsp)
-	{
-			 printk("[tongfang]%s:create class error.\n",__func__);
-			 return PTR_ERR(tongfang_clsp);
-	}
-	ret = class_create_file(tongfang_clsp, &class_attr_lock_time);
-	if(ret)
-		printk("[tongfang]%s create  class file error.\n",__func__);
 
 	/*
 	 * Initialize the cache to the proper values according with the
@@ -3337,8 +2652,6 @@ int dvb_unregister_frontend(struct dvb_frontend* fe)
 
 	mutex_lock(&frontend_mutex);
 	dvb_unregister_device (fepriv->dvbdev);
-	class_remove_file(tongfang_clsp, &class_attr_lock_time);
-	class_destroy(tongfang_clsp);
 
 	/* fe is invalid now */
 	kfree(fepriv);
@@ -3384,17 +2697,3 @@ void dvb_frontend_detach(struct dvb_frontend* fe)
 }
 #endif
 EXPORT_SYMBOL(dvb_frontend_detach);
-
-void dvb_frontend_retune(struct dvb_frontend *fe)
-{
-	struct dvb_frontend_private *fepriv = fe->frontend_priv;
-
-	fepriv->state = FESTATE_RETUNE;
-
-	fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
-
-	dvb_frontend_wakeup(fe);
-	fepriv->status = 0;
-}
-EXPORT_SYMBOL(dvb_frontend_retune);
-
diff --git a/drivers/media/dvb-core/dvb_frontend.h b/drivers/media/dvb-core/dvb_frontend.h
index ecb4011..b34922a 100755
--- a/drivers/media/dvb-core/dvb_frontend.h
+++ b/drivers/media/dvb-core/dvb_frontend.h
@@ -38,7 +38,6 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 
-#include <linux/dvb/aml_demod.h>
 #include <linux/dvb/frontend.h>
 
 #include "dvbdev.h"
@@ -72,12 +71,8 @@ struct dvb_tuner_info {
 struct analog_parameters {
 	unsigned int frequency;
 	unsigned int mode;
-	unsigned int soundsys;//A2,BTSC/EIAJ/NICAM
 	unsigned int audmode;
-	unsigned int lock_range;
-	unsigned int leap_step;
-	v4l2_std_id std;
-	unsigned int reserved;
+	u64 std;
 };
 
 enum dvbfe_modcod {
@@ -223,30 +218,21 @@ struct dvb_tuner_ops {
 
 #define TUNER_STATUS_LOCKED 1
 #define TUNER_STATUS_STEREO 2
-	int (*get_status)(struct dvb_frontend *fe, void *status);
-	void (*get_pll_status)(struct dvb_frontend *fe, void *status);
+	int (*get_status)(struct dvb_frontend *fe, u32 *status);
 	int (*get_rf_strength)(struct dvb_frontend *fe, u16 *strength);
 	int (*get_afc)(struct dvb_frontend *fe, s32 *afc);
-	int  (*get_snr)(struct dvb_frontend *fe);
 
 	/** These are provided separately from set_params in order to facilitate silicon
 	 * tuners which require sophisticated tuning loops, controlling each parameter separately. */
 	int (*set_frequency)(struct dvb_frontend *fe, u32 frequency);
 	int (*set_bandwidth)(struct dvb_frontend *fe, u32 bandwidth);
 
-	int (*set_tuner)(struct dvb_frontend *fe, struct aml_demod_sta *demod_sta, struct aml_demod_i2c *demod_i2c, struct aml_tuner_sys *tuner_sys);
-	int (*get_strength)(struct dvb_frontend *fe);
-
 	/*
 	 * These are provided separately from set_params in order to facilitate silicon
 	 * tuners which require sophisticated tuning loops, controlling each parameter separately.
 	 */
 	int (*set_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
 	int (*get_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
-    /*add function to get tuner status*/
-    int (*get_tuner_status)(struct dvb_frontend *fe, tuner_status_t *tuner_status);
-    /*add special fine tune function */
-    int (*fine_tune)(struct dvb_frontend *fe, int offset_khz);
 };
 
 struct analog_demod_info {
@@ -259,12 +245,8 @@ struct analog_demod_ops {
 
 	void (*set_params)(struct dvb_frontend *fe,
 			   struct analog_parameters *params);
-	int  (*has_signal)(struct dvb_frontend *fe, u16 *signal);
-	int  (*get_afc)(struct dvb_frontend *fe, s32 *afc);
-	int  (*is_stereo)(struct dvb_frontend *fe);
-	int  (*get_snr)(struct dvb_frontend *fe);
-	int (*get_status)(struct dvb_frontend *fe, void *status);
-	void (*get_pll_status)(struct dvb_frontend *fe, void *status);
+	int  (*has_signal)(struct dvb_frontend *fe);
+	int  (*get_afc)(struct dvb_frontend *fe);
 	void (*tuner_status)(struct dvb_frontend *fe);
 	void (*standby)(struct dvb_frontend *fe);
 	void (*release)(struct dvb_frontend *fe);
@@ -272,37 +254,10 @@ struct analog_demod_ops {
 
 	/** This is to allow setting tuner-specific configuration */
 	int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
-    /*add function to get atv_demod & stereo_demod status*/
-    int (*get_atv_status)(struct dvb_frontend *fe, atv_status_t *atv_status);
-    int (*get_sd_status)(struct dvb_frontend *fe, sound_status_t *sd_status);
 };
 
 struct dtv_frontend_properties;
 
-struct dvbsx_blindscan_info {
-	/* timeout of get blindscan event */
-	struct dvbsx_blindscanpara bspara;
-	int (*blindscan_callback)(struct dvb_frontend *fe, struct dvbsx_blindscanevent *pbsevent);
-};
-
-struct dvbsx_blindscan_ops {
-	struct dvbsx_blindscan_info info;
-
-	/*
-	 *  These are provided start and stop blindscan
-	 */
-	int (*blindscan_scan)(struct dvb_frontend* fe, struct dvbsx_blindscanpara *pbspara);
-	int (*blindscan_cancel)(struct dvb_frontend* fe);
-};
-
-struct dvb_frontend_asyncinfo {
-	int set_frontend_asyncenable;
-	int (*set_frontend_asyncpreproc)(struct dvb_frontend *fe);
-	/*return value = 1 interrupt, = 0 timeout,  = -1 error*/
-	int (*set_frontend_asyncwait)(struct dvb_frontend *fe, u32 timeout);
-	int (*set_frontend_asyncpostproc)(struct dvb_frontend *fe, int asyncwait_ret);
-};
-
 struct dvb_frontend_ops {
 
 	struct dvb_frontend_info info;
@@ -327,17 +282,16 @@ struct dvb_frontend_ops {
 	enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *fe);
 
 	/* these two are only used for the swzigzag code */
-	int (*set_frontend)(struct dvb_frontend* fe);
+	int (*set_frontend)(struct dvb_frontend *fe);
 	int (*get_tune_settings)(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* settings);
 
-	int (*get_frontend)(struct dvb_frontend* fe);
+	int (*get_frontend)(struct dvb_frontend *fe);
 
 	int (*read_status)(struct dvb_frontend* fe, fe_status_t* status);
 	int (*read_ber)(struct dvb_frontend* fe, u32* ber);
 	int (*read_signal_strength)(struct dvb_frontend* fe, u16* strength);
 	int (*read_snr)(struct dvb_frontend* fe, u16* snr);
 	int (*read_ucblocks)(struct dvb_frontend* fe, u32* ucblocks);
-	int (*set_qam_mode)(struct dvb_frontend* fe);
 
 	int (*diseqc_reset_overload)(struct dvb_frontend* fe);
 	int (*diseqc_send_master_cmd)(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd);
@@ -355,22 +309,15 @@ struct dvb_frontend_ops {
 	 * tuning algorithms, rather than a simple swzigzag
 	 */
 	enum dvbfe_search (*search)(struct dvb_frontend *fe);
-	int (*track)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
 
 	struct dvb_tuner_ops tuner_ops;
 	struct analog_demod_ops analog_ops;
 
 	int (*set_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
 	int (*get_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
-
-	struct dvbsx_blindscan_ops blindscan_ops;
-
-	int (*set_mode)(struct dvb_frontend* fe, fe_type_t type);
-	int (*read_ts)(struct dvb_frontend* fe, int *ts);
-
-	struct dvb_frontend_asyncinfo asyncinfo;
 };
 
+#ifdef __DVB_CORE__
 #define MAX_EVENT 8
 
 struct dvb_fe_events {
@@ -381,17 +328,7 @@ struct dvb_fe_events {
 	wait_queue_head_t	  wait_queue;
 	struct mutex		  mtx;
 };
-
-#define MAX_BLINDSCAN_EVENT 32
-
-struct dvbsx_blindscan_events {
-	struct dvbsx_blindscanevent events[MAX_BLINDSCAN_EVENT];
-	int			  eventw;
-	int			  eventr;
-	int			  overflow;
-	wait_queue_head_t	  wait_queue;
-	struct mutex		  mtx;
-};
+#endif
 
 struct dtv_frontend_properties {
 
@@ -416,8 +353,6 @@ struct dtv_frontend_properties {
 	fe_pilot_t		pilot;
 	fe_rolloff_t		rolloff;
 
-	fe_ofdm_mode_t      ofdm_mode;
-
 	fe_delivery_system_t	delivery_system;
 
 	enum fe_interleaving	interleaving;
@@ -439,11 +374,6 @@ struct dtv_frontend_properties {
 	/* Multistream specifics */
 	u32			stream_id;
 
-	u32         dvbt2_plp_id;
-
-	/* Analog specifics */
-	struct dvb_analog_parameters analog;
-	struct dvb_analog_parameters param;
 	/* ATSC-MH specifics */
 	u8			atscmh_fic_ver;
 	u8			atscmh_parade_id;
diff --git a/drivers/media/dvb-core/dvb_net.c b/drivers/media/dvb-core/dvb_net.c
index f91c80c..44225b1 100755
--- a/drivers/media/dvb-core/dvb_net.c
+++ b/drivers/media/dvb-core/dvb_net.c
@@ -185,7 +185,7 @@ static __be16 dvb_net_eth_type_trans(struct sk_buff *skb,
 			skb->pkt_type=PACKET_MULTICAST;
 	}
 
-	if (ntohs(eth->h_proto) >= ETH_P_802_3_MIN)
+	if (ntohs(eth->h_proto) >= 1536)
 		return eth->h_proto;
 
 	rawp = skb->data;
@@ -228,9 +228,9 @@ static int ule_test_sndu( struct dvb_net_priv *p )
 static int ule_bridged_sndu( struct dvb_net_priv *p )
 {
 	struct ethhdr *hdr = (struct ethhdr*) p->ule_next_hdr;
-	if(ntohs(hdr->h_proto) < ETH_P_802_3_MIN) {
+	if(ntohs(hdr->h_proto) < 1536) {
 		int framelen = p->ule_sndu_len - ((p->ule_next_hdr+sizeof(struct ethhdr)) - p->ule_skb->data);
-		/* A frame Type < ETH_P_802_3_MIN for a bridged frame, introduces a LLC Length field. */
+		/* A frame Type < 1536 for a bridged frame, introduces a LLC Length field. */
 		if(framelen != ntohs(hdr->h_proto)) {
 			return -1;
 		}
@@ -320,7 +320,7 @@ static int handle_ule_extensions( struct dvb_net_priv *p )
 			(int) p->ule_sndu_type, l, total_ext_len);
 #endif
 
-	} while (p->ule_sndu_type < ETH_P_802_3_MIN);
+	} while (p->ule_sndu_type < 1536);
 
 	return total_ext_len;
 }
@@ -712,7 +712,7 @@ static void dvb_net_ule( struct net_device *dev, const u8 *buf, size_t buf_len )
 				}
 
 				/* Handle ULE Extension Headers. */
-				if (priv->ule_sndu_type < ETH_P_802_3_MIN) {
+				if (priv->ule_sndu_type < 1536) {
 					/* There is an extension header.  Handle it accordingly. */
 					int l = handle_ule_extensions(priv);
 					if (l < 0) {
@@ -1044,7 +1044,7 @@ static int dvb_net_feed_start(struct net_device *dev)
 		ret = priv->tsfeed->set(priv->tsfeed,
 					priv->pid, /* pid */
 					TS_PACKET, /* type */
-					DMX_PES_OTHER, /* pes type */
+					DMX_TS_PES_OTHER, /* pes type */
 					32768,     /* circular buffer size */
 					timeout    /* timeout */
 					);
@@ -1479,8 +1479,11 @@ static int dvb_net_close(struct inode *inode, struct file *file)
 
 	dvb_generic_release(inode, file);
 
-	if(dvbdev->users == 1 && dvbnet->exit == 1)
+	if(dvbdev->users == 1 && dvbnet->exit == 1) {
+		fops_put(file->f_op);
+		file->f_op = NULL;
 		wake_up(&dvbdev->wait_queue);
+	}
 	return 0;
 }
 
diff --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
index 9fb1090..627ef81 100755
--- a/drivers/media/dvb-core/dvbdev.c
+++ b/drivers/media/dvb-core/dvbdev.c
@@ -47,7 +47,7 @@ static DEFINE_MUTEX(dvbdev_register_lock);
 
 static const char * const dnames[] = {
 	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
-	"net", "osd", "dsc"
+	"net", "osd"
 };
 
 #ifdef CONFIG_DVB_DYNAMIC_MINORS
@@ -462,6 +462,7 @@ static int __init init_dvbdev(void)
 {
 	int retval;
 	dev_t dev = MKDEV(DVB_MAJOR, 0);
+	printk(KERN_ERR "WARNING: You are using an experimental version of the media stack.\n\tAs the driver is backported to an older kernel, it doesn't offer\n\tenough quality for its usage in production.\n\tUse it with care.\nLatest git patches (needed if you report a bug to linux-media@vger.kernel.org):\n\t6bf7861fa2bb4be3cc70a6e9aed664ce65270027 [media] si476x: Fix some config dependencies and a compile warnings\n\tb0efc3ed0530b08e9e1cba5f63e9c251ca3d7428 [media] m920x: Fix uninitialized variable warning\n\t46f85978687152c53a69fc06951e386f194e7f5d [media] em28xx: fix typo in scale_to_size()\n");
 
 	if ((retval = register_chrdev_region(dev, MAX_DVB_MINORS, "DVB")) != 0) {
 		printk(KERN_ERR "dvb-core: unable to get major %d\n", DVB_MAJOR);
diff --git a/drivers/media/dvb-core/dvbdev.h b/drivers/media/dvb-core/dvbdev.h
index d2bee9c..93a9470 100755
--- a/drivers/media/dvb-core/dvbdev.h
+++ b/drivers/media/dvb-core/dvbdev.h
@@ -47,7 +47,6 @@
 #define DVB_DEVICE_CA         6
 #define DVB_DEVICE_NET        7
 #define DVB_DEVICE_OSD        8
-#define DVB_DEVICE_DSC        9
 
 #define DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr) \
 	static short adapter_nr[] = \
diff --git a/drivers/media/dvb-frontends/Kconfig b/drivers/media/dvb-frontends/Kconfig
index 0ba4858..ce5aa4e 100644
--- a/drivers/media/dvb-frontends/Kconfig
+++ b/drivers/media/dvb-frontends/Kconfig
@@ -235,6 +235,20 @@ config DVB_DS3000
 	help
 	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
 
+config DVB_TS2022
+	tristate "Montage Tehnology TS2022 based tuners"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-S/S2 silicon tuner. Say Y when you want to support this tuner.
+
+config DVB_DS3103
+	tristate "Montage Tehnology DS3103 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
 config DVB_MB86A16
 	tristate "Fujitsu MB86A16 based"
 	depends on DVB_CORE && I2C
diff --git a/drivers/media/dvb-frontends/Makefile b/drivers/media/dvb-frontends/Makefile
index 56ab1d2..3c1ffe5 100644
--- a/drivers/media/dvb-frontends/Makefile
+++ b/drivers/media/dvb-frontends/Makefile
@@ -105,3 +105,6 @@ obj-$(CONFIG_DVB_M88RS2000) += m88rs2000.o
 obj-$(CONFIG_DVB_AF9033) += af9033.o
 obj-$(CONFIG_DVB_M88DS3103) += m88ds3103.o
 obj-$(CONFIG_DVB_M88DC2800) += m88dc2800.o
+obj-$(CONFIG_DVB_DS3103) += ds3103.o
+obj-$(CONFIG_DVB_TS2022) += ts2022.o
+
diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index fb504f1..a204f28 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -24,9 +24,6 @@
 
 #include "af9013_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 struct af9013_state {
 	struct i2c_adapter *i2c;
 	struct dvb_frontend fe;
@@ -53,23 +50,16 @@ static int af9013_wr_regs_i2c(struct af9013_state *priv, u8 mbox, u16 reg,
 	const u8 *val, int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[3+len];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = priv->config.i2c_addr,
 			.flags = 0,
-			.len = 3 + len,
+			.len = sizeof(buf),
 			.buf = buf,
 		}
 	};
 
-	if (3 + len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	buf[0] = (reg >> 8) & 0xff;
 	buf[1] = (reg >> 0) & 0xff;
 	buf[2] = mbox;
diff --git a/drivers/media/dvb-frontends/af9033.c b/drivers/media/dvb-frontends/af9033.c
index 65728c2..a777b4b 100644
--- a/drivers/media/dvb-frontends/af9033.c
+++ b/drivers/media/dvb-frontends/af9033.c
@@ -21,9 +21,6 @@
 
 #include "af9033_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 struct af9033_state {
 	struct i2c_adapter *i2c;
 	struct dvb_frontend fe;
@@ -43,23 +40,16 @@ static int af9033_wr_regs(struct af9033_state *state, u32 reg, const u8 *val,
 		int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[3 + len];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = state->cfg.i2c_addr,
 			.flags = 0,
-			.len = 3 + len,
+			.len = sizeof(buf),
 			.buf = buf,
 		}
 	};
 
-	if (3 + len > sizeof(buf)) {
-		dev_warn(&state->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	buf[0] = (reg >> 16) & 0xff;
 	buf[1] = (reg >>  8) & 0xff;
 	buf[2] = (reg >>  0) & 0xff;
@@ -170,18 +160,11 @@ static int af9033_rd_reg_mask(struct af9033_state *state, u32 reg, u8 *val,
 static int af9033_wr_reg_val_tab(struct af9033_state *state,
 		const struct reg_val *tab, int tab_len)
 {
-#define MAX_TAB_LEN 212
 	int ret, i, j;
-	u8 buf[1 + MAX_TAB_LEN];
+	u8 buf[tab_len];
 
 	dev_dbg(&state->i2c->dev, "%s: tab_len=%d\n", __func__, tab_len);
 
-	if (tab_len > sizeof(buf)) {
-		dev_warn(&state->i2c->dev, "%s: tab len %d is too big\n",
-				KBUILD_MODNAME, tab_len);
-		return -EINVAL;
-	}
-
 	for (i = 0, j = 0; i < tab_len; i++) {
 		buf[j] = tab[i].val;
 
diff --git a/drivers/media/dvb-frontends/bcm3510.c b/drivers/media/dvb-frontends/bcm3510.c
index 39a29dd..1b77909 100644
--- a/drivers/media/dvb-frontends/bcm3510.c
+++ b/drivers/media/dvb-frontends/bcm3510.c
@@ -44,9 +44,6 @@
 #include "bcm3510.h"
 #include "bcm3510_priv.h"
 
-/* Max transfer size done by bcm3510_do_hab_cmd() function */
-#define MAX_XFER_SIZE	128
-
 struct bcm3510_state {
 
 	struct i2c_adapter* i2c;
@@ -204,19 +201,9 @@ static int bcm3510_hab_send_request(struct bcm3510_state *st, u8 *buf, int len)
 
 static int bcm3510_do_hab_cmd(struct bcm3510_state *st, u8 cmd, u8 msgid, u8 *obuf, u8 olen, u8 *ibuf, u8 ilen)
 {
-	u8 ob[MAX_XFER_SIZE], ib[MAX_XFER_SIZE];
+	u8 ob[olen+2],ib[ilen+2];
 	int ret = 0;
 
-	if (ilen + 2 > sizeof(ib)) {
-		deb_hab("do_hab_cmd: ilen=%d is too big!\n", ilen);
-		return -EINVAL;
-	}
-
-	if (olen + 2 > sizeof(ob)) {
-		deb_hab("do_hab_cmd: olen=%d is too big!\n", olen);
-		return -EINVAL;
-	}
-
 	ob[0] = cmd;
 	ob[1] = msgid;
 	memcpy(&ob[2],obuf,olen);
diff --git a/drivers/media/dvb-frontends/cx24123.c b/drivers/media/dvb-frontends/cx24123.c
index a771da3..68c88ab 100644
--- a/drivers/media/dvb-frontends/cx24123.c
+++ b/drivers/media/dvb-frontends/cx24123.c
@@ -26,7 +26,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <asm/div64.h>
 
 #include "dvb_frontend.h"
 #include "cx24123.h"
@@ -453,8 +452,7 @@ static u32 cx24123_int_log2(u32 a, u32 b)
 
 static int cx24123_set_symbolrate(struct cx24123_state *state, u32 srate)
 {
-	u64 tmp;
-	u32 sample_rate, ratio, sample_gain;
+	u32 tmp, sample_rate, ratio, sample_gain;
 	u8 pll_mult;
 
 	/*  check if symbol rate is within limits */
@@ -484,11 +482,27 @@ static int cx24123_set_symbolrate(struct cx24123_state *state, u32 srate)
 
 	sample_rate = pll_mult * XTAL;
 
-	/* SYSSymbolRate[21:0] = (srate << 23) / sample_rate */
+	/*
+	    SYSSymbolRate[21:0] = (srate << 23) / sample_rate
+
+	    We have to use 32 bit unsigned arithmetic without precision loss.
+	    The maximum srate is 45000000 or 0x02AEA540. This number has
+	    only 6 clear bits on top, hence we can shift it left only 6 bits
+	    at a time. Borrowed from cx24110.c
+	*/
+
+	tmp = srate << 6;
+	ratio = tmp / sample_rate;
+
+	tmp = (tmp % sample_rate) << 6;
+	ratio = (ratio << 6) + (tmp / sample_rate);
+
+	tmp = (tmp % sample_rate) << 6;
+	ratio = (ratio << 6) + (tmp / sample_rate);
+
+	tmp = (tmp % sample_rate) << 5;
+	ratio = (ratio << 5) + (tmp / sample_rate);
 
-	tmp = ((u64)srate) << 23;
-	do_div(tmp, sample_rate);
-	ratio = (u32) tmp;
 
 	cx24123_writereg(state, 0x01, pll_mult * 6);
 
diff --git a/drivers/media/dvb-frontends/cxd2820r_core.c b/drivers/media/dvb-frontends/cxd2820r_core.c
index 03930d5..9b658c1 100644
--- a/drivers/media/dvb-frontends/cxd2820r_core.c
+++ b/drivers/media/dvb-frontends/cxd2820r_core.c
@@ -21,31 +21,21 @@
 
 #include "cxd2820r_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 /* write multiple registers */
 static int cxd2820r_wr_regs_i2c(struct cxd2820r_priv *priv, u8 i2c, u8 reg,
 	u8 *val, int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[len+1];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = i2c,
 			.flags = 0,
-			.len = len + 1,
+			.len = sizeof(buf),
 			.buf = buf,
 		}
 	};
 
-	if (1 + len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 
@@ -65,7 +55,7 @@ static int cxd2820r_rd_regs_i2c(struct cxd2820r_priv *priv, u8 i2c, u8 reg,
 	u8 *val, int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[len];
 	struct i2c_msg msg[2] = {
 		{
 			.addr = i2c,
@@ -75,18 +65,11 @@ static int cxd2820r_rd_regs_i2c(struct cxd2820r_priv *priv, u8 i2c, u8 reg,
 		}, {
 			.addr = i2c,
 			.flags = I2C_M_RD,
-			.len = len,
+			.len = sizeof(buf),
 			.buf = buf,
 		}
 	};
 
-	if (len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	ret = i2c_transfer(priv->i2c, msg, 2);
 	if (ret == 2) {
 		memcpy(val, buf, len);
@@ -677,8 +660,7 @@ static const struct dvb_frontend_ops cxd2820r_ops = {
 			FE_CAN_GUARD_INTERVAL_AUTO	|
 			FE_CAN_HIERARCHY_AUTO		|
 			FE_CAN_MUTE_TS			|
-			FE_CAN_2G_MODULATION		|
-			FE_CAN_MULTISTREAM
+			FE_CAN_2G_MODULATION
 		},
 
 	.release		= cxd2820r_release,
diff --git a/drivers/media/dvb-frontends/cxd2820r_t2.c b/drivers/media/dvb-frontends/cxd2820r_t2.c
index 2ba130e..e82d82a 100644
--- a/drivers/media/dvb-frontends/cxd2820r_t2.c
+++ b/drivers/media/dvb-frontends/cxd2820r_t2.c
@@ -124,23 +124,6 @@ int cxd2820r_set_frontend_t2(struct dvb_frontend *fe)
 	buf[1] = ((if_ctl >>  8) & 0xff);
 	buf[2] = ((if_ctl >>  0) & 0xff);
 
-	/* PLP filtering */
-	if (c->stream_id > 255) {
-		dev_dbg(&priv->i2c->dev, "%s: Disable PLP filtering\n", __func__);
-		ret = cxd2820r_wr_reg(priv, 0x023ad , 0);
-		if (ret)
-			goto error;
-	} else {
-		dev_dbg(&priv->i2c->dev, "%s: Enable PLP filtering = %d\n", __func__,
-				c->stream_id);
-		ret = cxd2820r_wr_reg(priv, 0x023af , c->stream_id & 0xFF);
-		if (ret)
-			goto error;
-		ret = cxd2820r_wr_reg(priv, 0x023ad , 1);
-		if (ret)
-			goto error;
-	}
-
 	ret = cxd2820r_wr_regs(priv, 0x020b6, buf, 3);
 	if (ret)
 		goto error;
diff --git a/drivers/media/dvb-frontends/dib0090.c b/drivers/media/dvb-frontends/dib0090.c
index 3ee22ff..d9fe60b 100644
--- a/drivers/media/dvb-frontends/dib0090.c
+++ b/drivers/media/dvb-frontends/dib0090.c
@@ -528,19 +528,20 @@ static void dib0090_reset_digital(struct dvb_frontend *fe, const struct dib0090_
 	u16 PllCfg, i, v;
 
 	HARD_RESET(state);
-	dib0090_write_reg(state, 0x24, EN_PLL | EN_CRYSTAL);
-	if (cfg->in_soc)
-		return;
 
+	dib0090_write_reg(state, 0x24, EN_PLL | EN_CRYSTAL);
 	dib0090_write_reg(state, 0x1b, EN_DIGCLK | EN_PLL | EN_CRYSTAL);	/* PLL, DIG_CLK and CRYSTAL remain */
-	/* adcClkOutRatio=8->7, release reset */
-	dib0090_write_reg(state, 0x20, ((cfg->io.adc_clock_ratio - 1) << 11) | (0 << 10) | (1 << 9) | (1 << 8) | (0 << 4) | 0);
-	if (cfg->clkoutdrive != 0)
-		dib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)
-				| (cfg->clkoutdrive << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));
-	else
-		dib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)
-				| (7 << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));
+
+	if (!cfg->in_soc) {
+		/* adcClkOutRatio=8->7, release reset */
+		dib0090_write_reg(state, 0x20, ((cfg->io.adc_clock_ratio - 1) << 11) | (0 << 10) | (1 << 9) | (1 << 8) | (0 << 4) | 0);
+		if (cfg->clkoutdrive != 0)
+			dib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)
+					  | (cfg->clkoutdrive << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));
+		else
+			dib0090_write_reg(state, 0x23, (0 << 15) | ((!cfg->analog_output) << 14) | (2 << 10) | (1 << 9) | (0 << 8)
+					  | (7 << 5) | (cfg->clkouttobamse << 4) | (0 << 2) | (0));
+	}
 
 	/* Read Pll current config * */
 	PllCfg = dib0090_read_reg(state, 0x21);
@@ -693,174 +694,192 @@ void dib0090_dcc_freq(struct dvb_frontend *fe, u8 fast)
 EXPORT_SYMBOL(dib0090_dcc_freq);
 
 static const u16 bb_ramp_pwm_normal_socs[] = {
-	550, /* max BB gain in 10th of dB */
-	(1<<9) | 8, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> BB_RAMP2 */
+	550,			/* max BB gain in 10th of dB */
+	(1 << 9) | 8,		/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> BB_RAMP2 */
 	440,
-	(4  << 9) | 0, /* BB_RAMP3 = 26dB */
-	(0  << 9) | 208, /* BB_RAMP4 */
-	(4  << 9) | 208, /* BB_RAMP5 = 29dB */
-	(0  << 9) | 440, /* BB_RAMP6 */
+	(4 << 9) | 0,		/* BB_RAMP3 = 26dB */
+	(0 << 9) | 208,		/* BB_RAMP4 */
+	(4 << 9) | 208,		/* BB_RAMP5 = 29dB */
+	(0 << 9) | 440,		/* BB_RAMP6 */
 };
 
-static const u16 rf_ramp_pwm_cband_7090p[] = {
-	280, /* max RF gain in 10th of dB */
-	18, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	504, /* ramp_max = maximum X used on the ramp */
-	(29 << 10) | 364, /* RF_RAMP5, LNA 1 = 8dB */
-	(0  << 10) | 504, /* RF_RAMP6, LNA 1 */
-	(60 << 10) | 228, /* RF_RAMP7, LNA 2 = 7.7dB */
-	(0  << 10) | 364, /* RF_RAMP8, LNA 2 */
-	(34 << 10) | 109, /* GAIN_4_1, LNA 3 = 6.8dB */
-	(0  << 10) | 228, /* GAIN_4_2, LNA 3 */
-	(37 << 10) | 0, /* RF_RAMP3, LNA 4 = 6.2dB */
-	(0  << 10) | 109, /* RF_RAMP4, LNA 4 */
+static const u16 rf_ramp_pwm_cband_7090[] = {
+	280,			/* max RF gain in 10th of dB */
+	18,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
+	504,			/* ramp_max = maximum X used on the ramp */
+	(29 << 10) | 364,	/* RF_RAMP5, LNA 1 = 8dB */
+	(0 << 10) | 504,	/* RF_RAMP6, LNA 1 */
+	(60 << 10) | 228,	/* RF_RAMP7, LNA 2 = 7.7dB */
+	(0 << 10) | 364,	/* RF_RAMP8, LNA 2 */
+	(34 << 10) | 109,	/* GAIN_4_1, LNA 3 = 6.8dB */
+	(0 << 10) | 228,	/* GAIN_4_2, LNA 3 */
+	(37 << 10) | 0,		/* RF_RAMP3, LNA 4 = 6.2dB */
+	(0 << 10) | 109,	/* RF_RAMP4, LNA 4 */
 };
 
-static const u16 rf_ramp_pwm_cband_7090e_sensitivity[] = {
-	186, /* max RF gain in 10th of dB */
-	40, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	746, /* ramp_max = maximum X used on the ramp */
-	(10 << 10) | 345, /* RF_RAMP5, LNA 1 = 10dB */
-	(0  << 10) | 746, /* RF_RAMP6, LNA 1 */
-	(0 << 10) | 0, /* RF_RAMP7, LNA 2 = 0 dB */
-	(0  << 10) | 0, /* RF_RAMP8, LNA 2 */
-	(28 << 10) | 200, /* GAIN_4_1, LNA 3 = 6.8dB */ /* 3.61 dB */
-	(0  << 10) | 345, /* GAIN_4_2, LNA 3 */
-	(20 << 10) | 0, /* RF_RAMP3, LNA 4 = 6.2dB */ /* 4.96 dB */
-	(0  << 10) | 200, /* RF_RAMP4, LNA 4 */
+static const uint16_t rf_ramp_pwm_cband_7090e_sensitivity[] = {
+	186,
+	40,
+	746,
+	(10 << 10) | 345,
+	(0  << 10) | 746,
+	(0 << 10) | 0,
+	(0  << 10) | 0,
+	(28 << 10) | 200,
+	(0  << 10) | 345,
+	(20 << 10) | 0,
+	(0  << 10) | 200,
 };
 
-static const u16 rf_ramp_pwm_cband_7090e_aci[] = {
-	86, /* max RF gain in 10th of dB */
-	40, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	345, /* ramp_max = maximum X used on the ramp */
-	(0 << 10) | 0, /* RF_RAMP5, LNA 1 = 8dB */ /* 7.47 dB */
-	(0 << 10) | 0, /* RF_RAMP6, LNA 1 */
-	(0 << 10) | 0, /* RF_RAMP7, LNA 2 = 0 dB */
-	(0 << 10) | 0, /* RF_RAMP8, LNA 2 */
-	(28 << 10) | 200, /* GAIN_4_1, LNA 3 = 6.8dB */ /* 3.61 dB */
-	(0  << 10) | 345, /* GAIN_4_2, LNA 3 */
-	(20 << 10) | 0, /* RF_RAMP3, LNA 4 = 6.2dB */ /* 4.96 dB */
-	(0  << 10) | 200, /* RF_RAMP4, LNA 4 */
+static const uint16_t rf_ramp_pwm_cband_7090e_aci[] = {
+	86,
+	40,
+	345,
+	(0 << 10) | 0,
+	(0 << 10) | 0,
+	(0 << 10) | 0,
+	(0 << 10) | 0,
+	(28 << 10) | 200,
+	(0  << 10) | 345,
+	(20 << 10) | 0,
+	(0  << 10) | 200,
 };
 
 static const u16 rf_ramp_pwm_cband_8090[] = {
-	345, /* max RF gain in 10th of dB */
-	29, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	1000, /* ramp_max = maximum X used on the ramp */
-	(35 << 10) | 772, /* RF_RAMP3, LNA 1 = 8dB */
-	(0  << 10) | 1000, /* RF_RAMP4, LNA 1 */
-	(58 << 10) | 496, /* RF_RAMP5, LNA 2 = 9.5dB */
-	(0  << 10) | 772, /* RF_RAMP6, LNA 2 */
-	(27 << 10) | 200, /* RF_RAMP7, LNA 3 = 10.5dB */
-	(0  << 10) | 496, /* RF_RAMP8, LNA 3 */
-	(40 << 10) | 0, /* GAIN_4_1, LNA 4 = 7dB */
-	(0  << 10) | 200, /* GAIN_4_2, LNA 4 */
+	345,			/* max RF gain in 10th of dB */
+	29,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
+	1000,			/* ramp_max = maximum X used on the ramp */
+	(35 << 10) | 772,	/* RF_RAMP3, LNA 1 = 8dB */
+	(0 << 10) | 1000,	/* RF_RAMP4, LNA 1 */
+	(58 << 10) | 496,	/* RF_RAMP5, LNA 2 = 9.5dB */
+	(0 << 10) | 772,	/* RF_RAMP6, LNA 2 */
+	(27 << 10) | 200,	/* RF_RAMP7, LNA 3 = 10.5dB */
+	(0 << 10) | 496,	/* RF_RAMP8, LNA 3 */
+	(40 << 10) | 0,		/* GAIN_4_1, LNA 4 = 7dB */
+	(0 << 10) | 200,	/* GAIN_4_2, LNA 4 */
 };
 
 static const u16 rf_ramp_pwm_uhf_7090[] = {
-	407, /* max RF gain in 10th of dB */
-	13, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	529, /* ramp_max = maximum X used on the ramp */
-	(23 << 10) | 0, /* RF_RAMP3, LNA 1 = 14.7dB */
-	(0  << 10) | 176, /* RF_RAMP4, LNA 1 */
-	(63 << 10) | 400, /* RF_RAMP5, LNA 2 = 8dB */
-	(0  << 10) | 529, /* RF_RAMP6, LNA 2 */
-	(48 << 10) | 316, /* RF_RAMP7, LNA 3 = 6.8dB */
-	(0  << 10) | 400, /* RF_RAMP8, LNA 3 */
-	(29 << 10) | 176, /* GAIN_4_1, LNA 4 = 11.5dB */
-	(0  << 10) | 316, /* GAIN_4_2, LNA 4 */
+	407,			/* max RF gain in 10th of dB */
+	13,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
+	529,			/* ramp_max = maximum X used on the ramp */
+	(23 << 10) | 0,		/* RF_RAMP3, LNA 1 = 14.7dB */
+	(0 << 10) | 176,	/* RF_RAMP4, LNA 1 */
+	(63 << 10) | 400,	/* RF_RAMP5, LNA 2 = 8dB */
+	(0 << 10) | 529,	/* RF_RAMP6, LNA 2 */
+	(48 << 10) | 316,	/* RF_RAMP7, LNA 3 = 6.8dB */
+	(0 << 10) | 400,	/* RF_RAMP8, LNA 3 */
+	(29 << 10) | 176,	/* GAIN_4_1, LNA 4 = 11.5dB */
+	(0 << 10) | 316,	/* GAIN_4_2, LNA 4 */
 };
 
 static const u16 rf_ramp_pwm_uhf_8090[] = {
-	388, /* max RF gain in 10th of dB */
-	26, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	1008, /* ramp_max = maximum X used on the ramp */
-	(11 << 10) | 0, /* RF_RAMP3, LNA 1 = 14.7dB */
-	(0  << 10) | 369, /* RF_RAMP4, LNA 1 */
-	(41 << 10) | 809, /* RF_RAMP5, LNA 2 = 8dB */
-	(0  << 10) | 1008, /* RF_RAMP6, LNA 2 */
-	(27 << 10) | 659, /* RF_RAMP7, LNA 3 = 6dB */
-	(0  << 10) | 809, /* RF_RAMP8, LNA 3 */
-	(14 << 10) | 369, /* GAIN_4_1, LNA 4 = 11.5dB */
-	(0  << 10) | 659, /* GAIN_4_2, LNA 4 */
+	388,			/* max RF gain in 10th of dB */
+	26,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
+	1008,			/* ramp_max = maximum X used on the ramp */
+	(11 << 10) | 0,		/* RF_RAMP3, LNA 1 = 14.7dB */
+	(0 << 10) | 369,	/* RF_RAMP4, LNA 1 */
+	(41 << 10) | 809,	/* RF_RAMP5, LNA 2 = 8dB */
+	(0 << 10) | 1008,	/* RF_RAMP6, LNA 2 */
+	(27 << 10) | 659,	/* RF_RAMP7, LNA 3 = 6dB */
+	(0 << 10) | 809,	/* RF_RAMP8, LNA 3 */
+	(14 << 10) | 369,	/* GAIN_4_1, LNA 4 = 11.5dB */
+	(0 << 10) | 659,	/* GAIN_4_2, LNA 4 */
 };
 
-/* GENERAL PWM ramp definition for all other Krosus */
-static const u16 bb_ramp_pwm_normal[] = {
-	500, /* max BB gain in 10th of dB */
-	8, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> BB_RAMP2 */
-	400,
-	(2  << 9) | 0, /* BB_RAMP3 = 21dB */
-	(0  << 9) | 168, /* BB_RAMP4 */
-	(2  << 9) | 168, /* BB_RAMP5 = 29dB */
-	(0  << 9) | 400, /* BB_RAMP6 */
+static const u16 rf_ramp_pwm_cband[] = {
+	0,			/* max RF gain in 10th of dB */
+	0,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> 0x2b */
+	0,			/* ramp_max = maximum X used on the ramp */
+	(0 << 10) | 0,		/* 0x2c, LNA 1 = 0dB */
+	(0 << 10) | 0,		/* 0x2d, LNA 1 */
+	(0 << 10) | 0,		/* 0x2e, LNA 2 = 0dB */
+	(0 << 10) | 0,		/* 0x2f, LNA 2 */
+	(0 << 10) | 0,		/* 0x30, LNA 3 = 0dB */
+	(0 << 10) | 0,		/* 0x31, LNA 3 */
+	(0 << 10) | 0,		/* GAIN_4_1, LNA 4 = 0dB */
+	(0 << 10) | 0,		/* GAIN_4_2, LNA 4 */
 };
 
-static const u16 bb_ramp_pwm_boost[] = {
-	550, /* max BB gain in 10th of dB */
-	8, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> BB_RAMP2 */
-	440,
-	(2  << 9) | 0, /* BB_RAMP3 = 26dB */
-	(0  << 9) | 208, /* BB_RAMP4 */
-	(2  << 9) | 208, /* BB_RAMP5 = 29dB */
-	(0  << 9) | 440, /* BB_RAMP6 */
+static const u16 rf_ramp_vhf[] = {
+	412,			/* max RF gain in 10th of dB */
+	132, 307, 127,		/* LNA1,  13.2dB */
+	105, 412, 255,		/* LNA2,  10.5dB */
+	50, 50, 127,		/* LNA3,  5dB */
+	125, 175, 127,		/* LNA4,  12.5dB */
+	0, 0, 127,		/* CBAND, 0dB */
 };
 
-static const u16 rf_ramp_pwm_cband[] = {
-	314, /* max RF gain in 10th of dB */
-	33, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	1023, /* ramp_max = maximum X used on the ramp */
-	(8  << 10) | 743, /* RF_RAMP3, LNA 1 = 0dB */
-	(0  << 10) | 1023, /* RF_RAMP4, LNA 1 */
-	(15 << 10) | 469, /* RF_RAMP5, LNA 2 = 0dB */
-	(0  << 10) | 742, /* RF_RAMP6, LNA 2 */
-	(9  << 10) | 234, /* RF_RAMP7, LNA 3 = 0dB */
-	(0  << 10) | 468, /* RF_RAMP8, LNA 3 */
-	(9  << 10) | 0, /* GAIN_4_1, LNA 4 = 0dB */
-	(0  << 10) | 233, /* GAIN_4_2, LNA 4 */
+static const u16 rf_ramp_uhf[] = {
+	412,			/* max RF gain in 10th of dB */
+	132, 307, 127,		/* LNA1  : total gain = 13.2dB, point on the ramp where this amp is full gain, value to write to get full gain */
+	105, 412, 255,		/* LNA2  : 10.5 dB */
+	50, 50, 127,		/* LNA3  :  5.0 dB */
+	125, 175, 127,		/* LNA4  : 12.5 dB */
+	0, 0, 127,		/* CBAND :  0.0 dB */
+};
+
+static const u16 rf_ramp_cband_broadmatching[] =	/* for p1G only */
+{
+	314,			/* Calibrated at 200MHz order has been changed g4-g3-g2-g1 */
+	84, 314, 127,		/* LNA1 */
+	80, 230, 255,		/* LNA2 */
+	80, 150, 127,		/* LNA3  It was measured 12dB, do not lock if 120 */
+	70, 70, 127,		/* LNA4 */
+	0, 0, 127,		/* CBAND */
+};
+
+static const u16 rf_ramp_cband[] = {
+	332,			/* max RF gain in 10th of dB */
+	132, 252, 127,		/* LNA1,  dB */
+	80, 332, 255,		/* LNA2,  dB */
+	0, 0, 127,		/* LNA3,  dB */
+	0, 0, 127,		/* LNA4,  dB */
+	120, 120, 127,		/* LT1 CBAND */
 };
 
 static const u16 rf_ramp_pwm_vhf[] = {
-	398, /* max RF gain in 10th of dB */
-	24, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	954, /* ramp_max = maximum X used on the ramp */
-	(7  << 10) | 0, /* RF_RAMP3, LNA 1 = 13.2dB */
-	(0  << 10) | 290, /* RF_RAMP4, LNA 1 */
-	(16 << 10) | 699, /* RF_RAMP5, LNA 2 = 10.5dB */
-	(0  << 10) | 954, /* RF_RAMP6, LNA 2 */
-	(17 << 10) | 580, /* RF_RAMP7, LNA 3 = 5dB */
-	(0  << 10) | 699, /* RF_RAMP8, LNA 3 */
-	(7  << 10) | 290, /* GAIN_4_1, LNA 4 = 12.5dB */
-	(0  << 10) | 580, /* GAIN_4_2, LNA 4 */
+	404,			/* max RF gain in 10th of dB */
+	25,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> 0x2b */
+	1011,			/* ramp_max = maximum X used on the ramp */
+	(6 << 10) | 417,	/* 0x2c, LNA 1 = 13.2dB */
+	(0 << 10) | 756,	/* 0x2d, LNA 1 */
+	(16 << 10) | 756,	/* 0x2e, LNA 2 = 10.5dB */
+	(0 << 10) | 1011,	/* 0x2f, LNA 2 */
+	(16 << 10) | 290,	/* 0x30, LNA 3 = 5dB */
+	(0 << 10) | 417,	/* 0x31, LNA 3 */
+	(7 << 10) | 0,		/* GAIN_4_1, LNA 4 = 12.5dB */
+	(0 << 10) | 290,	/* GAIN_4_2, LNA 4 */
 };
 
 static const u16 rf_ramp_pwm_uhf[] = {
-	398, /* max RF gain in 10th of dB */
-	24, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	954, /* ramp_max = maximum X used on the ramp */
-	(7  << 10) | 0, /* RF_RAMP3, LNA 1 = 13.2dB */
-	(0  << 10) | 290, /* RF_RAMP4, LNA 1 */
-	(16 << 10) | 699, /* RF_RAMP5, LNA 2 = 10.5dB */
-	(0  << 10) | 954, /* RF_RAMP6, LNA 2 */
-	(17 << 10) | 580, /* RF_RAMP7, LNA 3 = 5dB */
-	(0  << 10) | 699, /* RF_RAMP8, LNA 3 */
-	(7  << 10) | 290, /* GAIN_4_1, LNA 4 = 12.5dB */
-	(0  << 10) | 580, /* GAIN_4_2, LNA 4 */
+	404,			/* max RF gain in 10th of dB */
+	25,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> 0x2b */
+	1011,			/* ramp_max = maximum X used on the ramp */
+	(6 << 10) | 417,	/* 0x2c, LNA 1 = 13.2dB */
+	(0 << 10) | 756,	/* 0x2d, LNA 1 */
+	(16 << 10) | 756,	/* 0x2e, LNA 2 = 10.5dB */
+	(0 << 10) | 1011,	/* 0x2f, LNA 2 */
+	(16 << 10) | 0,		/* 0x30, LNA 3 = 5dB */
+	(0 << 10) | 127,	/* 0x31, LNA 3 */
+	(7 << 10) | 127,	/* GAIN_4_1, LNA 4 = 12.5dB */
+	(0 << 10) | 417,	/* GAIN_4_2, LNA 4 */
 };
 
-static const u16 rf_ramp_pwm_sband[] = {
-	253, /* max RF gain in 10th of dB */
-	38, /* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> RF_RAMP2 */
-	961,
-	(4  << 10) | 0, /* RF_RAMP3, LNA 1 = 14.1dB */
-	(0  << 10) | 508, /* RF_RAMP4, LNA 1 */
-	(9  << 10) | 508, /* RF_RAMP5, LNA 2 = 11.2dB */
-	(0  << 10) | 961, /* RF_RAMP6, LNA 2 */
-	(0  << 10) | 0, /* RF_RAMP7, LNA 3 = 0dB */
-	(0  << 10) | 0, /* RF_RAMP8, LNA 3 */
-	(0  << 10) | 0, /* GAIN_4_1, LNA 4 = 0dB */
-	(0  << 10) | 0, /* GAIN_4_2, LNA 4 */
+static const u16 bb_ramp_boost[] = {
+	550,			/* max BB gain in 10th of dB */
+	260, 260, 26,		/* BB1, 26dB */
+	290, 550, 29,		/* BB2, 29dB */
+};
+
+static const u16 bb_ramp_pwm_normal[] = {
+	500,			/* max RF gain in 10th of dB */
+	8,			/* ramp_slope = 1dB of gain -> clock_ticks_per_db = clk_khz / ramp_slope -> 0x34 */
+	400,
+	(2 << 9) | 0,		/* 0x35 = 21dB */
+	(0 << 9) | 168,		/* 0x36 */
+	(2 << 9) | 168,		/* 0x37 = 29dB */
+	(0 << 9) | 400,		/* 0x38 */
 };
 
 struct slope {
@@ -1070,69 +1089,70 @@ static void dib0090_set_bbramp_pwm(struct dib0090_state *state, const u16 * cfg)
 void dib0090_pwm_gain_reset(struct dvb_frontend *fe)
 {
 	struct dib0090_state *state = fe->tuner_priv;
-	u16 *bb_ramp = (u16 *)&bb_ramp_pwm_normal; /* default baseband config */
-	u16 *rf_ramp = NULL;
-	u8 en_pwm_rf_mux = 1;
-
 	/* reset the AGC */
+
 	if (state->config->use_pwm_agc) {
+#ifdef CONFIG_BAND_SBAND
+		if (state->current_band == BAND_SBAND) {
+			dib0090_set_rframp_pwm(state, rf_ramp_pwm_sband);
+			dib0090_set_bbramp_pwm(state, bb_ramp_pwm_boost);
+		} else
+#endif
+#ifdef CONFIG_BAND_CBAND
 		if (state->current_band == BAND_CBAND) {
 			if (state->identity.in_soc) {
-				bb_ramp = (u16 *)&bb_ramp_pwm_normal_socs;
+				dib0090_set_bbramp_pwm(state, bb_ramp_pwm_normal_socs);
 				if (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)
-					rf_ramp = (u16 *)&rf_ramp_pwm_cband_8090;
-				else if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1) {
+					dib0090_set_rframp_pwm(state, rf_ramp_pwm_cband_8090);
+				else if (state->identity.version == SOC_7090_P1G_11R1
+						|| state->identity.version == SOC_7090_P1G_21R1) {
 					if (state->config->is_dib7090e) {
 						if (state->rf_ramp == NULL)
-							rf_ramp = (u16 *)&rf_ramp_pwm_cband_7090e_sensitivity;
+							dib0090_set_rframp_pwm(state, rf_ramp_pwm_cband_7090e_sensitivity);
 						else
-							rf_ramp = (u16 *)state->rf_ramp;
+							dib0090_set_rframp_pwm(state, state->rf_ramp);
 					} else
-						rf_ramp = (u16 *)&rf_ramp_pwm_cband_7090p;
+						dib0090_set_rframp_pwm(state, rf_ramp_pwm_cband_7090);
 				}
-			} else
-				rf_ramp = (u16 *)&rf_ramp_pwm_cband;
+			} else {
+				dib0090_set_rframp_pwm(state, rf_ramp_pwm_cband);
+				dib0090_set_bbramp_pwm(state, bb_ramp_pwm_normal);
+			}
 		} else
-
-			if (state->current_band == BAND_VHF) {
-				if (state->identity.in_soc) {
-					bb_ramp = (u16 *)&bb_ramp_pwm_normal_socs;
-					/* rf_ramp = &rf_ramp_pwm_vhf_socs; */ /* TODO */
-				} else
-					rf_ramp = (u16 *)&rf_ramp_pwm_vhf;
-			} else if (state->current_band == BAND_UHF) {
-				if (state->identity.in_soc) {
-					bb_ramp = (u16 *)&bb_ramp_pwm_normal_socs;
-					if (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)
-						rf_ramp = (u16 *)&rf_ramp_pwm_uhf_8090;
-					else if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1)
-						rf_ramp = (u16 *)&rf_ramp_pwm_uhf_7090;
-				} else
-					rf_ramp = (u16 *)&rf_ramp_pwm_uhf;
+#endif
+#ifdef CONFIG_BAND_VHF
+		if (state->current_band == BAND_VHF) {
+			if (state->identity.in_soc) {
+				dib0090_set_bbramp_pwm(state, bb_ramp_pwm_normal_socs);
+			} else {
+				dib0090_set_rframp_pwm(state, rf_ramp_pwm_vhf);
+				dib0090_set_bbramp_pwm(state, bb_ramp_pwm_normal);
 			}
-		if (rf_ramp)
-			dib0090_set_rframp_pwm(state, rf_ramp);
-		dib0090_set_bbramp_pwm(state, bb_ramp);
-
-		/* activate the ramp generator using PWM control */
-		dprintk("ramp RF gain = %d BAND = %s version = %d", state->rf_ramp[0], (state->current_band == BAND_CBAND) ? "CBAND" : "NOT CBAND", state->identity.version & 0x1f);
-
-		if ((state->rf_ramp[0] == 0) || (state->current_band == BAND_CBAND && (state->identity.version & 0x1f) <= P1D_E_F)) {
-			dprintk("DE-Engage mux for direct gain reg control");
-			en_pwm_rf_mux = 0;
 		} else
-			dprintk("Engage mux for PWM control");
-
-		dib0090_write_reg(state, 0x32, (en_pwm_rf_mux << 12) | (en_pwm_rf_mux << 11));
+#endif
+		{
+			if (state->identity.in_soc) {
+				if (state->identity.version == SOC_8090_P1G_11R1 || state->identity.version == SOC_8090_P1G_21R1)
+					dib0090_set_rframp_pwm(state, rf_ramp_pwm_uhf_8090);
+				else if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1)
+					dib0090_set_rframp_pwm(state, rf_ramp_pwm_uhf_7090);
+				dib0090_set_bbramp_pwm(state, bb_ramp_pwm_normal_socs);
+			} else {
+				dib0090_set_rframp_pwm(state, rf_ramp_pwm_uhf);
+				dib0090_set_bbramp_pwm(state, bb_ramp_pwm_normal);
+			}
+		}
 
-		/* Set fast servo cutoff to start AGC; 0 = 1KHz ; 1 = 50Hz ; 2 = 150Hz ; 3 = 50KHz ; 4 = servo fast*/
-		if (state->identity.version == SOC_7090_P1G_11R1 || state->identity.version == SOC_7090_P1G_21R1)
-			dib0090_write_reg(state, 0x04, 3);
+		if (state->rf_ramp[0] != 0)
+			dib0090_write_reg(state, 0x32, (3 << 11));
 		else
-			dib0090_write_reg(state, 0x04, 1);
-		dib0090_write_reg(state, 0x39, (1 << 10)); /* 0 gain by default */
+			dib0090_write_reg(state, 0x32, (0 << 11));
+
+		dib0090_write_reg(state, 0x04, 0x03);
+		dib0090_write_reg(state, 0x39, (1 << 10));
 	}
 }
+
 EXPORT_SYMBOL(dib0090_pwm_gain_reset);
 
 void dib0090_set_dc_servo(struct dvb_frontend *fe, u8 DC_servo_cutoff)
@@ -1173,22 +1193,22 @@ int dib0090_gain_control(struct dvb_frontend *fe)
 #endif
 #ifdef CONFIG_BAND_VHF
 		if (state->current_band == BAND_VHF && !state->identity.p1g) {
-			dib0090_set_rframp(state, rf_ramp_pwm_vhf);
-			dib0090_set_bbramp(state, bb_ramp_pwm_normal);
+			dib0090_set_rframp(state, rf_ramp_vhf);
+			dib0090_set_bbramp(state, bb_ramp_boost);
 		} else
 #endif
 #ifdef CONFIG_BAND_CBAND
 		if (state->current_band == BAND_CBAND && !state->identity.p1g) {
-			dib0090_set_rframp(state, rf_ramp_pwm_cband);
-			dib0090_set_bbramp(state, bb_ramp_pwm_normal);
+			dib0090_set_rframp(state, rf_ramp_cband);
+			dib0090_set_bbramp(state, bb_ramp_boost);
 		} else
 #endif
 		if ((state->current_band == BAND_CBAND || state->current_band == BAND_VHF) && state->identity.p1g) {
-			dib0090_set_rframp(state, rf_ramp_pwm_cband_7090p);
-			dib0090_set_bbramp(state, bb_ramp_pwm_normal_socs);
+			dib0090_set_rframp(state, rf_ramp_cband_broadmatching);
+			dib0090_set_bbramp(state, bb_ramp_boost);
 		} else {
-			dib0090_set_rframp(state, rf_ramp_pwm_uhf);
-			dib0090_set_bbramp(state, bb_ramp_pwm_normal);
+			dib0090_set_rframp(state, rf_ramp_uhf);
+			dib0090_set_bbramp(state, bb_ramp_boost);
 		}
 
 		dib0090_write_reg(state, 0x32, 0);
@@ -1533,16 +1553,14 @@ static void dib0090_set_EFUSE(struct dib0090_state *state)
 
 		if ((c >= CAP_VALUE_MAX) || (c <= CAP_VALUE_MIN))
 			c = 32;
-		else
-			c += 14;
 		if ((h >= HR_MAX) || (h <= HR_MIN))
 			h = 34;
 		if ((n >= POLY_MAX) || (n <= POLY_MIN))
 			n = 3;
 
-		dib0090_write_reg(state, 0x13, (h << 10));
-		e2 = (n << 11) | ((h >> 2)<<6) | c;
-		dib0090_write_reg(state, 0x2, e2); /* Load the BB_2 */
+		dib0090_write_reg(state, 0x13, (h << 10)) ;
+		e2 = (n<<11) | ((h>>2)<<6) | (c);
+		dib0090_write_reg(state, 0x2, e2) ; /* Load the BB_2 */
 	}
 }
 
diff --git a/drivers/media/dvb-frontends/dib7000p.c b/drivers/media/dvb-frontends/dib7000p.c
index effb87f..3e1eefa 100644
--- a/drivers/media/dvb-frontends/dib7000p.c
+++ b/drivers/media/dvb-frontends/dib7000p.c
@@ -429,13 +429,6 @@ int dib7000p_get_agc_values(struct dvb_frontend *fe,
 }
 EXPORT_SYMBOL(dib7000p_get_agc_values);
 
-int dib7000p_set_agc1_min(struct dvb_frontend *fe, u16 v)
-{
-	struct dib7000p_state *state = fe->demodulator_priv;
-	return dib7000p_write_word(state, 108,  v);
-}
-EXPORT_SYMBOL(dib7000p_set_agc1_min);
-
 static void dib7000p_reset_pll(struct dib7000p_state *state)
 {
 	struct dibx000_bandwidth_config *bw = &state->cfg.bw[0];
@@ -828,7 +821,6 @@ static int dib7000p_agc_startup(struct dvb_frontend *demod)
 	u8 agc_split;
 	u16 reg;
 	u32 upd_demod_gain_period = 0x1000;
-	s32 frequency_offset = 0;
 
 	switch (state->agc_state) {
 	case 0:
@@ -849,14 +841,7 @@ static int dib7000p_agc_startup(struct dvb_frontend *demod)
 		if (dib7000p_set_agc_config(state, BAND_OF_FREQUENCY(ch->frequency / 1000)) != 0)
 			return -1;
 
-		if (demod->ops.tuner_ops.get_frequency) {
-			u32 frequency_tuner;
-
-			demod->ops.tuner_ops.get_frequency(demod, &frequency_tuner);
-			frequency_offset = (s32)frequency_tuner / 1000 - ch->frequency / 1000;
-		}
-
-		dib7000p_set_dds(state, frequency_offset);
+		dib7000p_set_dds(state, 0);
 		ret = 7;
 		(*agc_state)++;
 		break;
diff --git a/drivers/media/dvb-frontends/dib7000p.h b/drivers/media/dvb-frontends/dib7000p.h
index d08cdff..cf5e779 100644
--- a/drivers/media/dvb-frontends/dib7000p.h
+++ b/drivers/media/dvb-frontends/dib7000p.h
@@ -63,7 +63,6 @@ extern struct i2c_adapter *dib7090_get_i2c_tuner(struct dvb_frontend *fe);
 extern int dib7090_slave_reset(struct dvb_frontend *fe);
 extern int dib7000p_get_agc_values(struct dvb_frontend *fe,
 		u16 *agc_global, u16 *agc1, u16 *agc2, u16 *wbd);
-extern int dib7000p_set_agc1_min(struct dvb_frontend *fe, u16 v);
 #else
 static inline struct dvb_frontend *dib7000p_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib7000p_config *cfg)
 {
@@ -155,12 +154,6 @@ static inline int dib7000p_get_agc_values(struct dvb_frontend *fe,
 	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
 	return -ENODEV;
 }
-
-static inline int dib7000p_set_agc1_min(struct dvb_frontend *fe, u16 v)
-{
-	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
-	return -ENODEV;
-}
 #endif
 
 #endif
diff --git a/drivers/media/dvb-frontends/dib8000.c b/drivers/media/dvb-frontends/dib8000.c
index 362de38..1f3bcb5 100644
--- a/drivers/media/dvb-frontends/dib8000.c
+++ b/drivers/media/dvb-frontends/dib8000.c
@@ -23,8 +23,8 @@
 #define LAYER_B   2
 #define LAYER_C   3
 
+#define FE_CALLBACK_TIME_NEVER 0xffffffff
 #define MAX_NUMBER_OF_FRONTENDS 6
-/* #define DIB8000_AGC_FREEZE */
 
 static int debug;
 module_param(debug, int, 0644);
@@ -32,6 +32,8 @@ MODULE_PARM_DESC(debug, "turn on debugging (default: 0)");
 
 #define dprintk(args...) do { if (debug) { printk(KERN_DEBUG "DiB8000: "); printk(args); printk("\n"); } } while (0)
 
+#define FE_STATUS_TUNE_FAILED 0
+
 struct i2c_device {
 	struct i2c_adapter *adap;
 	u8 addr;
@@ -40,23 +42,6 @@ struct i2c_device {
 	struct mutex *i2c_buffer_lock;
 };
 
-enum param_loop_step {
-	LOOP_TUNE_1,
-	LOOP_TUNE_2
-};
-
-enum dib8000_autosearch_step {
-	AS_START = 0,
-	AS_SEARCHING_FFT,
-	AS_SEARCHING_GUARD,
-	AS_DONE = 100,
-};
-
-enum timeout_mode {
-	SYMBOL_DEPENDENT_OFF = 0,
-	SYMBOL_DEPENDENT_ON,
-};
-
 struct dib8000_state {
 	struct dib8000_config cfg;
 
@@ -87,7 +72,7 @@ struct dib8000_state {
 	u16 revision;
 	u8 isdbt_cfg_loaded;
 	enum frontend_tune_state tune_state;
-	s32 status;
+	u32 status;
 
 	struct dvb_frontend *fe[MAX_NUMBER_OF_FRONTENDS];
 
@@ -100,30 +85,6 @@ struct dib8000_state {
 
 	u16 tuner_enable;
 	struct i2c_adapter dib8096p_tuner_adap;
-	u16 current_demod_bw;
-
-	u16 seg_mask;
-	u16 seg_diff_mask;
-	u16 mode;
-	u8 layer_b_nb_seg;
-	u8 layer_c_nb_seg;
-
-	u8 channel_parameters_set;
-	u16 autosearch_state;
-	u16 found_nfft;
-	u16 found_guard;
-	u8 subchannel;
-	u8 symbol_duration;
-	u32 timeout;
-	u8 longest_intlv_layer;
-	u16 output_mode;
-
-#ifdef DIB8000_AGC_FREEZE
-	u16 agc1_max;
-	u16 agc1_min;
-	u16 agc2_max;
-	u16 agc2_min;
-#endif
 };
 
 enum dib8000_power_mode {
@@ -157,10 +118,15 @@ static u16 dib8000_i2c_read16(struct i2c_device *i2c, u16 reg)
 	return ret;
 }
 
-static u16 __dib8000_read_word(struct dib8000_state *state, u16 reg)
+static u16 dib8000_read_word(struct dib8000_state *state, u16 reg)
 {
 	u16 ret;
 
+	if (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {
+		dprintk("could not acquire lock");
+		return 0;
+	}
+
 	state->i2c_write_buffer[0] = reg >> 8;
 	state->i2c_write_buffer[1] = reg & 0xff;
 
@@ -178,21 +144,6 @@ static u16 __dib8000_read_word(struct dib8000_state *state, u16 reg)
 		dprintk("i2c read error on %d", reg);
 
 	ret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];
-
-	return ret;
-}
-
-static u16 dib8000_read_word(struct dib8000_state *state, u16 reg)
-{
-	u16 ret;
-
-	if (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {
-		dprintk("could not acquire lock");
-		return 0;
-	}
-
-	ret = __dib8000_read_word(state, reg);
-
 	mutex_unlock(&state->i2c_buffer_lock);
 
 	return ret;
@@ -202,15 +153,8 @@ static u32 dib8000_read32(struct dib8000_state *state, u16 reg)
 {
 	u16 rw[2];
 
-	if (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {
-		dprintk("could not acquire lock");
-		return 0;
-	}
-
-	rw[0] = __dib8000_read_word(state, reg + 0);
-	rw[1] = __dib8000_read_word(state, reg + 1);
-
-	mutex_unlock(&state->i2c_buffer_lock);
+	rw[0] = dib8000_read_word(state, reg + 0);
+	rw[1] = dib8000_read_word(state, reg + 1);
 
 	return ((rw[0] << 16) | (rw[1]));
 }
@@ -394,9 +338,9 @@ static void dib8000_set_acquisition_mode(struct dib8000_state *state)
 static int dib8000_set_output_mode(struct dvb_frontend *fe, int mode)
 {
 	struct dib8000_state *state = fe->demodulator_priv;
+
 	u16 outreg, fifo_threshold, smo_mode, sram = 0x0205;	/* by default SDRAM deintlv is enabled */
 
-	state->output_mode = mode;
 	outreg = 0;
 	fifo_threshold = 1792;
 	smo_mode = (dib8000_read_word(state, 299) & 0x0050) | (1 << 1);
@@ -455,9 +399,8 @@ static int dib8000_set_output_mode(struct dvb_frontend *fe, int mode)
 static int dib8000_set_diversity_in(struct dvb_frontend *fe, int onoff)
 {
 	struct dib8000_state *state = fe->demodulator_priv;
-	u16 tmp, sync_wait = dib8000_read_word(state, 273) & 0xfff0;
+	u16 sync_wait = dib8000_read_word(state, 273) & 0xfff0;
 
-	dprintk("set diversity input to %i", onoff);
 	if (!state->differential_constellation) {
 		dib8000_write_word(state, 272, 1 << 9);	//dvsy_off_lmod4 = 1
 		dib8000_write_word(state, 273, sync_wait | (1 << 2) | 2);	// sync_enable = 1; comb_mode = 2
@@ -481,13 +424,6 @@ static int dib8000_set_diversity_in(struct dvb_frontend *fe, int onoff)
 		dib8000_write_word(state, 271, 1);
 		break;
 	}
-
-	if (state->revision == 0x8002) {
-		tmp = dib8000_read_word(state, 903);
-		dib8000_write_word(state, 903, tmp & ~(1 << 3));
-		msleep(30);
-		dib8000_write_word(state, 903, tmp | (1 << 3));
-	}
 	return 0;
 }
 
@@ -532,6 +468,27 @@ static void dib8000_set_power_mode(struct dib8000_state *state, enum dib8000_pow
 	dib8000_write_word(state, 1280, reg_1280);
 }
 
+static int dib8000_init_sdram(struct dib8000_state *state)
+{
+	u16 reg = 0;
+	dprintk("Init sdram");
+
+	reg = dib8000_read_word(state, 274)&0xfff0;
+	/* P_dintlv_delay_ram = 7 because of MobileSdram */
+	dib8000_write_word(state, 274, reg | 0x7);
+
+	dib8000_write_word(state, 1803, (7<<2));
+
+	reg = dib8000_read_word(state, 1280);
+	/* force restart P_restart_sdram */
+	dib8000_write_word(state, 1280,  reg | (1<<2));
+
+	/* release restart P_restart_sdram */
+	dib8000_write_word(state, 1280,  reg);
+
+	return 0;
+}
+
 static int dib8000_set_adc_state(struct dib8000_state *state, enum dibx000_adc_states no)
 {
 	int ret = 0;
@@ -627,23 +584,18 @@ static int dib8000_set_bandwidth(struct dvb_frontend *fe, u32 bw)
 
 static int dib8000_sad_calib(struct dib8000_state *state)
 {
-	u8 sad_sel = 3;
-
 	if (state->revision == 0x8090) {
-		dib8000_write_word(state, 922, (sad_sel << 2));
-		dib8000_write_word(state, 923, 2048);
-
-		dib8000_write_word(state, 922, (sad_sel << 2) | 0x1);
-		dib8000_write_word(state, 922, (sad_sel << 2));
-	} else {
-		/* internal */
-		dib8000_write_word(state, 923, (0 << 1) | (0 << 0));
-		dib8000_write_word(state, 924, 776);
-
-		/* do the calibration */
-		dib8000_write_word(state, 923, (1 << 0));
-		dib8000_write_word(state, 923, (0 << 0));
+		dprintk("%s: the sad calibration is not needed for the dib8096P",
+				__func__);
+		return 0;
 	}
+	/* internal */
+	dib8000_write_word(state, 923, (0 << 1) | (0 << 0));
+	dib8000_write_word(state, 924, 776);	// 0.625*3.3 / 4096
+
+	/* do the calibration */
+	dib8000_write_word(state, 923, (1 << 0));
+	dib8000_write_word(state, 923, (0 << 0));
 
 	msleep(1);
 	return 0;
@@ -657,8 +609,8 @@ int dib8000_set_wbd_ref(struct dvb_frontend *fe, u16 value)
 	state->wbd_ref = value;
 	return dib8000_write_word(state, 106, value);
 }
-EXPORT_SYMBOL(dib8000_set_wbd_ref);
 
+EXPORT_SYMBOL(dib8000_set_wbd_ref);
 static void dib8000_reset_pll_common(struct dib8000_state *state, const struct dibx000_bandwidth_config *bw)
 {
 	dprintk("ifreq: %d %x, inversion: %d", bw->ifreq, bw->ifreq, bw->ifreq >> 25);
@@ -733,23 +685,20 @@ static void dib8000_reset_pll(struct dib8000_state *state)
 }
 
 int dib8000_update_pll(struct dvb_frontend *fe,
-		struct dibx000_bandwidth_config *pll, u32 bw, u8 ratio)
+		struct dibx000_bandwidth_config *pll)
 {
 	struct dib8000_state *state = fe->demodulator_priv;
 	u16 reg_1857, reg_1856 = dib8000_read_word(state, 1856);
-	u8 loopdiv, prediv, oldprediv = state->cfg.pll->pll_prediv ;
+	u8 loopdiv, prediv;
 	u32 internal, xtal;
 
 	/* get back old values */
 	prediv = reg_1856 & 0x3f;
 	loopdiv = (reg_1856 >> 6) & 0x3f;
 
-	if ((pll == NULL) || (pll->pll_prediv == prediv &&
-				pll->pll_ratio == loopdiv))
-		return -EINVAL;
-
-	dprintk("Updating pll (prediv: old =  %d new = %d ; loopdiv : old = %d new = %d)", prediv, pll->pll_prediv, loopdiv, pll->pll_ratio);
-	if (state->revision == 0x8090) {
+	if ((pll != NULL) && (pll->pll_prediv != prediv ||
+				pll->pll_ratio != loopdiv)) {
+		dprintk("Updating pll (prediv: old =  %d new = %d ; loopdiv : old = %d new = %d)", prediv, pll->pll_prediv, loopdiv, pll->pll_ratio);
 		reg_1856 &= 0xf000;
 		reg_1857 = dib8000_read_word(state, 1857);
 		/* disable PLL */
@@ -780,33 +729,10 @@ int dib8000_update_pll(struct dvb_frontend *fe,
 		reg_1856 = dib8000_read_word(state, 1856);
 		dprintk("PLL Updated with prediv = %d and loopdiv = %d",
 				reg_1856&0x3f, (reg_1856>>6)&0x3f);
-	} else {
-		if (bw != state->current_demod_bw) {
-			/** Bandwidth change => force PLL update **/
-			dprintk("PLL: Bandwidth Change %d MHz -> %d MHz (prediv: %d->%d)", state->current_demod_bw / 1000, bw / 1000, oldprediv, state->cfg.pll->pll_prediv);
-
-			if (state->cfg.pll->pll_prediv != oldprediv) {
-				/** Full PLL change only if prediv is changed **/
-
-				/** full update => bypass and reconfigure **/
-				dprintk("PLL: New Setting for %d MHz Bandwidth (prediv: %d, ratio: %d)", bw/1000, state->cfg.pll->pll_prediv, state->cfg.pll->pll_ratio);
-				dib8000_write_word(state, 902, dib8000_read_word(state, 902) | (1<<3)); /* bypass PLL */
-				dib8000_reset_pll(state);
-				dib8000_write_word(state, 898, 0x0004); /* sad */
-			} else
-				ratio = state->cfg.pll->pll_ratio;
 
-			state->current_demod_bw = bw;
-		}
-
-		if (ratio != 0) {
-			/** ratio update => only change ratio **/
-			dprintk("PLL: Update ratio (prediv: %d, ratio: %d)", state->cfg.pll->pll_prediv, ratio);
-			dib8000_write_word(state, 901, (state->cfg.pll->pll_prediv << 8) | (ratio << 0)); /* only the PLL ratio is updated. */
-		}
-}
-
-	return 0;
+		return 0;
+	}
+	return -EINVAL;
 }
 EXPORT_SYMBOL(dib8000_update_pll);
 
@@ -1002,7 +928,7 @@ static int dib8000_reset(struct dvb_frontend *fe)
 	dib8000_set_power_mode(state, DIB8000_POWER_ALL);
 
 	/* always leave the VBG voltage on - it consumes almost nothing but takes a long time to start */
-	dib8000_set_adc_state(state, DIBX000_ADC_OFF);
+	dib8000_set_adc_state(state, DIBX000_VBG_ENABLE);
 
 	/* restart all parts */
 	dib8000_write_word(state, 770, 0xffff);
@@ -1066,11 +992,12 @@ static int dib8000_reset(struct dvb_frontend *fe)
 			l = *n++;
 		}
 	}
-
+	if (state->revision != 0x8090)
+		dib8000_write_word(state, 903, (0 << 4) | 2);
 	state->isdbt_cfg_loaded = 0;
 
 	//div_cfg override for special configs
-	if ((state->revision != 8090) && (state->cfg.div_cfg != 0))
+	if (state->cfg.div_cfg != 0)
 		dib8000_write_word(state, 903, state->cfg.div_cfg);
 
 	/* unforce divstr regardless whether i2c enumeration was done or not */
@@ -1079,12 +1006,10 @@ static int dib8000_reset(struct dvb_frontend *fe)
 	dib8000_set_bandwidth(fe, 6000);
 
 	dib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON);
-	dib8000_sad_calib(state);
-	if (state->revision != 0x8090)
+	if (state->revision != 0x8090) {
+		dib8000_sad_calib(state);
 		dib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF);
-
-	/* ber_rs_len = 3 */
-	dib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));
+	}
 
 	dib8000_set_power_mode(state, DIB8000_POWER_INTERFACE_ONLY);
 
@@ -1516,7 +1441,6 @@ static int dib8096p_set_output_mode(struct dvb_frontend *fe, int mode)
 	u8 prefer_mpeg_mux_use = 1;
 	int ret = 0;
 
-	state->output_mode = mode;
 	dib8096p_host_bus_drive(state, 1);
 
 	fifo_threshold = 1792;
@@ -1955,645 +1879,782 @@ static const u16 adc_target_16dB[11] = {
 };
 static const u8 permu_seg[] = { 6, 5, 7, 4, 8, 3, 9, 2, 10, 1, 11, 0, 12 };
 
-static u16 dib8000_set_layer(struct dib8000_state *state, u8 layer_index, u16 max_constellation)
+static void dib8000_set_channel(struct dib8000_state *state, u8 seq, u8 autosearching)
 {
-	u8  cr, constellation, time_intlv;
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
+	u16 mode, max_constellation, seg_diff_mask = 0, nbseg_diff = 0;
+	u8 guard, crate, constellation, timeI;
+	u16 i, coeff[4], P_cfr_left_edge = 0, P_cfr_right_edge = 0, seg_mask13 = 0x1fff;	// All 13 segments enabled
+	const s16 *ncoeff = NULL, *ana_fe;
+	u16 tmcc_pow = 0;
+	u16 coff_pow = 0x2800;
+	u16 init_prbs = 0xfff;
+	u16 ana_gain = 0;
 
-	switch (c->layer[layer_index].modulation) {
-	case DQPSK:
-			constellation = 0;
-			break;
-	case  QPSK:
-			constellation = 1;
+	if (state->revision == 0x8090)
+		dib8000_init_sdram(state);
+
+	if (state->ber_monitored_layer != LAYER_ALL)
+		dib8000_write_word(state, 285, (dib8000_read_word(state, 285) & 0x60) | state->ber_monitored_layer);
+	else
+		dib8000_write_word(state, 285, dib8000_read_word(state, 285) & 0x60);
+
+	i = dib8000_read_word(state, 26) & 1;	// P_dds_invspec
+	dib8000_write_word(state, 26, state->fe[0]->dtv_property_cache.inversion^i);
+
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {
+		//compute new dds_freq for the seg and adjust prbs
+		int seg_offset =
+			state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx -
+			(state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) -
+			(state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2);
+		int clk = state->cfg.pll->internal;
+		u32 segtodds = ((u32) (430 << 23) / clk) << 3;	// segtodds = SegBW / Fclk * pow(2,26)
+		int dds_offset = seg_offset * segtodds;
+		int new_dds, sub_channel;
+		if ((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)
+			dds_offset -= (int)(segtodds / 2);
+
+		if (state->cfg.pll->ifreq == 0) {
+			if ((state->fe[0]->dtv_property_cache.inversion ^ i) == 0) {
+				dib8000_write_word(state, 26, dib8000_read_word(state, 26) | 1);
+				new_dds = dds_offset;
+			} else
+				new_dds = dds_offset;
+
+			// We shift tuning frequency if the wanted segment is :
+			//  - the segment of center frequency with an odd total number of segments
+			//  - the segment to the left of center frequency with an even total number of segments
+			//  - the segment to the right of center frequency with an even total number of segments
+			if ((state->fe[0]->dtv_property_cache.delivery_system == SYS_ISDBT)
+				&& (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1)
+					&& (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2)
+					  && (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx ==
+				  ((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))
+					 || (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)
+						 && (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx == (state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2)))
+					 || (((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)
+						 && (state->fe[0]->dtv_property_cache.isdbt_sb_segment_idx ==
+							 ((state->fe[0]->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))
+					)) {
+				new_dds -= ((u32) (850 << 22) / clk) << 4;	// new_dds = 850 (freq shift in KHz) / Fclk * pow(2,26)
+			}
+		} else {
+			if ((state->fe[0]->dtv_property_cache.inversion ^ i) == 0)
+				new_dds = state->cfg.pll->ifreq - dds_offset;
+			else
+				new_dds = state->cfg.pll->ifreq + dds_offset;
+		}
+		dib8000_write_word(state, 27, (u16) ((new_dds >> 16) & 0x01ff));
+		dib8000_write_word(state, 28, (u16) (new_dds & 0xffff));
+		if (state->fe[0]->dtv_property_cache.isdbt_sb_segment_count % 2)
+			sub_channel = ((state->fe[0]->dtv_property_cache.isdbt_sb_subchannel + (3 * seg_offset) + 1) % 41) / 3;
+		else
+			sub_channel = ((state->fe[0]->dtv_property_cache.isdbt_sb_subchannel + (3 * seg_offset)) % 41) / 3;
+		sub_channel -= 6;
+
+		if (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_2K
+				|| state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_4K) {
+			dib8000_write_word(state, 219, dib8000_read_word(state, 219) | 0x1);	//adp_pass =1
+			dib8000_write_word(state, 190, dib8000_read_word(state, 190) | (0x1 << 14));	//pha3_force_pha_shift = 1
+		} else {
+			dib8000_write_word(state, 219, dib8000_read_word(state, 219) & 0xfffe);	//adp_pass =0
+			dib8000_write_word(state, 190, dib8000_read_word(state, 190) & 0xbfff);	//pha3_force_pha_shift = 0
+		}
+
+		switch (state->fe[0]->dtv_property_cache.transmission_mode) {
+		case TRANSMISSION_MODE_2K:
+			switch (sub_channel) {
+			case -6:
+				init_prbs = 0x0;
+				break;	// 41, 0, 1
+			case -5:
+				init_prbs = 0x423;
+				break;	// 02~04
+			case -4:
+				init_prbs = 0x9;
+				break;	// 05~07
+			case -3:
+				init_prbs = 0x5C7;
+				break;	// 08~10
+			case -2:
+				init_prbs = 0x7A6;
+				break;	// 11~13
+			case -1:
+				init_prbs = 0x3D8;
+				break;	// 14~16
+			case 0:
+				init_prbs = 0x527;
+				break;	// 17~19
+			case 1:
+				init_prbs = 0x7FF;
+				break;	// 20~22
+			case 2:
+				init_prbs = 0x79B;
+				break;	// 23~25
+			case 3:
+				init_prbs = 0x3D6;
+				break;	// 26~28
+			case 4:
+				init_prbs = 0x3A2;
+				break;	// 29~31
+			case 5:
+				init_prbs = 0x53B;
+				break;	// 32~34
+			case 6:
+				init_prbs = 0x2F4;
+				break;	// 35~37
+			default:
+			case 7:
+				init_prbs = 0x213;
+				break;	// 38~40
+			}
 			break;
-	case QAM_16:
-			constellation = 2;
+
+		case TRANSMISSION_MODE_4K:
+			switch (sub_channel) {
+			case -6:
+				init_prbs = 0x0;
+				break;	// 41, 0, 1
+			case -5:
+				init_prbs = 0x208;
+				break;	// 02~04
+			case -4:
+				init_prbs = 0xC3;
+				break;	// 05~07
+			case -3:
+				init_prbs = 0x7B9;
+				break;	// 08~10
+			case -2:
+				init_prbs = 0x423;
+				break;	// 11~13
+			case -1:
+				init_prbs = 0x5C7;
+				break;	// 14~16
+			case 0:
+				init_prbs = 0x3D8;
+				break;	// 17~19
+			case 1:
+				init_prbs = 0x7FF;
+				break;	// 20~22
+			case 2:
+				init_prbs = 0x3D6;
+				break;	// 23~25
+			case 3:
+				init_prbs = 0x53B;
+				break;	// 26~28
+			case 4:
+				init_prbs = 0x213;
+				break;	// 29~31
+			case 5:
+				init_prbs = 0x29;
+				break;	// 32~34
+			case 6:
+				init_prbs = 0xD0;
+				break;	// 35~37
+			default:
+			case 7:
+				init_prbs = 0x48E;
+				break;	// 38~40
+			}
 			break;
-	case QAM_64:
-	default:
-			constellation = 3;
+
+		default:
+		case TRANSMISSION_MODE_8K:
+			switch (sub_channel) {
+			case -6:
+				init_prbs = 0x0;
+				break;	// 41, 0, 1
+			case -5:
+				init_prbs = 0x740;
+				break;	// 02~04
+			case -4:
+				init_prbs = 0x069;
+				break;	// 05~07
+			case -3:
+				init_prbs = 0x7DD;
+				break;	// 08~10
+			case -2:
+				init_prbs = 0x208;
+				break;	// 11~13
+			case -1:
+				init_prbs = 0x7B9;
+				break;	// 14~16
+			case 0:
+				init_prbs = 0x5C7;
+				break;	// 17~19
+			case 1:
+				init_prbs = 0x7FF;
+				break;	// 20~22
+			case 2:
+				init_prbs = 0x53B;
+				break;	// 23~25
+			case 3:
+				init_prbs = 0x29;
+				break;	// 26~28
+			case 4:
+				init_prbs = 0x48E;
+				break;	// 29~31
+			case 5:
+				init_prbs = 0x4C4;
+				break;	// 32~34
+			case 6:
+				init_prbs = 0x367;
+				break;	// 33~37
+			default:
+			case 7:
+				init_prbs = 0x684;
+				break;	// 38~40
+			}
 			break;
+		}
+	} else {
+		dib8000_write_word(state, 27, (u16) ((state->cfg.pll->ifreq >> 16) & 0x01ff));
+		dib8000_write_word(state, 28, (u16) (state->cfg.pll->ifreq & 0xffff));
+		dib8000_write_word(state, 26, (u16) ((state->cfg.pll->ifreq >> 25) & 0x0003));
 	}
+	/*P_mode == ?? */
+	dib8000_write_word(state, 10, (seq << 4));
+	//  dib8000_write_word(state, 287, (dib8000_read_word(state, 287) & 0xe000) | 0x1000);
 
-	switch (c->layer[layer_index].fec) {
-	case FEC_1_2:
-			cr = 1;
-			break;
-	case FEC_2_3:
-			cr = 2;
-			break;
-	case FEC_3_4:
-			cr = 3;
-			break;
-	case FEC_5_6:
-			cr = 5;
-			break;
-	case FEC_7_8:
+	switch (state->fe[0]->dtv_property_cache.guard_interval) {
+	case GUARD_INTERVAL_1_32:
+		guard = 0;
+		break;
+	case GUARD_INTERVAL_1_16:
+		guard = 1;
+		break;
+	case GUARD_INTERVAL_1_8:
+		guard = 2;
+		break;
+	case GUARD_INTERVAL_1_4:
 	default:
-			cr = 7;
-			break;
+		guard = 3;
+		break;
 	}
 
-	if ((c->layer[layer_index].interleaving > 0) && ((c->layer[layer_index].interleaving <= 3) || (c->layer[layer_index].interleaving == 4 && c->isdbt_sb_mode == 1)))
-		time_intlv = c->layer[layer_index].interleaving;
-	else
-		time_intlv = 0;
+	dib8000_write_word(state, 1, (init_prbs << 2) | (guard & 0x3));	// ADDR 1
 
-	dib8000_write_word(state, 2 + layer_index, (constellation << 10) | ((c->layer[layer_index].segment_count & 0xf) << 6) | (cr << 3) | time_intlv);
-	if (c->layer[layer_index].segment_count > 0) {
-		switch (max_constellation) {
+	max_constellation = DQPSK;
+	for (i = 0; i < 3; i++) {
+		switch (state->fe[0]->dtv_property_cache.layer[i].modulation) {
 		case DQPSK:
+			constellation = 0;
+			break;
 		case QPSK:
-				if (c->layer[layer_index].modulation == QAM_16 || c->layer[layer_index].modulation == QAM_64)
-					max_constellation = c->layer[layer_index].modulation;
-				break;
+			constellation = 1;
+			break;
 		case QAM_16:
-				if (c->layer[layer_index].modulation == QAM_64)
-					max_constellation = c->layer[layer_index].modulation;
-				break;
+			constellation = 2;
+			break;
+		case QAM_64:
+		default:
+			constellation = 3;
+			break;
 		}
-	}
-
-	return  max_constellation;
-}
-
-static const u16 adp_Q64[4] = {0x0148, 0xfff0, 0x00a4, 0xfff8}; /* P_adp_regul_cnt 0.04, P_adp_noise_cnt -0.002, P_adp_regul_ext 0.02, P_adp_noise_ext -0.001 */
-static const u16 adp_Q16[4] = {0x023d, 0xffdf, 0x00a4, 0xfff0}; /* P_adp_regul_cnt 0.07, P_adp_noise_cnt -0.004, P_adp_regul_ext 0.02, P_adp_noise_ext -0.002 */
-static const u16 adp_Qdefault[4] = {0x099a, 0xffae, 0x0333, 0xfff8}; /* P_adp_regul_cnt 0.3,  P_adp_noise_cnt -0.01,  P_adp_regul_ext 0.1,  P_adp_noise_ext -0.002 */
-static u16 dib8000_adp_fine_tune(struct dib8000_state *state, u16 max_constellation)
-{
-	u16 i, ana_gain = 0;
-	const u16 *adp;
 
-	/* channel estimation fine configuration */
-	switch (max_constellation) {
-	case QAM_64:
-			ana_gain = 0x7;
-			adp = &adp_Q64[0];
+		switch (state->fe[0]->dtv_property_cache.layer[i].fec) {
+		case FEC_1_2:
+			crate = 1;
 			break;
-	case QAM_16:
-			ana_gain = 0x7;
-			adp = &adp_Q16[0];
+		case FEC_2_3:
+			crate = 2;
 			break;
-	default:
-			ana_gain = 0;
-			adp = &adp_Qdefault[0];
+		case FEC_3_4:
+			crate = 3;
 			break;
-	}
-
-	for (i = 0; i < 4; i++)
-		dib8000_write_word(state, 215 + i, adp[i]);
-
-	return ana_gain;
-}
-
-static void dib8000_update_ana_gain(struct dib8000_state *state, u16 ana_gain)
-{
-	u16 i;
-
-	dib8000_write_word(state, 116, ana_gain);
-
-	/* update ADC target depending on ana_gain */
-	if (ana_gain) { /* set -16dB ADC target for ana_gain=-1 */
-		for (i = 0; i < 10; i++)
-			dib8000_write_word(state, 80 + i, adc_target_16dB[i]);
-	} else { /* set -22dB ADC target for ana_gain=0 */
-		for (i = 0; i < 10; i++)
-			dib8000_write_word(state, 80 + i, adc_target_16dB[i] - 355);
-	}
-}
-
-static void dib8000_load_ana_fe_coefs(struct dib8000_state *state, const s16 *ana_fe)
-{
-	u16 mode = 0;
-
-	if (state->isdbt_cfg_loaded == 0)
-		for (mode = 0; mode < 24; mode++)
-			dib8000_write_word(state, 117 + mode, ana_fe[mode]);
-}
-
-static const u16 lut_prbs_2k[14] = {
-	0, 0x423, 0x009, 0x5C7, 0x7A6, 0x3D8, 0x527, 0x7FF, 0x79B, 0x3D6, 0x3A2, 0x53B, 0x2F4, 0x213
-};
-static const u16 lut_prbs_4k[14] = {
-	0, 0x208, 0x0C3, 0x7B9, 0x423, 0x5C7, 0x3D8, 0x7FF, 0x3D6, 0x53B, 0x213, 0x029, 0x0D0, 0x48E
-};
-static const u16 lut_prbs_8k[14] = {
-	0, 0x740, 0x069, 0x7DD, 0x208, 0x7B9, 0x5C7, 0x7FF, 0x53B, 0x029, 0x48E, 0x4C4, 0x367, 0x684
-};
-
-static u16 dib8000_get_init_prbs(struct dib8000_state *state, u16 subchannel)
-{
-	int sub_channel_prbs_group = 0;
-
-	sub_channel_prbs_group = (subchannel / 3) + 1;
-	dprintk("sub_channel_prbs_group = %d , subchannel =%d prbs = 0x%04x", sub_channel_prbs_group, subchannel, lut_prbs_8k[sub_channel_prbs_group]);
+		case FEC_5_6:
+			crate = 5;
+			break;
+		case FEC_7_8:
+		default:
+			crate = 7;
+			break;
+		}
 
-	switch (state->fe[0]->dtv_property_cache.transmission_mode) {
-	case TRANSMISSION_MODE_2K:
-			return lut_prbs_2k[sub_channel_prbs_group];
-	case TRANSMISSION_MODE_4K:
-			return lut_prbs_4k[sub_channel_prbs_group];
-	default:
-	case TRANSMISSION_MODE_8K:
-			return lut_prbs_8k[sub_channel_prbs_group];
+		if ((state->fe[0]->dtv_property_cache.layer[i].interleaving > 0) &&
+				((state->fe[0]->dtv_property_cache.layer[i].interleaving <= 3) ||
+				 (state->fe[0]->dtv_property_cache.layer[i].interleaving == 4 && state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1))
+			)
+			timeI = state->fe[0]->dtv_property_cache.layer[i].interleaving;
+		else
+			timeI = 0;
+		dib8000_write_word(state, 2 + i, (constellation << 10) | ((state->fe[0]->dtv_property_cache.layer[i].segment_count & 0xf) << 6) |
+					(crate << 3) | timeI);
+		if (state->fe[0]->dtv_property_cache.layer[i].segment_count > 0) {
+			switch (max_constellation) {
+			case DQPSK:
+			case QPSK:
+				if (state->fe[0]->dtv_property_cache.layer[i].modulation == QAM_16 ||
+					state->fe[0]->dtv_property_cache.layer[i].modulation == QAM_64)
+					max_constellation = state->fe[0]->dtv_property_cache.layer[i].modulation;
+				break;
+			case QAM_16:
+				if (state->fe[0]->dtv_property_cache.layer[i].modulation == QAM_64)
+					max_constellation = state->fe[0]->dtv_property_cache.layer[i].modulation;
+				break;
+			}
+		}
 	}
-}
 
-static void dib8000_set_13seg_channel(struct dib8000_state *state)
-{
-	u16 i;
-	u16 coff_pow = 0x2800;
+	mode = fft_to_mode(state);
 
-	state->seg_mask = 0x1fff; /* All 13 segments enabled */
+	//dib8000_write_word(state, 5, 13); /*p_last_seg = 13*/
 
-	/* ---- COFF ---- Carloff, the most robust --- */
-	if (state->isdbt_cfg_loaded == 0) {  /* if not Sound Broadcasting mode : put default values for 13 segments */
-		dib8000_write_word(state, 180, (16 << 6) | 9);
-		dib8000_write_word(state, 187, (4 << 12) | (8 << 5) | 0x2);
-		coff_pow = 0x2800;
-		for (i = 0; i < 6; i++)
-			dib8000_write_word(state, 181+i, coff_pow);
+	dib8000_write_word(state, 274, (dib8000_read_word(state, 274) & 0xffcf) |
+				((state->fe[0]->dtv_property_cache.isdbt_partial_reception & 1) << 5) | ((state->fe[0]->dtv_property_cache.
+												 isdbt_sb_mode & 1) << 4));
 
-		/* P_ctrl_corm_thres4pre_freq_inh=1, P_ctrl_pre_freq_mode_sat=1 */
-		/* P_ctrl_pre_freq_mode_sat=1, P_ctrl_pre_freq_inh=0, P_ctrl_pre_freq_step = 3, P_pre_freq_win_len=1 */
-		dib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (3 << 5) | 1);
+	dprintk("mode = %d ; guard = %d", mode, state->fe[0]->dtv_property_cache.guard_interval);
 
-		/* P_ctrl_pre_freq_win_len=8, P_ctrl_pre_freq_thres_lockin=6 */
-		dib8000_write_word(state, 340, (8 << 6) | (6 << 0));
-		/* P_ctrl_pre_freq_thres_lockout=4, P_small_use_tmcc/ac/cp=1 */
-		dib8000_write_word(state, 341, (4 << 3) | (1 << 2) | (1 << 1) | (1 << 0));
+	/* signal optimization parameter */
 
-		dib8000_write_word(state, 228, 0);  /* default value */
-		dib8000_write_word(state, 265, 31); /* default value */
-		dib8000_write_word(state, 205, 0x200f); /* init value */
+	if (state->fe[0]->dtv_property_cache.isdbt_partial_reception) {
+		seg_diff_mask = (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) << permu_seg[0];
+		for (i = 1; i < 3; i++)
+			nbseg_diff +=
+				(state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * state->fe[0]->dtv_property_cache.layer[i].segment_count;
+		for (i = 0; i < nbseg_diff; i++)
+			seg_diff_mask |= 1 << permu_seg[i + 1];
+	} else {
+		for (i = 0; i < 3; i++)
+			nbseg_diff +=
+				(state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * state->fe[0]->dtv_property_cache.layer[i].segment_count;
+		for (i = 0; i < nbseg_diff; i++)
+			seg_diff_mask |= 1 << permu_seg[i];
 	}
+	dprintk("nbseg_diff = %X (%d)", seg_diff_mask, seg_diff_mask);
 
-	/*
-	 * make the cpil_coff_lock more robust but slower p_coff_winlen
-	 * 6bits; p_coff_thres_lock 6bits (for coff lock if needed)
-	 */
-
-	if (state->cfg.pll->ifreq == 0)
-		dib8000_write_word(state, 266, ~state->seg_mask | state->seg_diff_mask | 0x40); /* P_equal_noise_seg_inh */
+	state->differential_constellation = (seg_diff_mask != 0);
+	if (state->revision != 0x8090)
+		dib8000_set_diversity_in(state->fe[0], state->diversity_onoff);
+	else
+		dib8096p_set_diversity_in(state->fe[0], state->diversity_onoff);
 
-	dib8000_load_ana_fe_coefs(state, ana_fe_coeff_13seg);
-}
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
+		if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 1)
+			seg_mask13 = 0x00E0;
+		else		// 1-segment
+			seg_mask13 = 0x0040;
+	} else
+		seg_mask13 = 0x1fff;
 
-static void dib8000_set_subchannel_prbs(struct dib8000_state *state, u16 init_prbs)
-{
-	u16 reg_1;
+	// WRITE: Mode & Diff mask
+	dib8000_write_word(state, 0, (mode << 13) | seg_diff_mask);
 
-	reg_1 = dib8000_read_word(state, 1);
-	dib8000_write_word(state, 1, (init_prbs << 2) | (reg_1 & 0x3)); /* ADDR 1 */
-}
+	if ((seg_diff_mask) || (state->fe[0]->dtv_property_cache.isdbt_sb_mode))
+		dib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);
+	else
+		dib8000_write_word(state, 268, (2 << 9) | 39);	//init value
 
-static void dib8000_small_fine_tune(struct dib8000_state *state)
-{
-	u16 i;
-	const s16 *ncoeff;
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
+	// ---- SMALL ----
+	// P_small_seg_diff
+	dib8000_write_word(state, 352, seg_diff_mask);	// ADDR 352
 
-	dib8000_write_word(state, 352, state->seg_diff_mask);
-	dib8000_write_word(state, 353, state->seg_mask);
+	dib8000_write_word(state, 353, seg_mask13);	// ADDR 353
 
-	/* P_small_coef_ext_enable=ISDB-Tsb, P_small_narrow_band=ISDB-Tsb, P_small_last_seg=13, P_small_offset_num_car=5 */
-	dib8000_write_word(state, 351, (c->isdbt_sb_mode << 9) | (c->isdbt_sb_mode << 8) | (13 << 4) | 5);
+/*	// P_small_narrow_band=0, P_small_last_seg=13, P_small_offset_num_car=5 */
 
-	if (c->isdbt_sb_mode) {
-		/* ---- SMALL ---- */
-		switch (c->transmission_mode) {
+	// ---- SMALL ----
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
+		switch (state->fe[0]->dtv_property_cache.transmission_mode) {
 		case TRANSMISSION_MODE_2K:
-				if (c->isdbt_partial_reception == 0) { /* 1-seg */
-					if (c->layer[0].modulation == DQPSK) /* DQPSK */
-						ncoeff = coeff_2k_sb_1seg_dqpsk;
-					else /* QPSK or QAM */
-						ncoeff = coeff_2k_sb_1seg;
-				} else { /* 3-segments */
-					if (c->layer[0].modulation == DQPSK) { /* DQPSK on central segment */
-						if (c->layer[1].modulation == DQPSK) /* DQPSK on external segments */
-							ncoeff = coeff_2k_sb_3seg_0dqpsk_1dqpsk;
-						else /* QPSK or QAM on external segments */
-							ncoeff = coeff_2k_sb_3seg_0dqpsk;
-					} else { /* QPSK or QAM on central segment */
-						if (c->layer[1].modulation == DQPSK) /* DQPSK on external segments */
-							ncoeff = coeff_2k_sb_3seg_1dqpsk;
-						else /* QPSK or QAM on external segments */
-							ncoeff = coeff_2k_sb_3seg;
-					}
+			if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {
+				if (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)
+					ncoeff = coeff_2k_sb_1seg_dqpsk;
+				else	// QPSK or QAM
+					ncoeff = coeff_2k_sb_1seg;
+			} else {	// 3-segments
+				if (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {
+					if (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK)
+						ncoeff = coeff_2k_sb_3seg_0dqpsk_1dqpsk;
+					else	// QPSK or QAM on external segments
+						ncoeff = coeff_2k_sb_3seg_0dqpsk;
+				} else {	// QPSK or QAM on central segment
+					if (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK)
+						ncoeff = coeff_2k_sb_3seg_1dqpsk;
+					else	// QPSK or QAM on external segments
+						ncoeff = coeff_2k_sb_3seg;
 				}
-				break;
+			}
+			break;
+
 		case TRANSMISSION_MODE_4K:
-				if (c->isdbt_partial_reception == 0) { /* 1-seg */
-					if (c->layer[0].modulation == DQPSK) /* DQPSK */
-						ncoeff = coeff_4k_sb_1seg_dqpsk;
-					else /* QPSK or QAM */
-						ncoeff = coeff_4k_sb_1seg;
-				} else { /* 3-segments */
-					if (c->layer[0].modulation == DQPSK) { /* DQPSK on central segment */
-						if (c->layer[1].modulation == DQPSK) /* DQPSK on external segments */
-							ncoeff = coeff_4k_sb_3seg_0dqpsk_1dqpsk;
-						else /* QPSK or QAM on external segments */
-							ncoeff = coeff_4k_sb_3seg_0dqpsk;
-					} else { /* QPSK or QAM on central segment */
-						if (c->layer[1].modulation == DQPSK) /* DQPSK on external segments */
-							ncoeff = coeff_4k_sb_3seg_1dqpsk;
-						else /* QPSK or QAM on external segments */
-							ncoeff = coeff_4k_sb_3seg;
+			if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {
+				if (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)
+					ncoeff = coeff_4k_sb_1seg_dqpsk;
+				else	// QPSK or QAM
+					ncoeff = coeff_4k_sb_1seg;
+			} else {	// 3-segments
+				if (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {
+					if (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {
+						ncoeff = coeff_4k_sb_3seg_0dqpsk_1dqpsk;
+					} else {	// QPSK or QAM on external segments
+						ncoeff = coeff_4k_sb_3seg_0dqpsk;
 					}
+				} else {	// QPSK or QAM on central segment
+					if (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {
+						ncoeff = coeff_4k_sb_3seg_1dqpsk;
+					} else	// QPSK or QAM on external segments
+						ncoeff = coeff_4k_sb_3seg;
 				}
-				break;
+			}
+			break;
+
 		case TRANSMISSION_MODE_AUTO:
 		case TRANSMISSION_MODE_8K:
 		default:
-				if (c->isdbt_partial_reception == 0) { /* 1-seg */
-					if (c->layer[0].modulation == DQPSK) /* DQPSK */
-						ncoeff = coeff_8k_sb_1seg_dqpsk;
-					else /* QPSK or QAM */
-						ncoeff = coeff_8k_sb_1seg;
-				} else { /* 3-segments */
-					if (c->layer[0].modulation == DQPSK) { /* DQPSK on central segment */
-						if (c->layer[1].modulation == DQPSK) /* DQPSK on external segments */
-							ncoeff = coeff_8k_sb_3seg_0dqpsk_1dqpsk;
-						else /* QPSK or QAM on external segments */
-							ncoeff = coeff_8k_sb_3seg_0dqpsk;
-					} else { /* QPSK or QAM on central segment */
-						if (c->layer[1].modulation == DQPSK) /* DQPSK on external segments */
-							ncoeff = coeff_8k_sb_3seg_1dqpsk;
-						else /* QPSK or QAM on external segments */
-							ncoeff = coeff_8k_sb_3seg;
+			if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {
+				if (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK)
+					ncoeff = coeff_8k_sb_1seg_dqpsk;
+				else	// QPSK or QAM
+					ncoeff = coeff_8k_sb_1seg;
+			} else {	// 3-segments
+				if (state->fe[0]->dtv_property_cache.layer[0].modulation == DQPSK) {
+					if (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {
+						ncoeff = coeff_8k_sb_3seg_0dqpsk_1dqpsk;
+					} else {	// QPSK or QAM on external segments
+						ncoeff = coeff_8k_sb_3seg_0dqpsk;
 					}
+				} else {	// QPSK or QAM on central segment
+					if (state->fe[0]->dtv_property_cache.layer[1].modulation == DQPSK) {
+						ncoeff = coeff_8k_sb_3seg_1dqpsk;
+					} else	// QPSK or QAM on external segments
+						ncoeff = coeff_8k_sb_3seg;
 				}
-				break;
+			}
+			break;
 		}
-
 		for (i = 0; i < 8; i++)
 			dib8000_write_word(state, 343 + i, ncoeff[i]);
 	}
-}
-
-static const u16 coff_thres_1seg[3] = {300, 150, 80};
-static const u16 coff_thres_3seg[3] = {350, 300, 250};
-static void dib8000_set_sb_channel(struct dib8000_state *state)
-{
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	const u16 *coff;
-	u16 i;
-
-	if (c->transmission_mode == TRANSMISSION_MODE_2K || c->transmission_mode == TRANSMISSION_MODE_4K) {
-		dib8000_write_word(state, 219, dib8000_read_word(state, 219) | 0x1); /* adp_pass =1 */
-		dib8000_write_word(state, 190, dib8000_read_word(state, 190) | (0x1 << 14)); /* pha3_force_pha_shift = 1 */
-	} else {
-		dib8000_write_word(state, 219, dib8000_read_word(state, 219) & 0xfffe); /* adp_pass =0 */
-		dib8000_write_word(state, 190, dib8000_read_word(state, 190) & 0xbfff); /* pha3_force_pha_shift = 0 */
-	}
 
-	if (c->isdbt_partial_reception == 1) /* 3-segments */
-		state->seg_mask = 0x00E0;
-	else /* 1-segment */
-		state->seg_mask = 0x0040;
+	// P_small_coef_ext_enable=ISDB-Tsb, P_small_narrow_band=ISDB-Tsb, P_small_last_seg=13, P_small_offset_num_car=5
+	dib8000_write_word(state, 351,
+				(state->fe[0]->dtv_property_cache.isdbt_sb_mode << 9) | (state->fe[0]->dtv_property_cache.isdbt_sb_mode << 8) | (13 << 4) | 5);
 
-	dib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);
+	// ---- COFF ----
+	// Carloff, the most robust
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
 
-	/* ---- COFF ---- Carloff, the most robust --- */
-	/* P_coff_cpil_alpha=4, P_coff_inh=0, P_coff_cpil_winlen=64, P_coff_narrow_band=1, P_coff_square_val=1, P_coff_one_seg=~partial_rcpt, P_coff_use_tmcc=1, P_coff_use_ac=1 */
-	dib8000_write_word(state, 187, (4 << 12) | (0 << 11) | (63 << 5) | (0x3 << 3) | ((~c->isdbt_partial_reception & 1) << 2) | 0x3);
+		// P_coff_cpil_alpha=4, P_coff_inh=0, P_coff_cpil_winlen=64
+		// P_coff_narrow_band=1, P_coff_square_val=1, P_coff_one_seg=~partial_rcpt, P_coff_use_tmcc=1, P_coff_use_ac=1
+		dib8000_write_word(state, 187,
+					(4 << 12) | (0 << 11) | (63 << 5) | (0x3 << 3) | ((~state->fe[0]->dtv_property_cache.isdbt_partial_reception & 1) << 2)
+					| 0x3);
 
-	dib8000_write_word(state, 340, (16 << 6) | (8 << 0)); /* P_ctrl_pre_freq_win_len=16, P_ctrl_pre_freq_thres_lockin=8 */
-	dib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));/* P_ctrl_pre_freq_thres_lockout=6, P_small_use_tmcc/ac/cp=1 */
+/*		// P_small_coef_ext_enable = 1 */
+/*		dib8000_write_word(state, 351, dib8000_read_word(state, 351) | 0x200); */
 
-	/* Sound Broadcasting mode 1 seg */
-	if (c->isdbt_partial_reception == 0) {
-		/* P_coff_winlen=63, P_coff_thres_lock=15, P_coff_one_seg_width = (P_mode == 3) , P_coff_one_seg_sym = (P_mode-1) */
-		if (state->mode == 3)
-			dib8000_write_word(state, 180, 0x1fcf | ((state->mode - 1) << 14));
-		else
-			dib8000_write_word(state, 180, 0x0fcf | ((state->mode - 1) << 14));
+		if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {
 
-		/* P_ctrl_corm_thres4pre_freq_inh=1,P_ctrl_pre_freq_mode_sat=1, P_ctrl_pre_freq_inh=0, P_ctrl_pre_freq_step = 5, P_pre_freq_win_len=4 */
-		dib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (5 << 5) | 4);
-		coff = &coff_thres_1seg[0];
-	} else {   /* Sound Broadcasting mode 3 seg */
-		dib8000_write_word(state, 180, 0x1fcf | (1 << 14));
-		/* P_ctrl_corm_thres4pre_freq_inh = 1, P_ctrl_pre_freq_mode_sat=1, P_ctrl_pre_freq_inh=0, P_ctrl_pre_freq_step = 4, P_pre_freq_win_len=4 */
-		dib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (4 << 5) | 4);
-		coff = &coff_thres_3seg[0];
-	}
+			// P_coff_winlen=63, P_coff_thres_lock=15, P_coff_one_seg_width= (P_mode == 3) , P_coff_one_seg_sym= (P_mode-1)
+			if (mode == 3)
+				dib8000_write_word(state, 180, 0x1fcf | ((mode - 1) << 14));
+			else
+				dib8000_write_word(state, 180, 0x0fcf | ((mode - 1) << 14));
+			// P_ctrl_corm_thres4pre_freq_inh=1,P_ctrl_pre_freq_mode_sat=1,
+			// P_ctrl_pre_freq_inh=0, P_ctrl_pre_freq_step = 5, P_pre_freq_win_len=4
+			dib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (5 << 5) | 4);
+			// P_ctrl_pre_freq_win_len=16, P_ctrl_pre_freq_thres_lockin=8
+			dib8000_write_word(state, 340, (16 << 6) | (8 << 0));
+			// P_ctrl_pre_freq_thres_lockout=6, P_small_use_tmcc/ac/cp=1
+			dib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));
+
+			// P_coff_corthres_8k, 4k, 2k and P_coff_cpilthres_8k, 4k, 2k
+			dib8000_write_word(state, 181, 300);
+			dib8000_write_word(state, 182, 150);
+			dib8000_write_word(state, 183, 80);
+			dib8000_write_word(state, 184, 300);
+			dib8000_write_word(state, 185, 150);
+			dib8000_write_word(state, 186, 80);
+		} else {	// Sound Broadcasting mode 3 seg
+			// P_coff_one_seg_sym= 1, P_coff_one_seg_width= 1, P_coff_winlen=63, P_coff_thres_lock=15
+			/*	if (mode == 3) */
+			/*		dib8000_write_word(state, 180, 0x2fca | ((0) << 14)); */
+			/*	else */
+			/*		dib8000_write_word(state, 180, 0x2fca | ((1) << 14)); */
+			dib8000_write_word(state, 180, 0x1fcf | (1 << 14));
+
+			// P_ctrl_corm_thres4pre_freq_inh = 1, P_ctrl_pre_freq_mode_sat=1,
+			// P_ctrl_pre_freq_inh=0, P_ctrl_pre_freq_step = 4, P_pre_freq_win_len=4
+			dib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (4 << 5) | 4);
+			// P_ctrl_pre_freq_win_len=16, P_ctrl_pre_freq_thres_lockin=8
+			dib8000_write_word(state, 340, (16 << 6) | (8 << 0));
+			//P_ctrl_pre_freq_thres_lockout=6, P_small_use_tmcc/ac/cp=1
+			dib8000_write_word(state, 341, (6 << 3) | (1 << 2) | (1 << 1) | (1 << 0));
+
+			// P_coff_corthres_8k, 4k, 2k and P_coff_cpilthres_8k, 4k, 2k
+			dib8000_write_word(state, 181, 350);
+			dib8000_write_word(state, 182, 300);
+			dib8000_write_word(state, 183, 250);
+			dib8000_write_word(state, 184, 350);
+			dib8000_write_word(state, 185, 300);
+			dib8000_write_word(state, 186, 250);
+		}
 
-	dib8000_write_word(state, 228, 1); /* P_2d_mode_byp=1 */
-	dib8000_write_word(state, 205, dib8000_read_word(state, 205) & 0xfff0); /* P_cspu_win_cut = 0 */
+	} else if (state->isdbt_cfg_loaded == 0) {	// if not Sound Broadcasting mode : put default values for 13 segments
+		dib8000_write_word(state, 180, (16 << 6) | 9);
+		dib8000_write_word(state, 187, (4 << 12) | (8 << 5) | 0x2);
+		coff_pow = 0x2800;
+		for (i = 0; i < 6; i++)
+			dib8000_write_word(state, 181 + i, coff_pow);
 
-	if (c->isdbt_partial_reception == 0 && c->transmission_mode == TRANSMISSION_MODE_2K)
-		dib8000_write_word(state, 265, 15); /* P_equal_noise_sel = 15 */
+		// P_ctrl_corm_thres4pre_freq_inh=1, P_ctrl_pre_freq_mode_sat=1,
+		// P_ctrl_pre_freq_mode_sat=1, P_ctrl_pre_freq_inh=0, P_ctrl_pre_freq_step = 3, P_pre_freq_win_len=1
+		dib8000_write_word(state, 338, (1 << 12) | (1 << 10) | (0 << 9) | (3 << 5) | 1);
 
-	/* Write COFF thres */
-	for (i = 0 ; i < 3; i++) {
-		dib8000_write_word(state, 181+i, coff[i]);
-		dib8000_write_word(state, 184+i, coff[i]);
+		// P_ctrl_pre_freq_win_len=8, P_ctrl_pre_freq_thres_lockin=6
+		dib8000_write_word(state, 340, (8 << 6) | (6 << 0));
+		// P_ctrl_pre_freq_thres_lockout=4, P_small_use_tmcc/ac/cp=1
+		dib8000_write_word(state, 341, (4 << 3) | (1 << 2) | (1 << 1) | (1 << 0));
 	}
+	// ---- FFT ----
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1 && state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)
+		dib8000_write_word(state, 178, 64);	// P_fft_powrange=64
+	else
+		dib8000_write_word(state, 178, 32);	// P_fft_powrange=32
 
-	/*
-	 * make the cpil_coff_lock more robust but slower p_coff_winlen
+	/* make the cpil_coff_lock more robust but slower p_coff_winlen
 	 * 6bits; p_coff_thres_lock 6bits (for coff lock if needed)
 	 */
-
-	dib8000_write_word(state, 266, ~state->seg_mask | state->seg_diff_mask); /* P_equal_noise_seg_inh */
-
-	if (c->isdbt_partial_reception == 0)
-		dib8000_write_word(state, 178, 64); /* P_fft_powrange = 64 */
+	/* if ( ( nbseg_diff>0)&&(nbseg_diff<13))
+		dib8000_write_word(state, 187, (dib8000_read_word(state, 187) & 0xfffb) | (1 << 3)); */
+
+	dib8000_write_word(state, 189, ~seg_mask13 | seg_diff_mask);	/* P_lmod4_seg_inh       */
+	dib8000_write_word(state, 192, ~seg_mask13 | seg_diff_mask);	/* P_pha3_seg_inh        */
+	dib8000_write_word(state, 225, ~seg_mask13 | seg_diff_mask);	/* P_tac_seg_inh         */
+	if ((!state->fe[0]->dtv_property_cache.isdbt_sb_mode) && (state->cfg.pll->ifreq == 0))
+		dib8000_write_word(state, 266, ~seg_mask13 | seg_diff_mask | 0x40);	/* P_equal_noise_seg_inh */
 	else
-		dib8000_write_word(state, 178, 32); /* P_fft_powrange = 32 */
-}
+		dib8000_write_word(state, 266, ~seg_mask13 | seg_diff_mask);	/* P_equal_noise_seg_inh */
+	dib8000_write_word(state, 287, ~seg_mask13 | 0x1000);	/* P_tmcc_seg_inh        */
+	//dib8000_write_word(state, 288, ~seg_mask13 | seg_diff_mask); /* P_tmcc_seg_eq_inh */
+	if (!autosearching)
+		dib8000_write_word(state, 288, (~seg_mask13 | seg_diff_mask) & 0x1fff);	/* P_tmcc_seg_eq_inh */
+	else
+		dib8000_write_word(state, 288, 0x1fff);	//disable equalisation of the tmcc when autosearch to be able to find the DQPSK channels.
+	dprintk("287 = %X (%d)", ~seg_mask13 | 0x1000, ~seg_mask13 | 0x1000);
+
+	dib8000_write_word(state, 211, seg_mask13 & (~seg_diff_mask));	/* P_des_seg_enabled     */
+
+	/* offset loop parameters */
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
+		if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)
+			/* P_timf_alpha = (11-P_mode), P_corm_alpha=6, P_corm_thres=0x80 */
+			dib8000_write_word(state, 32, ((11 - mode) << 12) | (6 << 8) | 0x40);
+
+		else		// Sound Broadcasting mode 3 seg
+			/* P_timf_alpha = (10-P_mode), P_corm_alpha=6, P_corm_thres=0x80 */
+			dib8000_write_word(state, 32, ((10 - mode) << 12) | (6 << 8) | 0x60);
+	} else
+		// TODO in 13 seg, timf_alpha can always be the same or not ?
+		/* P_timf_alpha = (9-P_mode, P_corm_alpha=6, P_corm_thres=0x80 */
+		dib8000_write_word(state, 32, ((9 - mode) << 12) | (6 << 8) | 0x80);
+
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
+		if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)
+			/* P_ctrl_pha_off_max=3   P_ctrl_sfreq_inh =0  P_ctrl_sfreq_step = (11-P_mode)  */
+			dib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (10 - mode));
+
+		else		// Sound Broadcasting mode 3 seg
+			/* P_ctrl_pha_off_max=3   P_ctrl_sfreq_inh =0  P_ctrl_sfreq_step = (10-P_mode)  */
+			dib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (9 - mode));
+	} else
+		/* P_ctrl_pha_off_max=3   P_ctrl_sfreq_inh =0  P_ctrl_sfreq_step = 9  */
+		dib8000_write_word(state, 37, (3 << 5) | (0 << 4) | (8 - mode));
 
-static void dib8000_set_isdbt_common_channel(struct dib8000_state *state, u8 seq, u8 autosearching)
-{
-	u16 p_cfr_left_edge  = 0, p_cfr_right_edge = 0;
-	u16 tmcc_pow = 0, ana_gain = 0, tmp = 0, i = 0, nbseg_diff = 0 ;
-	u16 max_constellation = DQPSK;
-	int init_prbs;
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-
-	/* P_mode */
-	dib8000_write_word(state, 10, (seq << 4));
-
-	/* init mode */
-	state->mode = fft_to_mode(state);
-
-	/* set guard */
-	tmp = dib8000_read_word(state, 1);
-	dib8000_write_word(state, 1, (tmp&0xfffc) | (c->guard_interval & 0x3));
-
-	dib8000_write_word(state, 274, (dib8000_read_word(state, 274) & 0xffcf) | ((c->isdbt_partial_reception & 1) << 5) | ((c->isdbt_sb_mode & 1) << 4));
-
-	/* signal optimization parameter */
-	if (c->isdbt_partial_reception) {
-		state->seg_diff_mask = (c->layer[0].modulation == DQPSK) << permu_seg[0];
-		for (i = 1; i < 3; i++)
-			nbseg_diff += (c->layer[i].modulation == DQPSK) * c->layer[i].segment_count;
-		for (i = 0; i < nbseg_diff; i++)
-			state->seg_diff_mask |= 1 << permu_seg[i+1];
-	} else {
-		for (i = 0; i < 3; i++)
-			nbseg_diff += (c->layer[i].modulation == DQPSK) * c->layer[i].segment_count;
-		for (i = 0; i < nbseg_diff; i++)
-			state->seg_diff_mask |= 1 << permu_seg[i];
+	/* P_dvsy_sync_wait - reuse mode */
+	switch (state->fe[0]->dtv_property_cache.transmission_mode) {
+	case TRANSMISSION_MODE_8K:
+		mode = 256;
+		break;
+	case TRANSMISSION_MODE_4K:
+		mode = 128;
+		break;
+	default:
+	case TRANSMISSION_MODE_2K:
+		mode = 64;
+		break;
 	}
-
-	if (state->seg_diff_mask)
-		dib8000_write_word(state, 268, (dib8000_read_word(state, 268) & 0xF9FF) | 0x0200);
+	if (state->cfg.diversity_delay == 0)
+		mode = (mode * (1 << (guard)) * 3) / 2 + 48;	// add 50% SFN margin + compensate for one DVSY-fifo
 	else
-		dib8000_write_word(state, 268, (2 << 9) | 39); /*init value */
-
-	for (i = 0; i < 3; i++)
-		max_constellation = dib8000_set_layer(state, i, max_constellation);
-	if (autosearching == 0) {
-		state->layer_b_nb_seg = c->layer[1].segment_count;
-		state->layer_c_nb_seg = c->layer[2].segment_count;
-	}
-
-	/* WRITE: Mode & Diff mask */
-	dib8000_write_word(state, 0, (state->mode << 13) | state->seg_diff_mask);
-
-	state->differential_constellation = (state->seg_diff_mask != 0);
+		mode = (mode * (1 << (guard)) * 3) / 2 + state->cfg.diversity_delay;	// add 50% SFN margin + compensate for DVSY-fifo
+	mode <<= 4;
+	dib8000_write_word(state, 273, (dib8000_read_word(state, 273) & 0x000f) | mode);
 
 	/* channel estimation fine configuration */
-	ana_gain = dib8000_adp_fine_tune(state, max_constellation);
-
-	/* update ana_gain depending on max constellation */
-	dib8000_update_ana_gain(state, ana_gain);
-
-	/* ---- ANA_FE ---- */
-	if (c->isdbt_partial_reception) /* 3-segments */
-		dib8000_load_ana_fe_coefs(state, ana_fe_coeff_3seg);
-	else
-		dib8000_load_ana_fe_coefs(state, ana_fe_coeff_1seg); /* 1-segment */
+	switch (max_constellation) {
+	case QAM_64:
+		ana_gain = 0x7;	// -1 : avoid def_est saturation when ADC target is -16dB
+		coeff[0] = 0x0148;	/* P_adp_regul_cnt 0.04 */
+		coeff[1] = 0xfff0;	/* P_adp_noise_cnt -0.002 */
+		coeff[2] = 0x00a4;	/* P_adp_regul_ext 0.02 */
+		coeff[3] = 0xfff8;	/* P_adp_noise_ext -0.001 */
+		//if (!state->cfg.hostbus_diversity) //if diversity, we should prehaps use the configuration of the max_constallation -1
+		break;
+	case QAM_16:
+		ana_gain = 0x7;	// -1 : avoid def_est saturation when ADC target is -16dB
+		coeff[0] = 0x023d;	/* P_adp_regul_cnt 0.07 */
+		coeff[1] = 0xffdf;	/* P_adp_noise_cnt -0.004 */
+		coeff[2] = 0x00a4;	/* P_adp_regul_ext 0.02 */
+		coeff[3] = 0xfff0;	/* P_adp_noise_ext -0.002 */
+		//if (!((state->cfg.hostbus_diversity) && (max_constellation == QAM_16)))
+		break;
+	default:
+		ana_gain = 0;	// 0 : goes along with ADC target at -22dB to keep good mobile performance and lock at sensitivity level
+		coeff[0] = 0x099a;	/* P_adp_regul_cnt 0.3 */
+		coeff[1] = 0xffae;	/* P_adp_noise_cnt -0.01 */
+		coeff[2] = 0x0333;	/* P_adp_regul_ext 0.1 */
+		coeff[3] = 0xfff8;	/* P_adp_noise_ext -0.002 */
+		break;
+	}
+	for (mode = 0; mode < 4; mode++)
+		dib8000_write_word(state, 215 + mode, coeff[mode]);
 
-	/* TSB or ISDBT ? apply it now */
-	if (c->isdbt_sb_mode) {
-		dib8000_set_sb_channel(state);
-		if (c->isdbt_sb_subchannel < 14)
-			init_prbs = dib8000_get_init_prbs(state, c->isdbt_sb_subchannel);
-		else
-			init_prbs = 0;
-	} else {
-		dib8000_set_13seg_channel(state);
-		init_prbs = 0xfff;
+	// update ana_gain depending on max constellation
+	dib8000_write_word(state, 116, ana_gain);
+	// update ADC target depending on ana_gain
+	if (ana_gain) {		// set -16dB ADC target for ana_gain=-1
+		for (i = 0; i < 10; i++)
+			dib8000_write_word(state, 80 + i, adc_target_16dB[i]);
+	} else {		// set -22dB ADC target for ana_gain=0
+		for (i = 0; i < 10; i++)
+			dib8000_write_word(state, 80 + i, adc_target_16dB[i] - 355);
 	}
 
-	/* SMALL */
-	dib8000_small_fine_tune(state);
+	// ---- ANA_FE ----
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {
+		if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 1)
+			ana_fe = ana_fe_coeff_3seg;
+		else		// 1-segment
+			ana_fe = ana_fe_coeff_1seg;
+	} else
+		ana_fe = ana_fe_coeff_13seg;
 
-	dib8000_set_subchannel_prbs(state, init_prbs);
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1 || state->isdbt_cfg_loaded == 0)
+		for (mode = 0; mode < 24; mode++)
+			dib8000_write_word(state, 117 + mode, ana_fe[mode]);
 
-	/* ---- CHAN_BLK ---- */
+	// ---- CHAN_BLK ----
 	for (i = 0; i < 13; i++) {
-		if ((((~state->seg_diff_mask) >> i) & 1) == 1) {
-			p_cfr_left_edge  += (1 << i) * ((i == 0) || ((((state->seg_mask & (~state->seg_diff_mask)) >> (i - 1)) & 1) == 0));
-			p_cfr_right_edge += (1 << i) * ((i == 12) || ((((state->seg_mask & (~state->seg_diff_mask)) >> (i + 1)) & 1) == 0));
+		if ((((~seg_diff_mask) >> i) & 1) == 1) {
+			P_cfr_left_edge += (1 << i) * ((i == 0) || ((((seg_mask13 & (~seg_diff_mask)) >> (i - 1)) & 1) == 0));
+			P_cfr_right_edge += (1 << i) * ((i == 12) || ((((seg_mask13 & (~seg_diff_mask)) >> (i + 1)) & 1) == 0));
 		}
 	}
-	dib8000_write_word(state, 222, p_cfr_left_edge); /* p_cfr_left_edge */
-	dib8000_write_word(state, 223, p_cfr_right_edge); /* p_cfr_right_edge */
-	/* "P_cspu_left_edge" & "P_cspu_right_edge" not used => do not care */
-
-	dib8000_write_word(state, 189, ~state->seg_mask | state->seg_diff_mask); /* P_lmod4_seg_inh */
-	dib8000_write_word(state, 192, ~state->seg_mask | state->seg_diff_mask); /* P_pha3_seg_inh */
-	dib8000_write_word(state, 225, ~state->seg_mask | state->seg_diff_mask); /* P_tac_seg_inh */
-
-	if (!autosearching)
-		dib8000_write_word(state, 288, (~state->seg_mask | state->seg_diff_mask) & 0x1fff); /* P_tmcc_seg_eq_inh */
-	else
-		dib8000_write_word(state, 288, 0x1fff); /*disable equalisation of the tmcc when autosearch to be able to find the DQPSK channels. */
-
-	dib8000_write_word(state, 211, state->seg_mask & (~state->seg_diff_mask)); /* P_des_seg_enabled */
-	dib8000_write_word(state, 287, ~state->seg_mask | 0x1000); /* P_tmcc_seg_inh */
-
-	dib8000_write_word(state, 178, 32); /* P_fft_powrange = 32 */
-
-	/* ---- TMCC ---- */
+	dib8000_write_word(state, 222, P_cfr_left_edge);	// P_cfr_left_edge
+	dib8000_write_word(state, 223, P_cfr_right_edge);	// P_cfr_right_edge
+	// "P_cspu_left_edge"  not used => do not care
+	// "P_cspu_right_edge" not used => do not care
+
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
+		dib8000_write_word(state, 228, 1);	// P_2d_mode_byp=1
+		dib8000_write_word(state, 205, dib8000_read_word(state, 205) & 0xfff0);	// P_cspu_win_cut = 0
+		if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0
+			&& state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_2K) {
+			//dib8000_write_word(state, 219, dib8000_read_word(state, 219) & 0xfffe); // P_adp_pass = 0
+			dib8000_write_word(state, 265, 15);	// P_equal_noise_sel = 15
+		}
+	} else if (state->isdbt_cfg_loaded == 0) {
+		dib8000_write_word(state, 228, 0);	// default value
+		dib8000_write_word(state, 265, 31);	// default value
+		dib8000_write_word(state, 205, 0x200f);	// init value
+	}
+	// ---- TMCC ----
 	for (i = 0; i < 3; i++)
-		tmcc_pow += (((c->layer[i].modulation == DQPSK) * 4 + 1) * c->layer[i].segment_count) ;
+		tmcc_pow +=
+			(((state->fe[0]->dtv_property_cache.layer[i].modulation == DQPSK) * 4 + 1) * state->fe[0]->dtv_property_cache.layer[i].segment_count);
+	// Quantif of "P_tmcc_dec_thres_?k" is (0, 5+mode, 9);
+	// Threshold is set at 1/4 of max power.
+	tmcc_pow *= (1 << (9 - 2));
+
+	dib8000_write_word(state, 290, tmcc_pow);	// P_tmcc_dec_thres_2k
+	dib8000_write_word(state, 291, tmcc_pow);	// P_tmcc_dec_thres_4k
+	dib8000_write_word(state, 292, tmcc_pow);	// P_tmcc_dec_thres_8k
+	//dib8000_write_word(state, 287, (1 << 13) | 0x1000 );
+	// ---- PHA3 ----
 
-	/* Quantif of "P_tmcc_dec_thres_?k" is (0, 5+mode, 9); */
-	/* Threshold is set at 1/4 of max power. */
-	tmcc_pow *= (1 << (9-2));
-	dib8000_write_word(state, 290, tmcc_pow); /* P_tmcc_dec_thres_2k */
-	dib8000_write_word(state, 291, tmcc_pow); /* P_tmcc_dec_thres_4k */
-	dib8000_write_word(state, 292, tmcc_pow); /* P_tmcc_dec_thres_8k */
-	/*dib8000_write_word(state, 287, (1 << 13) | 0x1000 ); */
-
-	/* ---- PHA3 ---- */
 	if (state->isdbt_cfg_loaded == 0)
-		dib8000_write_word(state, 250, 3285); /* p_2d_hspeed_thr0 */
+		dib8000_write_word(state, 250, 3285);	/*p_2d_hspeed_thr0 */
 
-	state->isdbt_cfg_loaded = 0;
-}
-
-static u32 dib8000_wait_lock(struct dib8000_state *state, u32 internal,
-			     u32 wait0_ms, u32 wait1_ms, u32 wait2_ms)
-{
-	u32 value = 0;	/* P_search_end0 wait time */
-	u16 reg = 11;	/* P_search_end0 start addr */
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1)
+		state->isdbt_cfg_loaded = 0;
+	else
+		state->isdbt_cfg_loaded = 1;
 
-	for (reg = 11; reg < 16; reg += 2) {
-		if (reg == 11) {
-			if (state->revision == 0x8090)
-				value = internal * wait1_ms;
-			else
-				value = internal * wait0_ms;
-		} else if (reg == 13)
-			value = internal * wait1_ms;
-		else if (reg == 15)
-			value = internal * wait2_ms;
-		dib8000_write_word(state, reg, (u16)((value >> 16) & 0xffff));
-		dib8000_write_word(state, (reg + 1), (u16)(value & 0xffff));
-	}
-	return value;
 }
 
 static int dib8000_autosearch_start(struct dvb_frontend *fe)
 {
+	u8 factor;
+	u32 value;
 	struct dib8000_state *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	u8 slist = 0;
-	u32 value, internal = state->cfg.pll->internal;
-
-	if (state->revision == 0x8090)
-		internal = dib8000_read32(state, 23) / 1000;
-
-	if ((state->revision >= 0x8002) &&
-	    (state->autosearch_state == AS_SEARCHING_FFT)) {
-		dib8000_write_word(state,  37, 0x0065); /* P_ctrl_pha_off_max default values */
-		dib8000_write_word(state, 116, 0x0000); /* P_ana_gain to 0 */
-
-		dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x1fff) | (0 << 13) | (1 << 15)); /* P_mode = 0, P_restart_search=1 */
-		dib8000_write_word(state, 1, (dib8000_read_word(state, 1) & 0xfffc) | 0); /* P_guard = 0 */
-		dib8000_write_word(state, 6, 0); /* P_lock0_mask = 0 */
-		dib8000_write_word(state, 7, 0); /* P_lock1_mask = 0 */
-		dib8000_write_word(state, 8, 0); /* P_lock2_mask = 0 */
-		dib8000_write_word(state, 10, (dib8000_read_word(state, 10) & 0x200) | (16 << 4) | (0 << 0)); /* P_search_list=16, P_search_maxtrial=0 */
-
-		if (state->revision == 0x8090)
-			value = dib8000_wait_lock(state, internal, 10, 10, 10); /* time in ms configure P_search_end0 P_search_end1 P_search_end2 */
-		else
-			value = dib8000_wait_lock(state, internal, 20, 20, 20); /* time in ms configure P_search_end0 P_search_end1 P_search_end2 */
-
-		dib8000_write_word(state, 17, 0);
-		dib8000_write_word(state, 18, 200); /* P_search_rstst = 200 */
-		dib8000_write_word(state, 19, 0);
-		dib8000_write_word(state, 20, 400); /* P_search_rstend = 400 */
-		dib8000_write_word(state, 21, (value >> 16) & 0xffff); /* P_search_checkst */
-		dib8000_write_word(state, 22, value & 0xffff);
-
-		if (state->revision == 0x8090)
-			dib8000_write_word(state, 32, (dib8000_read_word(state, 32) & 0xf0ff) | (0 << 8)); /* P_corm_alpha = 0 */
-		else
-			dib8000_write_word(state, 32, (dib8000_read_word(state, 32) & 0xf0ff) | (9 << 8)); /* P_corm_alpha = 3 */
-		dib8000_write_word(state, 355, 2); /* P_search_param_max = 2 */
-
-		/* P_search_param_select = (1 | 1<<4 | 1 << 8) */
-		dib8000_write_word(state, 356, 0);
-		dib8000_write_word(state, 357, 0x111);
-
-		dib8000_write_word(state, 770, (dib8000_read_word(state, 770) & 0xdfff) | (1 << 13)); /* P_restart_ccg = 1 */
-		dib8000_write_word(state, 770, (dib8000_read_word(state, 770) & 0xdfff) | (0 << 13)); /* P_restart_ccg = 0 */
-		dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x7ff) | (0 << 15) | (1 << 13)); /* P_restart_search = 0; */
-	} else if ((state->revision >= 0x8002) &&
-		   (state->autosearch_state == AS_SEARCHING_GUARD)) {
-		c->transmission_mode = TRANSMISSION_MODE_8K;
-		c->guard_interval = GUARD_INTERVAL_1_8;
-		c->inversion = 0;
-		c->layer[0].modulation = QAM_64;
-		c->layer[0].fec = FEC_2_3;
-		c->layer[0].interleaving = 0;
-		c->layer[0].segment_count = 13;
-
-		slist = 16;
-		c->transmission_mode = state->found_nfft;
-
-		dib8000_set_isdbt_common_channel(state, slist, 1);
-
-		/* set lock_mask values */
-		dib8000_write_word(state, 6, 0x4);
-		if (state->revision == 0x8090)
-			dib8000_write_word(state, 7, ((1 << 12) | (1 << 11) | (1 << 10)));/* tmcc_dec_lock, tmcc_sync_lock, tmcc_data_lock, tmcc_bch_uncor */
-		else
-			dib8000_write_word(state, 7, 0x8);
-		dib8000_write_word(state, 8, 0x1000);
-
-		/* set lock_mask wait time values */
-		if (state->revision == 0x8090)
-			dib8000_wait_lock(state, internal, 50, 100, 1000); /* time in ms configure P_search_end0 P_search_end1 P_search_end2 */
-		else
-			dib8000_wait_lock(state, internal, 50, 200, 1000); /* time in ms configure P_search_end0 P_search_end1 P_search_end2 */
-
-		dib8000_write_word(state, 355, 3); /* P_search_param_max = 3 */
 
-		/* P_search_param_select = 0xf; look for the 4 different guard intervals */
-		dib8000_write_word(state, 356, 0);
-		dib8000_write_word(state, 357, 0xf);
-
-		value = dib8000_read_word(state, 0);
-		dib8000_write_word(state, 0, (u16)((1 << 15) | value));
-		dib8000_read_word(state, 1284);  /* reset the INT. n_irq_pending */
-		dib8000_write_word(state, 0, (u16)value);
+	int slist = 0;
+
+	state->fe[0]->dtv_property_cache.inversion = 0;
+	if (!state->fe[0]->dtv_property_cache.isdbt_sb_mode)
+		state->fe[0]->dtv_property_cache.layer[0].segment_count = 13;
+	state->fe[0]->dtv_property_cache.layer[0].modulation = QAM_64;
+	state->fe[0]->dtv_property_cache.layer[0].fec = FEC_2_3;
+	state->fe[0]->dtv_property_cache.layer[0].interleaving = 0;
+
+	//choose the right list, in sb, always do everything
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode) {
+		state->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;
+		state->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;
+		slist = 7;
+		dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));
 	} else {
-		c->inversion = 0;
-		c->layer[0].modulation = QAM_64;
-		c->layer[0].fec = FEC_2_3;
-		c->layer[0].interleaving = 0;
-		c->layer[0].segment_count = 13;
-		if (!c->isdbt_sb_mode)
-			c->layer[0].segment_count = 13;
-
-		/* choose the right list, in sb, always do everything */
-		if (c->isdbt_sb_mode) {
-			slist = 7;
-			dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));
+		if (state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO) {
+			if (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) {
+				slist = 7;
+				dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));	// P_mode = 1 to have autosearch start ok with mode2
+			} else
+				slist = 3;
 		} else {
-			if (c->guard_interval == GUARD_INTERVAL_AUTO) {
-				if (c->transmission_mode == TRANSMISSION_MODE_AUTO) {
-					c->transmission_mode = TRANSMISSION_MODE_8K;
-					c->guard_interval = GUARD_INTERVAL_1_8;
-					slist = 7;
-					dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));  /* P_mode = 1 to have autosearch start ok with mode2 */
-				} else {
-					c->guard_interval = GUARD_INTERVAL_1_8;
-					slist = 3;
-				}
-			} else {
-				if (c->transmission_mode == TRANSMISSION_MODE_AUTO) {
-					c->transmission_mode = TRANSMISSION_MODE_8K;
-					slist = 2;
-					dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));  /* P_mode = 1 */
-				} else
-					slist = 0;
-			}
+			if (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) {
+				slist = 2;
+				dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));	// P_mode = 1
+			} else
+				slist = 0;
 		}
-		dprintk("Using list for autosearch : %d", slist);
 
-		dib8000_set_isdbt_common_channel(state, slist, 1);
+		if (state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO)
+			state->fe[0]->dtv_property_cache.transmission_mode = TRANSMISSION_MODE_8K;
+		if (state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO)
+			state->fe[0]->dtv_property_cache.guard_interval = GUARD_INTERVAL_1_8;
+
+		dprintk("using list for autosearch : %d", slist);
+		dib8000_set_channel(state, (unsigned char)slist, 1);
+		//dib8000_write_word(state, 0, (dib8000_read_word(state, 0) & 0x9fff) | (1 << 13));  // P_mode = 1
+
+		factor = 1;
 
-		/* set lock_mask values */
+		//set lock_mask values
 		dib8000_write_word(state, 6, 0x4);
-		if (state->revision == 0x8090)
-			dib8000_write_word(state, 7, (1 << 12) | (1 << 11) | (1 << 10));
-		else
-			dib8000_write_word(state, 7, 0x8);
+		dib8000_write_word(state, 7, 0x8);
 		dib8000_write_word(state, 8, 0x1000);
 
-		/* set lock_mask wait time values */
-		if (state->revision == 0x8090)
-			dib8000_wait_lock(state, internal, 50, 200, 1000); /* time in ms configure P_search_end0 P_search_end1 P_search_end2 */
-		else
-			dib8000_wait_lock(state, internal, 50, 100, 1000); /* time in ms configure P_search_end0 P_search_end1 P_search_end2 */
+		//set lock_mask wait time values
+		value = 50 * state->cfg.pll->internal * factor;
+		dib8000_write_word(state, 11, (u16) ((value >> 16) & 0xffff));	// lock0 wait time
+		dib8000_write_word(state, 12, (u16) (value & 0xffff));	// lock0 wait time
+		value = 100 * state->cfg.pll->internal * factor;
+		dib8000_write_word(state, 13, (u16) ((value >> 16) & 0xffff));	// lock1 wait time
+		dib8000_write_word(state, 14, (u16) (value & 0xffff));	// lock1 wait time
+		value = 1000 * state->cfg.pll->internal * factor;
+		dib8000_write_word(state, 15, (u16) ((value >> 16) & 0xffff));	// lock2 wait time
+		dib8000_write_word(state, 16, (u16) (value & 0xffff));	// lock2 wait time
 
 		value = dib8000_read_word(state, 0);
-		dib8000_write_word(state, 0, (u16)((1 << 15) | value));
-		dib8000_read_word(state, 1284);  /* reset the INT. n_irq_pending */
-		dib8000_write_word(state, 0, (u16)value);
+		dib8000_write_word(state, 0, (u16) ((1 << 15) | value));
+		dib8000_read_word(state, 1284);	// reset the INT. n_irq_pending
+		dib8000_write_word(state, 0, (u16) value);
+
 	}
+
 	return 0;
 }
 
@@ -2602,636 +2663,96 @@ static int dib8000_autosearch_irq(struct dvb_frontend *fe)
 	struct dib8000_state *state = fe->demodulator_priv;
 	u16 irq_pending = dib8000_read_word(state, 1284);
 
-	if ((state->revision >= 0x8002) &&
-	    (state->autosearch_state == AS_SEARCHING_FFT)) {
-		if (irq_pending & 0x1) {
-			dprintk("dib8000_autosearch_irq: max correlation result available");
-			return 3;
-		}
-	} else {
-		if (irq_pending & 0x1) {	/* failed */
-			dprintk("dib8000_autosearch_irq failed");
-			return 1;
-		}
+	if (irq_pending & 0x1) {	// failed
+		dprintk("dib8000_autosearch_irq failed");
+		return 1;
+	}
 
-		if (irq_pending & 0x2) {	/* succeeded */
-			dprintk("dib8000_autosearch_irq succeeded");
-			return 2;
-		}
+	if (irq_pending & 0x2) {	// succeeded
+		dprintk("dib8000_autosearch_irq succeeded");
+		return 2;
 	}
 
 	return 0;		// still pending
 }
 
-static void dib8000_viterbi_state(struct dib8000_state *state, u8 onoff)
-{
-	u16 tmp;
-
-	tmp = dib8000_read_word(state, 771);
-	if (onoff) /* start P_restart_chd : channel_decoder */
-		dib8000_write_word(state, 771, tmp & 0xfffd);
-	else /* stop P_restart_chd : channel_decoder */
-		dib8000_write_word(state, 771, tmp | (1<<1));
-}
-
-static void dib8000_set_dds(struct dib8000_state *state, s32 offset_khz)
+static int dib8000_tune(struct dvb_frontend *fe)
 {
-	s16 unit_khz_dds_val;
-	u32 abs_offset_khz = ABS(offset_khz);
-	u32 dds = state->cfg.pll->ifreq & 0x1ffffff;
-	u8 invert = !!(state->cfg.pll->ifreq & (1 << 25));
-	u8 ratio;
+	struct dib8000_state *state = fe->demodulator_priv;
+	int ret = 0;
+	u16 lock, value, mode;
 
-	if (state->revision == 0x8090) {
-		ratio = 4;
-		unit_khz_dds_val = (1<<26) / (dib8000_read32(state, 23) / 1000);
-		if (offset_khz < 0)
-			dds = (1 << 26) - (abs_offset_khz * unit_khz_dds_val);
-		else
-			dds = (abs_offset_khz * unit_khz_dds_val);
+	// we are already tuned - just resuming from suspend
+	if (state == NULL)
+		return -EINVAL;
 
-		if (invert)
-			dds = (1<<26) - dds;
-	} else {
-		ratio = 2;
-		unit_khz_dds_val = (u16) (67108864 / state->cfg.pll->internal);
+	mode = fft_to_mode(state);
 
-		if (offset_khz < 0)
-			unit_khz_dds_val *= -1;
+	dib8000_set_bandwidth(fe, state->fe[0]->dtv_property_cache.bandwidth_hz / 1000);
+	dib8000_set_channel(state, 0, 0);
 
-		/* IF tuner */
-		if (invert)
-			dds -= abs_offset_khz * unit_khz_dds_val;
-		else
-			dds += abs_offset_khz * unit_khz_dds_val;
-	}
+	// restart demod
+	ret |= dib8000_write_word(state, 770, 0x4000);
+	ret |= dib8000_write_word(state, 770, 0x0000);
+	msleep(45);
 
-	dprintk("setting a DDS frequency offset of %c%dkHz", invert ? '-' : ' ', dds / unit_khz_dds_val);
+	/* P_ctrl_inh_cor=0, P_ctrl_alpha_cor=4, P_ctrl_inh_isi=0, P_ctrl_alpha_isi=3 */
+	/*  ret |= dib8000_write_word(state, 29, (0 << 9) | (4 << 5) | (0 << 4) | (3 << 0) );  workaround inh_isi stays at 1 */
 
-	if (abs_offset_khz <= (state->cfg.pll->internal / ratio)) {
-		/* Max dds offset is the half of the demod freq */
-		dib8000_write_word(state, 26, invert);
-		dib8000_write_word(state, 27, (u16)(dds >> 16) & 0x1ff);
-		dib8000_write_word(state, 28, (u16)(dds & 0xffff));
+	// never achieved a lock before - wait for timfreq to update
+	if (state->timf == 0) {
+		if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
+			if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0)
+				msleep(300);
+			else	// Sound Broadcasting mode 3 seg
+				msleep(500);
+		} else		// 13 seg
+			msleep(200);
 	}
-}
+	if (state->fe[0]->dtv_property_cache.isdbt_sb_mode == 1) {
+		if (state->fe[0]->dtv_property_cache.isdbt_partial_reception == 0) {
 
-static void dib8000_set_frequency_offset(struct dib8000_state *state)
-{
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	int i;
-	u32 current_rf;
-	int total_dds_offset_khz;
+			/* P_timf_alpha = (13-P_mode) , P_corm_alpha=6, P_corm_thres=0x40  alpha to check on board */
+			dib8000_write_word(state, 32, ((13 - mode) << 12) | (6 << 8) | 0x40);
+			//dib8000_write_word(state, 32, (8 << 12) | (6 << 8) | 0x80);
 
-	if (state->fe[0]->ops.tuner_ops.get_frequency)
-		state->fe[0]->ops.tuner_ops.get_frequency(state->fe[0], &current_rf);
-	else
-		current_rf = c->frequency;
-	current_rf /= 1000;
-	total_dds_offset_khz = (int)current_rf - (int)c->frequency / 1000;
+			/*  P_ctrl_sfreq_step= (12-P_mode)   P_ctrl_sfreq_inh =0     P_ctrl_pha_off_max  */
+			ret |= dib8000_write_word(state, 37, (12 - mode) | ((5 + mode) << 5));
 
-	if (c->isdbt_sb_mode) {
-		state->subchannel = c->isdbt_sb_subchannel;
+		} else {	// Sound Broadcasting mode 3 seg
 
-		i = dib8000_read_word(state, 26) & 1; /* P_dds_invspec */
-		dib8000_write_word(state, 26, c->inversion ^ i);
+			/* P_timf_alpha = (12-P_mode) , P_corm_alpha=6, P_corm_thres=0x60  alpha to check on board */
+			dib8000_write_word(state, 32, ((12 - mode) << 12) | (6 << 8) | 0x60);
 
-		if (state->cfg.pll->ifreq == 0) { /* low if tuner */
-			if ((c->inversion ^ i) == 0)
-				dib8000_write_word(state, 26, dib8000_read_word(state, 26) | 1);
-		} else {
-			if ((c->inversion ^ i) == 0)
-				total_dds_offset_khz *= -1;
+			ret |= dib8000_write_word(state, 37, (11 - mode) | ((5 + mode) << 5));
 		}
-	}
-
-	dprintk("%dkhz tuner offset (frequency = %dHz & current_rf = %dHz) total_dds_offset_hz = %d", c->frequency - current_rf, c->frequency, current_rf, total_dds_offset_khz);
-
-	/* apply dds offset now */
-	dib8000_set_dds(state, total_dds_offset_khz);
-}
 
-static u16 LUT_isdbt_symbol_duration[4] = { 26, 101, 63 };
+	} else {		// 13 seg
+		/* P_timf_alpha = 8 , P_corm_alpha=6, P_corm_thres=0x80  alpha to check on board */
+		dib8000_write_word(state, 32, ((11 - mode) << 12) | (6 << 8) | 0x80);
 
-static u32 dib8000_get_symbol_duration(struct dib8000_state *state)
-{
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	u16 i;
+		ret |= dib8000_write_word(state, 37, (10 - mode) | ((5 + mode) << 5));
 
-	switch (c->transmission_mode) {
-	case TRANSMISSION_MODE_2K:
-			i = 0;
-			break;
-	case TRANSMISSION_MODE_4K:
-			i = 2;
-			break;
-	default:
-	case TRANSMISSION_MODE_AUTO:
-	case TRANSMISSION_MODE_8K:
-			i = 1;
-			break;
-	}
-
-	return (LUT_isdbt_symbol_duration[i] / (c->bandwidth_hz / 1000)) + 1;
-}
-
-static void dib8000_set_isdbt_loop_params(struct dib8000_state *state, enum param_loop_step loop_step)
-{
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	u16 reg_32 = 0, reg_37 = 0;
-
-	switch (loop_step) {
-	case LOOP_TUNE_1:
-			if (c->isdbt_sb_mode)  {
-				if (c->isdbt_partial_reception == 0) {
-					reg_32 = ((11 - state->mode) << 12) | (6 << 8) | 0x40; /* P_timf_alpha = (11-P_mode), P_corm_alpha=6, P_corm_thres=0x40 */
-					reg_37 = (3 << 5) | (0 << 4) | (10 - state->mode); /* P_ctrl_pha_off_max=3   P_ctrl_sfreq_inh =0  P_ctrl_sfreq_step = (10-P_mode)  */
-				} else { /* Sound Broadcasting mode 3 seg */
-					reg_32 = ((10 - state->mode) << 12) | (6 << 8) | 0x60; /* P_timf_alpha = (10-P_mode), P_corm_alpha=6, P_corm_thres=0x60 */
-					reg_37 = (3 << 5) | (0 << 4) | (9 - state->mode); /* P_ctrl_pha_off_max=3   P_ctrl_sfreq_inh =0  P_ctrl_sfreq_step = (9-P_mode)  */
-				}
-			} else { /* 13-seg start conf offset loop parameters */
-				reg_32 = ((9 - state->mode) << 12) | (6 << 8) | 0x80; /* P_timf_alpha = (9-P_mode, P_corm_alpha=6, P_corm_thres=0x80 */
-				reg_37 = (3 << 5) | (0 << 4) | (8 - state->mode); /* P_ctrl_pha_off_max=3   P_ctrl_sfreq_inh =0  P_ctrl_sfreq_step = 9  */
-			}
-			break;
-	case LOOP_TUNE_2:
-			if (c->isdbt_sb_mode)  {
-				if (c->isdbt_partial_reception == 0) {  /* Sound Broadcasting mode 1 seg */
-					reg_32 = ((13-state->mode) << 12) | (6 << 8) | 0x40; /* P_timf_alpha = (13-P_mode) , P_corm_alpha=6, P_corm_thres=0x40*/
-					reg_37 = (12-state->mode) | ((5 + state->mode) << 5);
-				} else {  /* Sound Broadcasting mode 3 seg */
-					reg_32 = ((12-state->mode) << 12) | (6 << 8) | 0x60; /* P_timf_alpha = (12-P_mode) , P_corm_alpha=6, P_corm_thres=0x60 */
-					reg_37 = (11-state->mode) | ((5 + state->mode) << 5);
-				}
-			} else {  /* 13 seg */
-				reg_32 = ((11-state->mode) << 12) | (6 << 8) | 0x80; /* P_timf_alpha = 8 , P_corm_alpha=6, P_corm_thres=0x80 */
-				reg_37 = ((5+state->mode) << 5) | (10 - state->mode);
-			}
-			break;
-	}
-	dib8000_write_word(state, 32, reg_32);
-	dib8000_write_word(state, 37, reg_37);
-}
-
-static void dib8000_demod_restart(struct dib8000_state *state)
-{
-	dib8000_write_word(state, 770, 0x4000);
-	dib8000_write_word(state, 770, 0x0000);
-	return;
-}
-
-static void dib8000_set_sync_wait(struct dib8000_state *state)
-{
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	u16 sync_wait = 64;
-
-	/* P_dvsy_sync_wait - reuse mode */
-	switch (c->transmission_mode) {
-	case TRANSMISSION_MODE_8K:
-			sync_wait = 256;
-			break;
-	case TRANSMISSION_MODE_4K:
-			sync_wait = 128;
-			break;
-	default:
-	case TRANSMISSION_MODE_2K:
-			sync_wait =  64;
-			break;
 	}
 
-	if (state->cfg.diversity_delay == 0)
-		sync_wait = (sync_wait * (1 << (c->guard_interval)) * 3) / 2 + 48; /* add 50% SFN margin + compensate for one DVSY-fifo */
-	else
-		sync_wait = (sync_wait * (1 << (c->guard_interval)) * 3) / 2 + state->cfg.diversity_delay; /* add 50% SFN margin + compensate for DVSY-fifo */
-
-	dib8000_write_word(state, 273, (dib8000_read_word(state, 273) & 0x000f) | (sync_wait << 4));
-}
-
-static u32 dib8000_get_timeout(struct dib8000_state *state, u32 delay, enum timeout_mode mode)
-{
-	if (mode == SYMBOL_DEPENDENT_ON)
-		return systime() + (delay * state->symbol_duration);
+	// we achieved a coff_cpil_lock - it's time to update the timf
+	if (state->revision != 0x8090)
+		lock = dib8000_read_word(state, 568);
 	else
-		return systime() + delay;
-}
-
-static s32 dib8000_get_status(struct dvb_frontend *fe)
-{
-	struct dib8000_state *state = fe->demodulator_priv;
-	return state->status;
-}
-
-enum frontend_tune_state dib8000_get_tune_state(struct dvb_frontend *fe)
-{
-	struct dib8000_state *state = fe->demodulator_priv;
-	return state->tune_state;
-}
-EXPORT_SYMBOL(dib8000_get_tune_state);
-
-int dib8000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)
-{
-	struct dib8000_state *state = fe->demodulator_priv;
-
-	state->tune_state = tune_state;
-	return 0;
-}
-EXPORT_SYMBOL(dib8000_set_tune_state);
-
-static int dib8000_tune_restart_from_demod(struct dvb_frontend *fe)
-{
-	struct dib8000_state *state = fe->demodulator_priv;
-
-	state->status = FE_STATUS_TUNE_PENDING;
-	state->tune_state = CT_DEMOD_START;
-	return 0;
-}
-
-static u16 dib8000_read_lock(struct dvb_frontend *fe)
-{
-	struct dib8000_state *state = fe->demodulator_priv;
-
-	if (state->revision == 0x8090)
-		return dib8000_read_word(state, 570);
-	return dib8000_read_word(state, 568);
-}
-
-static int dib8090p_init_sdram(struct dib8000_state *state)
-{
-	u16 reg = 0;
-	dprintk("init sdram");
-
-	reg = dib8000_read_word(state, 274) & 0xfff0;
-	dib8000_write_word(state, 274, reg | 0x7); /* P_dintlv_delay_ram = 7 because of MobileSdram */
-
-	dib8000_write_word(state, 1803, (7 << 2));
-
-	reg = dib8000_read_word(state, 1280);
-	dib8000_write_word(state, 1280,  reg | (1 << 2)); /* force restart P_restart_sdram */
-	dib8000_write_word(state, 1280,  reg); /* release restart P_restart_sdram */
-
-	return 0;
-}
-
-static int dib8000_tune(struct dvb_frontend *fe)
-{
-	struct dib8000_state *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	enum frontend_tune_state *tune_state = &state->tune_state;
-
-	u16 locks, deeper_interleaver = 0, i;
-	int ret = 1; /* 1 symbol duration (in 100us unit) delay most of the time */
-
-	u32 *timeout = &state->timeout;
-	u32 now = systime();
-#ifdef DIB8000_AGC_FREEZE
-	u16 agc1, agc2;
-#endif
-
-	u32 corm[4] = {0, 0, 0, 0};
-	u8 find_index, max_value;
-
-#if 0
-	if (*tune_state < CT_DEMOD_STOP)
-		dprintk("IN: context status = %d, TUNE_STATE %d autosearch step = %u systime = %u", state->channel_parameters_set, *tune_state, state->autosearch_state, now);
-#endif
-
-	switch (*tune_state) {
-	case CT_DEMOD_START: /* 30 */
-			if (state->revision == 0x8090)
-				dib8090p_init_sdram(state);
-			state->status = FE_STATUS_TUNE_PENDING;
-			if ((c->delivery_system != SYS_ISDBT) ||
-					(c->inversion == INVERSION_AUTO) ||
-					(c->transmission_mode == TRANSMISSION_MODE_AUTO) ||
-					(c->guard_interval == GUARD_INTERVAL_AUTO) ||
-					(((c->isdbt_layer_enabled & (1 << 0)) != 0) &&
-					 (c->layer[0].segment_count != 0xff) &&
-					 (c->layer[0].segment_count != 0) &&
-					 ((c->layer[0].modulation == QAM_AUTO) ||
-					  (c->layer[0].fec == FEC_AUTO))) ||
-					(((c->isdbt_layer_enabled & (1 << 1)) != 0) &&
-					 (c->layer[1].segment_count != 0xff) &&
-					 (c->layer[1].segment_count != 0) &&
-					 ((c->layer[1].modulation == QAM_AUTO) ||
-					  (c->layer[1].fec == FEC_AUTO))) ||
-					(((c->isdbt_layer_enabled & (1 << 2)) != 0) &&
-					 (c->layer[2].segment_count != 0xff) &&
-					 (c->layer[2].segment_count != 0) &&
-					 ((c->layer[2].modulation == QAM_AUTO) ||
-					  (c->layer[2].fec == FEC_AUTO))) ||
-					(((c->layer[0].segment_count == 0) ||
-					  ((c->isdbt_layer_enabled & (1 << 0)) == 0)) &&
-					 ((c->layer[1].segment_count == 0) ||
-					  ((c->isdbt_layer_enabled & (2 << 0)) == 0)) &&
-					 ((c->layer[2].segment_count == 0) || ((c->isdbt_layer_enabled & (3 << 0)) == 0))))
-				state->channel_parameters_set = 0; /* auto search */
-			else
-				state->channel_parameters_set = 1; /* channel parameters are known */
-
-			dib8000_viterbi_state(state, 0); /* force chan dec in restart */
-
-			/* Layer monit */
-			dib8000_write_word(state, 285, dib8000_read_word(state, 285) & 0x60);
-
-			dib8000_set_frequency_offset(state);
-			dib8000_set_bandwidth(fe, c->bandwidth_hz / 1000);
-
-			if (state->channel_parameters_set == 0) { /* The channel struct is unknown, search it ! */
-#ifdef DIB8000_AGC_FREEZE
-				if (state->revision != 0x8090) {
-					state->agc1_max = dib8000_read_word(state, 108);
-					state->agc1_min = dib8000_read_word(state, 109);
-					state->agc2_max = dib8000_read_word(state, 110);
-					state->agc2_min = dib8000_read_word(state, 111);
-					agc1 = dib8000_read_word(state, 388);
-					agc2 = dib8000_read_word(state, 389);
-					dib8000_write_word(state, 108, agc1);
-					dib8000_write_word(state, 109, agc1);
-					dib8000_write_word(state, 110, agc2);
-					dib8000_write_word(state, 111, agc2);
-				}
-#endif
-				state->autosearch_state = AS_SEARCHING_FFT;
-				state->found_nfft = TRANSMISSION_MODE_AUTO;
-				state->found_guard = GUARD_INTERVAL_AUTO;
-				*tune_state = CT_DEMOD_SEARCH_NEXT;
-			} else { /* we already know the channel struct so TUNE only ! */
-				state->autosearch_state = AS_DONE;
-				*tune_state = CT_DEMOD_STEP_3;
-			}
-			state->symbol_duration = dib8000_get_symbol_duration(state);
-			break;
-
-	case CT_DEMOD_SEARCH_NEXT: /* 51 */
-			dib8000_autosearch_start(fe);
-			if (state->revision == 0x8090)
-				ret = 50;
-			else
-				ret = 15;
-			*tune_state = CT_DEMOD_STEP_1;
-			break;
-
-	case CT_DEMOD_STEP_1: /* 31 */
-			switch (dib8000_autosearch_irq(fe)) {
-			case 1: /* fail */
-					state->status = FE_STATUS_TUNE_FAILED;
-					state->autosearch_state = AS_DONE;
-					*tune_state = CT_DEMOD_STOP; /* else we are done here */
-					break;
-			case 2: /* Succes */
-					state->status = FE_STATUS_FFT_SUCCESS; /* signal to the upper layer, that there was a channel found and the parameters can be read */
-					*tune_state = CT_DEMOD_STEP_3;
-					if (state->autosearch_state == AS_SEARCHING_GUARD)
-						*tune_state = CT_DEMOD_STEP_2;
-					else
-						state->autosearch_state = AS_DONE;
-					break;
-			case 3: /* Autosearch FFT max correlation endded */
-					*tune_state = CT_DEMOD_STEP_2;
-					break;
-			}
-			break;
-
-	case CT_DEMOD_STEP_2:
-			switch (state->autosearch_state) {
-			case AS_SEARCHING_FFT:
-					/* searching for the correct FFT */
-				if (state->revision == 0x8090) {
-					corm[2] = (dib8000_read_word(state, 596) << 16) | (dib8000_read_word(state, 597));
-					corm[1] = (dib8000_read_word(state, 598) << 16) | (dib8000_read_word(state, 599));
-					corm[0] = (dib8000_read_word(state, 600) << 16) | (dib8000_read_word(state, 601));
-				} else {
-					corm[2] = (dib8000_read_word(state, 594) << 16) | (dib8000_read_word(state, 595));
-					corm[1] = (dib8000_read_word(state, 596) << 16) | (dib8000_read_word(state, 597));
-					corm[0] = (dib8000_read_word(state, 598) << 16) | (dib8000_read_word(state, 599));
-				}
-					/* dprintk("corm fft: %u %u %u", corm[0], corm[1], corm[2]); */
-
-					max_value = 0;
-					for (find_index = 1 ; find_index < 3 ; find_index++) {
-						if (corm[max_value] < corm[find_index])
-							max_value = find_index ;
-					}
-
-					switch (max_value) {
-					case 0:
-							state->found_nfft = TRANSMISSION_MODE_2K;
-							break;
-					case 1:
-							state->found_nfft = TRANSMISSION_MODE_4K;
-							break;
-					case 2:
-					default:
-							state->found_nfft = TRANSMISSION_MODE_8K;
-							break;
-					}
-					/* dprintk("Autosearch FFT has found Mode %d", max_value + 1); */
-
-					*tune_state = CT_DEMOD_SEARCH_NEXT;
-					state->autosearch_state = AS_SEARCHING_GUARD;
-					if (state->revision == 0x8090)
-						ret = 50;
-					else
-						ret = 10;
-					break;
-			case AS_SEARCHING_GUARD:
-					/* searching for the correct guard interval */
-					if (state->revision == 0x8090)
-						state->found_guard = dib8000_read_word(state, 572) & 0x3;
-					else
-						state->found_guard = dib8000_read_word(state, 570) & 0x3;
-					/* dprintk("guard interval found=%i", state->found_guard); */
-
-					*tune_state = CT_DEMOD_STEP_3;
-					break;
-			default:
-					/* the demod should never be in this state */
-					state->status = FE_STATUS_TUNE_FAILED;
-					state->autosearch_state = AS_DONE;
-					*tune_state = CT_DEMOD_STOP; /* else we are done here */
-					break;
-			}
-			break;
-
-	case CT_DEMOD_STEP_3: /* 33 */
-			state->symbol_duration = dib8000_get_symbol_duration(state);
-			dib8000_set_isdbt_loop_params(state, LOOP_TUNE_1);
-			dib8000_set_isdbt_common_channel(state, 0, 0);/* setting the known channel parameters here */
-			*tune_state = CT_DEMOD_STEP_4;
-			break;
-
-	case CT_DEMOD_STEP_4: /* (34) */
-			dib8000_demod_restart(state);
-
-			dib8000_set_sync_wait(state);
-			dib8000_set_diversity_in(state->fe[0], state->diversity_onoff);
-
-			locks = (dib8000_read_word(state, 180) >> 6) & 0x3f; /* P_coff_winlen ? */
-			/* coff should lock over P_coff_winlen ofdm symbols : give 3 times this lenght to lock */
-			*timeout = dib8000_get_timeout(state, 2 * locks, SYMBOL_DEPENDENT_ON);
-			*tune_state = CT_DEMOD_STEP_5;
-			break;
-
-	case CT_DEMOD_STEP_5: /* (35) */
-			locks = dib8000_read_lock(fe);
-			if (locks & (0x3 << 11)) { /* coff-lock and off_cpil_lock achieved */
-				dib8000_update_timf(state); /* we achieved a coff_cpil_lock - it's time to update the timf */
-				if (!state->differential_constellation) {
-					/* 2 times lmod4_win_len + 10 symbols (pipe delay after coff + nb to compute a 1st correlation) */
-					*timeout = dib8000_get_timeout(state, (20 * ((dib8000_read_word(state, 188)>>5)&0x1f)), SYMBOL_DEPENDENT_ON);
-					*tune_state = CT_DEMOD_STEP_7;
-				} else {
-					*tune_state = CT_DEMOD_STEP_8;
-				}
-			} else if (now > *timeout) {
-				*tune_state = CT_DEMOD_STEP_6; /* goto check for diversity input connection */
-			}
-			break;
-
-	case CT_DEMOD_STEP_6: /* (36)  if there is an input (diversity) */
-			if ((state->fe[1] != NULL) && (state->output_mode != OUTMODE_DIVERSITY)) {
-				/* if there is a diversity fe in input and this fe is has not already failled : wait here until this this fe has succedeed or failled */
-				if (dib8000_get_status(state->fe[1]) <= FE_STATUS_STD_SUCCESS) /* Something is locked on the input fe */
-					*tune_state = CT_DEMOD_STEP_8; /* go for mpeg */
-				else if (dib8000_get_status(state->fe[1]) >= FE_STATUS_TUNE_TIME_TOO_SHORT) { /* fe in input failled also, break the current one */
-					*tune_state = CT_DEMOD_STOP; /* else we are done here ; step 8 will close the loops and exit */
-					dib8000_viterbi_state(state, 1); /* start viterbi chandec */
-					dib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);
-					state->status = FE_STATUS_TUNE_FAILED;
-				}
-			} else {
-				dib8000_viterbi_state(state, 1); /* start viterbi chandec */
-				dib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);
-				*tune_state = CT_DEMOD_STOP; /* else we are done here ; step 8 will close the loops and exit */
-				state->status = FE_STATUS_TUNE_FAILED;
-			}
-			break;
-
-	case CT_DEMOD_STEP_7: /* 37 */
-			locks = dib8000_read_lock(fe);
-			if (locks & (1<<10)) { /* lmod4_lock */
-				ret = 14; /* wait for 14 symbols */
-				*tune_state = CT_DEMOD_STEP_8;
-			} else if (now > *timeout)
-				*tune_state = CT_DEMOD_STEP_6; /* goto check for diversity input connection */
-			break;
-
-	case CT_DEMOD_STEP_8: /* 38 */
-			dib8000_viterbi_state(state, 1); /* start viterbi chandec */
-			dib8000_set_isdbt_loop_params(state, LOOP_TUNE_2);
-
-			/* mpeg will never lock on this condition because init_prbs is not set : search for it !*/
-			if (c->isdbt_sb_mode
-			    && c->isdbt_sb_subchannel < 14
-			    && !state->differential_constellation) {
-				state->subchannel = 0;
-				*tune_state = CT_DEMOD_STEP_11;
-			} else {
-				*tune_state = CT_DEMOD_STEP_9;
-				state->status = FE_STATUS_LOCKED;
-			}
-			break;
-
-	case CT_DEMOD_STEP_9: /* 39 */
-			if ((state->revision == 0x8090) || ((dib8000_read_word(state, 1291) >> 9) & 0x1)) { /* fe capable of deinterleaving : esram */
-				/* defines timeout for mpeg lock depending on interleaver lenght of longest layer */
-				for (i = 0; i < 3; i++) {
-					if (c->layer[i].interleaving >= deeper_interleaver) {
-						dprintk("layer%i: time interleaver = %d ", i, c->layer[i].interleaving);
-						if (c->layer[i].segment_count > 0) { /* valid layer */
-							deeper_interleaver = c->layer[0].interleaving;
-							state->longest_intlv_layer = i;
-						}
-					}
-				}
-
-				if (deeper_interleaver == 0)
-					locks = 2; /* locks is the tmp local variable name */
-				else if (deeper_interleaver == 3)
-					locks = 8;
-				else
-					locks = 2 * deeper_interleaver;
-
-				if (state->diversity_onoff != 0) /* because of diversity sync */
-					locks *= 2;
-
-				*timeout = now + (2000 * locks); /* give the mpeg lock 800ms if sram is present */
-				dprintk("Deeper interleaver mode = %d on layer %d : timeout mult factor = %d => will use timeout = %d", deeper_interleaver, state->longest_intlv_layer, locks, *timeout);
-
-				*tune_state = CT_DEMOD_STEP_10;
-			} else
-				*tune_state = CT_DEMOD_STOP;
-			break;
-
-	case CT_DEMOD_STEP_10: /* 40 */
-			locks = dib8000_read_lock(fe);
-			if (locks&(1<<(7-state->longest_intlv_layer))) { /* mpeg lock : check the longest one */
-				dprintk("Mpeg locks [ L0 : %d | L1 : %d | L2 : %d ]", (locks>>7)&0x1, (locks>>6)&0x1, (locks>>5)&0x1);
-				if (c->isdbt_sb_mode
-				    && c->isdbt_sb_subchannel < 14
-				    && !state->differential_constellation)
-					/* signal to the upper layer, that there was a channel found and the parameters can be read */
-					state->status = FE_STATUS_DEMOD_SUCCESS;
-				else
-					state->status = FE_STATUS_DATA_LOCKED;
-				*tune_state = CT_DEMOD_STOP;
-			} else if (now > *timeout) {
-				if (c->isdbt_sb_mode
-				    && c->isdbt_sb_subchannel < 14
-				    && !state->differential_constellation) { /* continue to try init prbs autosearch */
-					state->subchannel += 3;
-					*tune_state = CT_DEMOD_STEP_11;
-				} else { /* we are done mpeg of the longest interleaver xas not locking but let's try if an other layer has locked in the same time */
-					if (locks & (0x7<<5)) {
-						dprintk("Mpeg locks [ L0 : %d | L1 : %d | L2 : %d ]", (locks>>7)&0x1, (locks>>6)&0x1, (locks>>5)&0x1);
-						state->status = FE_STATUS_DATA_LOCKED;
-					} else
-						state->status = FE_STATUS_TUNE_FAILED;
-					*tune_state = CT_DEMOD_STOP;
-				}
-			}
-			break;
+		lock = dib8000_read_word(state, 570);
+	if ((lock >> 11) & 0x1)
+		dib8000_update_timf(state);
 
-	case CT_DEMOD_STEP_11:  /* 41 : init prbs autosearch */
-			if (state->subchannel <= 41) {
-				dib8000_set_subchannel_prbs(state, dib8000_get_init_prbs(state, state->subchannel));
-				*tune_state = CT_DEMOD_STEP_9;
-			} else {
-				*tune_state = CT_DEMOD_STOP;
-				state->status = FE_STATUS_TUNE_FAILED;
-			}
-			break;
+	//now that tune is finished, lock0 should lock on fec_mpeg to output this lock on MP_LOCK. It's changed in autosearch start
+	dib8000_write_word(state, 6, 0x200);
 
-	default:
-			break;
-	}
-
-	/* tuning is finished - cleanup the demod */
-	switch (*tune_state) {
-	case CT_DEMOD_STOP: /* (42) */
-#ifdef DIB8000_AGC_FREEZE
-			if ((state->revision != 0x8090) && (state->agc1_max != 0)) {
-				dib8000_write_word(state, 108, state->agc1_max);
-				dib8000_write_word(state, 109, state->agc1_min);
-				dib8000_write_word(state, 110, state->agc2_max);
-				dib8000_write_word(state, 111, state->agc2_min);
-				state->agc1_max = 0;
-				state->agc1_min = 0;
-				state->agc2_max = 0;
-				state->agc2_min = 0;
-			}
-#endif
-			ret = FE_CALLBACK_TIME_NEVER;
-			break;
-	default:
-			break;
+	if (state->revision == 0x8002) {
+		value = dib8000_read_word(state, 903);
+		dib8000_write_word(state, 903, value & ~(1 << 3));
+		msleep(1);
+		dib8000_write_word(state, 903, value | (1 << 3));
 	}
 
-	if ((ret > 0) && (*tune_state > CT_DEMOD_STEP_3))
-		return ret * state->symbol_duration;
-	if ((ret > 0) && (ret < state->symbol_duration))
-		return state->symbol_duration; /* at least one symbol */
 	return ret;
 }
 
@@ -3246,7 +2767,7 @@ static int dib8000_wakeup(struct dvb_frontend *fe)
 	if (dib8000_set_adc_state(state, DIBX000_SLOW_ADC_ON) != 0)
 		dprintk("could not start Slow ADC");
 
-	if (state->revision == 0x8090)
+	if (state->revision != 0x8090)
 		dib8000_sad_calib(state);
 
 	for (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {
@@ -3276,6 +2797,21 @@ static int dib8000_sleep(struct dvb_frontend *fe)
 	return dib8000_set_adc_state(state, DIBX000_SLOW_ADC_OFF) | dib8000_set_adc_state(state, DIBX000_ADC_OFF);
 }
 
+enum frontend_tune_state dib8000_get_tune_state(struct dvb_frontend *fe)
+{
+	struct dib8000_state *state = fe->demodulator_priv;
+	return state->tune_state;
+}
+EXPORT_SYMBOL(dib8000_get_tune_state);
+
+int dib8000_set_tune_state(struct dvb_frontend *fe, enum frontend_tune_state tune_state)
+{
+	struct dib8000_state *state = fe->demodulator_priv;
+	state->tune_state = tune_state;
+	return 0;
+}
+EXPORT_SYMBOL(dib8000_set_tune_state);
+
 static int dib8000_get_frontend(struct dvb_frontend *fe)
 {
 	struct dib8000_state *state = fe->demodulator_priv;
@@ -3425,19 +2961,19 @@ static int dib8000_get_frontend(struct dvb_frontend *fe)
 static int dib8000_set_frontend(struct dvb_frontend *fe)
 {
 	struct dib8000_state *state = fe->demodulator_priv;
-	struct dtv_frontend_properties *c = &state->fe[0]->dtv_property_cache;
-	int l, i, active, time, ret, time_slave = FE_CALLBACK_TIME_NEVER;
-	u8 exit_condition, index_frontend;
-	u32 delay, callback_time;
+	u8 nbr_pending, exit_condition, index_frontend;
+	s8 index_frontend_success = -1;
+	int time, ret;
+	int  time_slave = FE_CALLBACK_TIME_NEVER;
 
-	if (c->frequency == 0) {
+	if (state->fe[0]->dtv_property_cache.frequency == 0) {
 		dprintk("dib8000: must at least specify frequency ");
 		return 0;
 	}
 
-	if (c->bandwidth_hz == 0) {
+	if (state->fe[0]->dtv_property_cache.bandwidth_hz == 0) {
 		dprintk("dib8000: no bandwidth specified, set to default ");
-		c->bandwidth_hz = 6000000;
+		state->fe[0]->dtv_property_cache.bandwidth_hz = 6000000;
 	}
 
 	for (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {
@@ -3445,36 +2981,18 @@ static int dib8000_set_frontend(struct dvb_frontend *fe)
 		state->fe[index_frontend]->dtv_property_cache.delivery_system = SYS_ISDBT;
 		memcpy(&state->fe[index_frontend]->dtv_property_cache, &fe->dtv_property_cache, sizeof(struct dtv_frontend_properties));
 
-		/* set output mode and diversity input */
-		if (state->revision != 0x8090) {
-			dib8000_set_diversity_in(state->fe[index_frontend], 1);
-			if (index_frontend != 0)
-				dib8000_set_output_mode(state->fe[index_frontend],
-						OUTMODE_DIVERSITY);
-			else
-				dib8000_set_output_mode(state->fe[0], OUTMODE_HIGH_Z);
-		} else {
-			dib8096p_set_diversity_in(state->fe[index_frontend], 1);
-			if (index_frontend != 0)
-				dib8096p_set_output_mode(state->fe[index_frontend],
-						OUTMODE_DIVERSITY);
-			else
-				dib8096p_set_output_mode(state->fe[0], OUTMODE_HIGH_Z);
-		}
-
-		/* tune the tuner */
+		if (state->revision != 0x8090)
+			dib8000_set_output_mode(state->fe[index_frontend],
+					OUTMODE_HIGH_Z);
+		else
+			dib8096p_set_output_mode(state->fe[index_frontend],
+					OUTMODE_HIGH_Z);
 		if (state->fe[index_frontend]->ops.tuner_ops.set_params)
 			state->fe[index_frontend]->ops.tuner_ops.set_params(state->fe[index_frontend]);
 
 		dib8000_set_tune_state(state->fe[index_frontend], CT_AGC_START);
 	}
 
-	/* turn off the diversity of the last chip */
-	if (state->revision != 0x8090)
-		dib8000_set_diversity_in(state->fe[index_frontend - 1], 0);
-	else
-		dib8096p_set_diversity_in(state->fe[index_frontend - 1], 0);
-
 	/* start up the AGC */
 	do {
 		time = dib8000_agc_startup(state->fe[0]);
@@ -3501,88 +3019,139 @@ static int dib8000_set_frontend(struct dvb_frontend *fe)
 	for (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)
 		dib8000_set_tune_state(state->fe[index_frontend], CT_DEMOD_START);
 
-	active = 1;
-	do {
-		callback_time = FE_CALLBACK_TIME_NEVER;
+	if ((state->fe[0]->dtv_property_cache.delivery_system != SYS_ISDBT) ||
+			(state->fe[0]->dtv_property_cache.inversion == INVERSION_AUTO) ||
+			(state->fe[0]->dtv_property_cache.transmission_mode == TRANSMISSION_MODE_AUTO) ||
+			(state->fe[0]->dtv_property_cache.guard_interval == GUARD_INTERVAL_AUTO) ||
+			(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 0)) != 0) &&
+			 (state->fe[0]->dtv_property_cache.layer[0].segment_count != 0xff) &&
+			 (state->fe[0]->dtv_property_cache.layer[0].segment_count != 0) &&
+			 ((state->fe[0]->dtv_property_cache.layer[0].modulation == QAM_AUTO) ||
+			  (state->fe[0]->dtv_property_cache.layer[0].fec == FEC_AUTO))) ||
+			(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 1)) != 0) &&
+			 (state->fe[0]->dtv_property_cache.layer[1].segment_count != 0xff) &&
+			 (state->fe[0]->dtv_property_cache.layer[1].segment_count != 0) &&
+			 ((state->fe[0]->dtv_property_cache.layer[1].modulation == QAM_AUTO) ||
+			  (state->fe[0]->dtv_property_cache.layer[1].fec == FEC_AUTO))) ||
+			(((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 2)) != 0) &&
+			 (state->fe[0]->dtv_property_cache.layer[2].segment_count != 0xff) &&
+			 (state->fe[0]->dtv_property_cache.layer[2].segment_count != 0) &&
+			 ((state->fe[0]->dtv_property_cache.layer[2].modulation == QAM_AUTO) ||
+			  (state->fe[0]->dtv_property_cache.layer[2].fec == FEC_AUTO))) ||
+			(((state->fe[0]->dtv_property_cache.layer[0].segment_count == 0) ||
+			  ((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (1 << 0)) == 0)) &&
+			 ((state->fe[0]->dtv_property_cache.layer[1].segment_count == 0) ||
+			  ((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (2 << 0)) == 0)) &&
+			 ((state->fe[0]->dtv_property_cache.layer[2].segment_count == 0) || ((state->fe[0]->dtv_property_cache.isdbt_layer_enabled & (3 << 0)) == 0)))) {
+		int i = 100;
+		u8 found = 0;
+		u8 tune_failed = 0;
+
 		for (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {
-			delay = dib8000_tune(state->fe[index_frontend]);
-			if (delay != FE_CALLBACK_TIME_NEVER)
-				delay += systime();
-
-			/* we are in autosearch */
-			if (state->channel_parameters_set == 0) { /* searching */
-				if ((dib8000_get_status(state->fe[index_frontend]) == FE_STATUS_DEMOD_SUCCESS) || (dib8000_get_status(state->fe[index_frontend]) == FE_STATUS_FFT_SUCCESS)) {
-					dprintk("autosearch succeeded on fe%i", index_frontend);
-					dib8000_get_frontend(state->fe[index_frontend]); /* we read the channel parameters from the frontend which was successful */
-					state->channel_parameters_set = 1;
-
-					for (l = 0; (l < MAX_NUMBER_OF_FRONTENDS) && (state->fe[l] != NULL); l++) {
-						if (l != index_frontend) { /* and for all frontend except the successful one */
-							dib8000_tune_restart_from_demod(state->fe[l]);
-
-							state->fe[l]->dtv_property_cache.isdbt_sb_mode = state->fe[index_frontend]->dtv_property_cache.isdbt_sb_mode;
-							state->fe[l]->dtv_property_cache.inversion = state->fe[index_frontend]->dtv_property_cache.inversion;
-							state->fe[l]->dtv_property_cache.transmission_mode = state->fe[index_frontend]->dtv_property_cache.transmission_mode;
-							state->fe[l]->dtv_property_cache.guard_interval = state->fe[index_frontend]->dtv_property_cache.guard_interval;
-							state->fe[l]->dtv_property_cache.isdbt_partial_reception = state->fe[index_frontend]->dtv_property_cache.isdbt_partial_reception;
-							for (i = 0; i < 3; i++) {
-								state->fe[l]->dtv_property_cache.layer[i].segment_count = state->fe[index_frontend]->dtv_property_cache.layer[i].segment_count;
-								state->fe[l]->dtv_property_cache.layer[i].interleaving = state->fe[index_frontend]->dtv_property_cache.layer[i].interleaving;
-								state->fe[l]->dtv_property_cache.layer[i].fec = state->fe[index_frontend]->dtv_property_cache.layer[i].fec;
-								state->fe[l]->dtv_property_cache.layer[i].modulation = state->fe[index_frontend]->dtv_property_cache.layer[i].modulation;
-							}
-
-						}
-					}
-				}
-			}
-			if (delay < callback_time)
-				callback_time = delay;
+			dib8000_set_bandwidth(state->fe[index_frontend], fe->dtv_property_cache.bandwidth_hz / 1000);
+			dib8000_autosearch_start(state->fe[index_frontend]);
 		}
-		/* tuning is done when the master frontend is done (failed or success) */
-		if (dib8000_get_status(state->fe[0]) == FE_STATUS_TUNE_FAILED ||
-				dib8000_get_status(state->fe[0]) == FE_STATUS_LOCKED ||
-				dib8000_get_status(state->fe[0]) == FE_STATUS_DATA_LOCKED) {
-			active = 0;
-			/* we need to wait for all frontends to be finished */
+
+		do {
+			msleep(20);
+			nbr_pending = 0;
+			exit_condition = 0; /* 0: tune pending; 1: tune failed; 2:tune success */
 			for (index_frontend = 0; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++) {
-				if (dib8000_get_tune_state(state->fe[index_frontend]) != CT_DEMOD_STOP)
-					active = 1;
+				if (((tune_failed >> index_frontend) & 0x1) == 0) {
+					found = dib8000_autosearch_irq(state->fe[index_frontend]);
+					switch (found) {
+					case 0: /* tune pending */
+						 nbr_pending++;
+						 break;
+					case 2:
+						 dprintk("autosearch succeed on the frontend%i", index_frontend);
+						 exit_condition = 2;
+						 index_frontend_success = index_frontend;
+						 break;
+					default:
+						 dprintk("unhandled autosearch result");
+					case 1:
+						 tune_failed |= (1 << index_frontend);
+						 dprintk("autosearch failed for the frontend%i", index_frontend);
+						 break;
+					}
+				}
 			}
-			if (active == 0)
-				dprintk("tuning done with status %d", dib8000_get_status(state->fe[0]));
-		}
 
-		if ((active == 1) && (callback_time == FE_CALLBACK_TIME_NEVER)) {
-			dprintk("strange callback time something went wrong");
-			active = 0;
+			/* if all tune are done and no success, exit: tune failed */
+			if ((nbr_pending == 0) && (exit_condition == 0))
+				exit_condition = 1;
+		} while ((exit_condition == 0) && i--);
+
+		if (exit_condition == 1) { /* tune failed */
+			dprintk("tune failed");
+			return 0;
 		}
 
-		while ((active == 1) && (systime() < callback_time))
-			msleep(100);
-	} while (active);
+		dprintk("tune success on frontend%i", index_frontend_success);
 
-	/* set output mode */
-	if (state->revision != 0x8090)
+		dib8000_get_frontend(fe);
+	}
+
+	for (index_frontend = 0, ret = 0; (ret >= 0) && (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)
+		ret = dib8000_tune(state->fe[index_frontend]);
+
+	/* set output mode and diversity input */
+	if (state->revision != 0x8090) {
 		dib8000_set_output_mode(state->fe[0], state->cfg.output_mode);
-	else {
+		for (index_frontend = 1;
+				(index_frontend < MAX_NUMBER_OF_FRONTENDS) &&
+				(state->fe[index_frontend] != NULL);
+				index_frontend++) {
+			dib8000_set_output_mode(state->fe[index_frontend],
+					OUTMODE_DIVERSITY);
+			dib8000_set_diversity_in(state->fe[index_frontend-1], 1);
+		}
+
+		/* turn off the diversity of the last chip */
+		dib8000_set_diversity_in(state->fe[index_frontend-1], 0);
+	} else {
 		dib8096p_set_output_mode(state->fe[0], state->cfg.output_mode);
 		if (state->cfg.enMpegOutput == 0) {
 			dib8096p_setDibTxMux(state, MPEG_ON_DIBTX);
 			dib8096p_setHostBusMux(state, DIBTX_ON_HOSTBUS);
 		}
+		for (index_frontend = 1;
+				(index_frontend < MAX_NUMBER_OF_FRONTENDS) &&
+				(state->fe[index_frontend] != NULL);
+				index_frontend++) {
+			dib8096p_set_output_mode(state->fe[index_frontend],
+					OUTMODE_DIVERSITY);
+			dib8096p_set_diversity_in(state->fe[index_frontend-1], 1);
+		}
+
+		/* turn off the diversity of the last chip */
+		dib8096p_set_diversity_in(state->fe[index_frontend-1], 0);
 	}
 
 	return ret;
 }
 
+static u16 dib8000_read_lock(struct dvb_frontend *fe)
+{
+	struct dib8000_state *state = fe->demodulator_priv;
+
+	if (state->revision == 0x8090)
+		return dib8000_read_word(state, 570);
+	return dib8000_read_word(state, 568);
+}
+
 static int dib8000_read_status(struct dvb_frontend *fe, fe_status_t * stat)
 {
 	struct dib8000_state *state = fe->demodulator_priv;
 	u16 lock_slave = 0, lock;
 	u8 index_frontend;
 
-	lock = dib8000_read_lock(fe);
+	if (state->revision == 0x8090)
+		lock = dib8000_read_word(state, 570);
+	else
+		lock = dib8000_read_word(state, 568);
+
 	for (index_frontend = 1; (index_frontend < MAX_NUMBER_OF_FRONTENDS) && (state->fe[index_frontend] != NULL); index_frontend++)
 		lock_slave |= dib8000_read_lock(state->fe[index_frontend]);
 
@@ -3976,11 +3545,10 @@ struct dvb_frontend *dib8000_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, s
 	dib8000_reset(fe);
 
 	dib8000_write_word(state, 285, (dib8000_read_word(state, 285) & ~0x60) | (3 << 5));	/* ber_rs_len = 3 */
-	state->current_demod_bw = 6000;
 
 	return fe;
 
-error:
+ error:
 	kfree(state);
 	return NULL;
 }
diff --git a/drivers/media/dvb-frontends/dib8000.h b/drivers/media/dvb-frontends/dib8000.h
index b8c11e5..9e7a2b1 100644
--- a/drivers/media/dvb-frontends/dib8000.h
+++ b/drivers/media/dvb-frontends/dib8000.h
@@ -33,8 +33,6 @@ struct dib8000_config {
 	u8 output_mode;
 	u8 refclksel;
 	u8 enMpegOutput:1;
-
-	struct dibx000_bandwidth_config *plltable;
 };
 
 #define DEFAULT_DIB8000_I2C_ADDRESS 18
@@ -60,7 +58,7 @@ extern int dib8090p_get_dc_power(struct dvb_frontend *fe, u8 IQ);
 extern u32 dib8000_ctrl_timf(struct dvb_frontend *fe,
 		uint8_t op, uint32_t timf);
 extern int dib8000_update_pll(struct dvb_frontend *fe,
-		struct dibx000_bandwidth_config *pll, u32 bw, u8 ratio);
+		struct dibx000_bandwidth_config *pll);
 extern int dib8000_set_slave_frontend(struct dvb_frontend *fe, struct dvb_frontend *fe_slave);
 extern int dib8000_remove_slave_frontend(struct dvb_frontend *fe);
 extern struct dvb_frontend *dib8000_get_slave_frontend(struct dvb_frontend *fe, int slave_index);
@@ -149,7 +147,7 @@ static inline u32 dib8000_ctrl_timf(struct dvb_frontend *fe,
 	return 0;
 }
 static inline int dib8000_update_pll(struct dvb_frontend *fe,
-		struct dibx000_bandwidth_config *pll, u32 bw, u8 ratio)
+		struct dibx000_bandwidth_config *pll)
 {
 	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
 	return -ENODEV;
diff --git a/drivers/media/dvb-frontends/dibx000_common.h b/drivers/media/dvb-frontends/dibx000_common.h
index b538e05..5f48488 100644
--- a/drivers/media/dvb-frontends/dibx000_common.h
+++ b/drivers/media/dvb-frontends/dibx000_common.h
@@ -193,8 +193,7 @@ enum frontend_tune_state {
 	CT_DEMOD_STEP_8,
 	CT_DEMOD_STEP_9,
 	CT_DEMOD_STEP_10,
-	CT_DEMOD_STEP_11,
-	CT_DEMOD_SEARCH_NEXT = 51,
+	CT_DEMOD_SEARCH_NEXT = 41,
 	CT_DEMOD_STEP_LOCKED,
 	CT_DEMOD_STOP,
 
diff --git a/drivers/media/dvb-frontends/ds3000.c b/drivers/media/dvb-frontends/ds3000.c
index 22e8c20..8513fb6 100644
--- a/drivers/media/dvb-frontends/ds3000.c
+++ b/drivers/media/dvb-frontends/ds3000.c
@@ -356,7 +356,10 @@ static int ds3000_firmware_ondemand(struct dvb_frontend *fe)
 	if (ret < 0)
 		return ret;
 
-	/* Load firmware */
+	/* reset all */
+	ds3000_writereg(state, 0x07, 0xe0);
+	ds3000_writereg(state, 0x07, 0x00);
+
 	/* request the firmware, this will block until someone uploads it */
 	printk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,
 				DS3000_DEFAULT_FIRMWARE);
@@ -836,6 +839,7 @@ struct dvb_frontend *ds3000_attach(const struct ds3000_config *config,
 {
 	struct ds3000_state *state = NULL;
 	int ret;
+	u8 val_01, val_02;
 
 	dprintk("%s\n", __func__);
 
@@ -857,9 +861,15 @@ struct dvb_frontend *ds3000_attach(const struct ds3000_config *config,
 		goto error3;
 	}
 
-	printk(KERN_INFO "DS3000 chip version: %d.%d attached.\n",
-			ds3000_readreg(state, 0x02),
-			ds3000_readreg(state, 0x01));
+	/* check demod chip ID */
+	val_01 = ds3000_readreg(state, 0x01);
+	val_02 = ds3000_readreg(state, 0x02);
+	if ((val_02 != 0x00) || (val_01 != 0xC0)) {
+		printk("\tChip ID != [DS300X]! Not supported by this module\n");
+		goto error3;
+	}
+
+	printk(KERN_INFO "DS3000 chip version: %d.%d attached.\n", val_02, val_01);
 
 	memcpy(&state->frontend.ops, &ds3000_ops,
 			sizeof(struct dvb_frontend_ops));
@@ -1094,6 +1104,18 @@ static int ds3000_initfe(struct dvb_frontend *fe)
 	return 0;
 }
 
+/* Put device to sleep */
+static int ds3000_sleep(struct dvb_frontend *fe)
+{
+	struct ds3000_state *state = fe->demodulator_priv;
+
+	if (state->config->set_lock_led)
+		state->config->set_lock_led(fe, 0);
+
+	dprintk("%s()\n", __func__);
+	return 0;
+}
+
 static struct dvb_frontend_ops ds3000_ops = {
 	.delsys = { SYS_DVBS, SYS_DVBS2 },
 	.info = {
@@ -1115,6 +1137,7 @@ static struct dvb_frontend_ops ds3000_ops = {
 	.release = ds3000_release,
 
 	.init = ds3000_initfe,
+	.sleep = ds3000_sleep,
 	.i2c_gate_ctrl = ds3000_i2c_gate_ctrl,
 	.read_status = ds3000_read_status,
 	.read_ber = ds3000_read_ber,
diff --git a/drivers/media/dvb-frontends/ds3103.c b/drivers/media/dvb-frontends/ds3103.c
new file mode 100644
index 0000000..bf01cd3
--- /dev/null
+++ b/drivers/media/dvb-frontends/ds3103.c
@@ -0,0 +1,1395 @@
+/*
+    Montage Technology DS3103 - DVBS/S2 Demodulator driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+
+#include "dvb_frontend.h"
+#include "ds3103.h"
+
+static int debug;
+
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(args); \
+	} while (0)
+
+#define DS3103_DEFAULT_FIRMWARE "dvb-fe-ds3103.fw"
+
+static u8 ds310x_dvbs_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x03,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x40,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x30,
+	0x65, 0x40,
+	0x68, 0x26,
+	0x69, 0x4c,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x7c, 0x00,
+	0xae, 0x82,
+	0x80, 0x64,
+	0x81, 0x66,
+	0x82, 0x44,
+	0x85, 0x04,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xe0, 0xf8,
+	0xe6, 0x8b,
+	0xd0, 0x40,
+	0xf8, 0x20,
+	0xfa, 0x0f,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00
+};
+
+static u8 ds310x_dvbs2_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x07,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x10,
+	0x65, 0x20,
+	0x68, 0x46,
+	0x69, 0xcd,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x85, 0x08,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0x86, 0x00,
+	0x87, 0x0f,
+	0x89, 0x00,
+	0x8b, 0x44,
+	0x8c, 0x66,
+	0x9d, 0xc1,
+	0x8a, 0x10,
+	0xad, 0x40,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc1, 0x10,
+	0xc2, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xca, 0x23,
+	0xcb, 0x24,
+	0xcc, 0xf4,
+	0xce, 0x74,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00
+};
+
+struct ds3103_state {
+	struct i2c_adapter *i2c;
+	const struct ds3103_config *config;
+	struct dvb_frontend frontend;
+	/* previous uncorrected block counter for DVB-S2 */
+	u16 prevUCBS2;
+};
+
+static int ds3103_writereg(struct ds3103_state *state, int reg, int data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = { .addr = state->config->demod_address,
+		.flags = 0, .buf = buf, .len = 2 };
+	int err;
+
+	dprintk("%s: write reg 0x%02x, value 0x%02x\n", __func__, reg, data);
+
+	err = i2c_transfer(state->i2c, &msg, 1);
+	if (err != 1) {
+		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"
+			 " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+/* I2C write for 8k firmware load */
+static int ds3103_writeFW(struct ds3103_state *state, int reg,
+				const u8 *data, u16 len)
+{
+	int i, ret = -EREMOTEIO;
+	struct i2c_msg msg;
+	u8 *buf;
+
+	buf = kmalloc(33, GFP_KERNEL);
+	if (buf == NULL) {
+		printk(KERN_ERR "Unable to kmalloc\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	*(buf) = reg;
+
+	msg.addr = state->config->demod_address;
+	msg.flags = 0;
+	msg.buf = buf;
+	msg.len = 33;
+   
+	for (i = 0; i < len; i += 32) {
+		memcpy(buf + 1, data + i, 32);
+
+		dprintk("%s: write reg 0x%02x, len = %d\n", __func__, reg, len);
+
+		ret = i2c_transfer(state->i2c, &msg, 1);
+		if (ret != 1) {
+			printk(KERN_ERR "%s: write error(err == %i, "
+				"reg == 0x%02x\n", __func__, ret, reg);
+			ret = -EREMOTEIO;
+		}
+	}
+
+error:
+	kfree(buf);
+
+	return ret;
+}
+
+static int ds3103_readreg(struct ds3103_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = state->config->demod_address,
+			.flags = 0,
+			.buf = b0,
+			.len = 1
+		}, {
+			.addr = state->config->demod_address,
+			.flags = I2C_M_RD,
+			.buf = b1,
+			.len = 1
+		}
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	dprintk("%s: read reg 0x%02x, value 0x%02x\n", __func__, reg, b1[0]);
+
+	return b1[0];
+}
+
+static int ds3103_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	
+	if (enable)
+		ds3103_writereg(state, 0x03, 0x12);
+	else
+		ds3103_writereg(state, 0x03, 0x02);
+	
+	return 0;
+}
+static int ds3103_load_firmware(struct dvb_frontend *fe,
+					const struct firmware *fw);
+
+static int ds3103_firmware_ondemand(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	const struct firmware *fw;
+	int ret = 0;
+
+	dprintk("%s()\n", __func__);
+
+	if (ds3103_readreg(state, 0xb2) <= 0)
+		return ret;
+
+	/* global reset, global diseqc reset, global fec reset */
+	ds3103_writereg(state, 0x07, 0xe0);
+	ds3103_writereg(state, 0x07, 0x00);
+
+	/* request the firmware, this will block until someone uploads it */
+	printk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,
+				DS3103_DEFAULT_FIRMWARE);
+	ret = request_firmware(&fw, DS3103_DEFAULT_FIRMWARE,
+				state->i2c->dev.parent);
+	printk(KERN_INFO "%s: Waiting for firmware upload(2)...\n", __func__);
+	if (ret) {
+		printk(KERN_ERR "%s: No firmware uploaded (timeout or file not "
+				"found?)\n", __func__);
+		return ret;
+	}
+
+	ret = ds3103_load_firmware(fe, fw);
+	if (ret)
+		printk("%s: Writing firmware to device failed\n", __func__);
+
+	release_firmware(fw);
+
+	dprintk("%s: Firmware upload %s\n", __func__,
+			ret == 0 ? "complete" : "failed");
+
+	return ret;
+}
+
+static int ds3103_load_firmware(struct dvb_frontend *fe,
+					const struct firmware *fw)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+
+	dprintk("%s\n", __func__);
+	dprintk("Firmware is %zu bytes (%02x %02x .. %02x %02x)\n",
+			fw->size,
+			fw->data[0],
+			fw->data[1],
+			fw->data[fw->size - 2],
+			fw->data[fw->size - 1]);
+
+	/* Begin the firmware load process */
+	ds3103_writereg(state, 0xb2, 0x01);
+	/* write the entire firmware */
+	ds3103_writeFW(state, 0xb0, fw->data, fw->size);
+	ds3103_writereg(state, 0xb2, 0x00);
+
+	return 0;
+}
+
+static int ds3103_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	u8 data;
+
+	dprintk("%s(%d)\n", __func__, voltage);
+
+	data = ds3103_readreg(state, 0xa2);
+	data |= 0x03; /* bit0 V/H, bit1 off/on */
+
+	switch (voltage) {
+	case SEC_VOLTAGE_18:
+		data &= ~0x03;
+		break;
+	case SEC_VOLTAGE_13:
+		data &= ~0x03;
+		data |= 0x01;
+		break;
+	case SEC_VOLTAGE_OFF:
+		break;
+	}
+
+	ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+static int ds3103_read_status(struct dvb_frontend *fe, fe_status_t* status)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int lock;
+
+	*status = 0;
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		lock = ds3103_readreg(state, 0xd1);
+		if ((lock & 0x07) == 0x07)
+			*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |
+				FE_HAS_VITERBI | FE_HAS_SYNC |
+				FE_HAS_LOCK;
+
+		break;
+	case SYS_DVBS2:
+		lock = ds3103_readreg(state, 0x0d);
+		if ((lock & 0x8f) == 0x8f)
+			*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |
+				FE_HAS_VITERBI | FE_HAS_SYNC |
+				FE_HAS_LOCK;
+
+		break;
+	default:
+		return 1;
+	}
+
+	if (state->config->set_lock_led)
+		state->config->set_lock_led(fe, *status == 0 ? 0 : 1);
+
+	dprintk("%s: status = 0x%02x\n", __func__, lock);
+
+	return 0;
+}
+
+/* read DS3103 BER value */
+static int ds3103_read_ber(struct dvb_frontend *fe, u32* ber)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 data;
+	u32 ber_reading, lpdc_frames;
+
+	dprintk("%s()\n", __func__);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		/* set the number of bytes checked during
+		BER estimation */
+		ds3103_writereg(state, 0xf9, 0x04);
+		/* read BER estimation status */
+		data = ds3103_readreg(state, 0xf8);
+		/* check if BER estimation is ready */
+		if ((data & 0x10) == 0) {
+			/* this is the number of error bits,
+			to calculate the bit error rate
+			divide to 8388608 */
+			*ber = (ds3103_readreg(state, 0xf7) << 8) |
+				ds3103_readreg(state, 0xf6);
+			/* start counting error bits */
+			/* need to be set twice
+			otherwise it fails sometimes */
+			data |= 0x10;
+			ds3103_writereg(state, 0xf8, data);
+			ds3103_writereg(state, 0xf8, data);
+		} else
+			/* used to indicate that BER estimation
+			is not ready, i.e. BER is unknown */
+			*ber = 0xffffffff;
+		break;
+	case SYS_DVBS2:
+		/* read the number of LPDC decoded frames */
+		lpdc_frames = (ds3103_readreg(state, 0xd7) << 16) |
+				(ds3103_readreg(state, 0xd6) << 8) |
+				ds3103_readreg(state, 0xd5);
+		/* read the number of packets with bad CRC */
+		ber_reading = (ds3103_readreg(state, 0xf8) << 8) |
+				ds3103_readreg(state, 0xf7);
+		if (lpdc_frames > 750) {
+			/* clear LPDC frame counters */
+			ds3103_writereg(state, 0xd1, 0x01);
+			/* clear bad packets counter */
+			ds3103_writereg(state, 0xf9, 0x01);
+			/* enable bad packets counter */
+			ds3103_writereg(state, 0xf9, 0x00);
+			/* enable LPDC frame counters */
+			ds3103_writereg(state, 0xd1, 0x00);
+			*ber = ber_reading;
+		} else
+			/* used to indicate that BER estimation is not ready,
+			i.e. BER is unknown */
+			*ber = 0xffffffff;
+		break;
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+
+/* calculate DS3103 snr value in dB */
+static int ds3103_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 snr_reading, snr_value;
+	u32 dvbs2_signal_reading, dvbs2_noise_reading, tmp;
+	static const u16 dvbs_snr_tab[] = { /* 20 x Table (rounded up) */
+		0x0000, 0x1b13, 0x2aea, 0x3627, 0x3ede, 0x45fe, 0x4c03,
+		0x513a, 0x55d4, 0x59f2, 0x5dab, 0x6111, 0x6431, 0x6717,
+		0x69c9, 0x6c4e, 0x6eac, 0x70e8, 0x7304, 0x7505
+	};
+	static const u16 dvbs2_snr_tab[] = { /* 80 x Table (rounded up) */
+		0x0000, 0x0bc2, 0x12a3, 0x1785, 0x1b4e, 0x1e65, 0x2103,
+		0x2347, 0x2546, 0x2710, 0x28ae, 0x2a28, 0x2b83, 0x2cc5,
+		0x2df1, 0x2f09, 0x3010, 0x3109, 0x31f4, 0x32d2, 0x33a6,
+		0x3470, 0x3531, 0x35ea, 0x369b, 0x3746, 0x37ea, 0x3888,
+		0x3920, 0x39b3, 0x3a42, 0x3acc, 0x3b51, 0x3bd3, 0x3c51,
+		0x3ccb, 0x3d42, 0x3db6, 0x3e27, 0x3e95, 0x3f00, 0x3f68,
+		0x3fcf, 0x4033, 0x4094, 0x40f4, 0x4151, 0x41ac, 0x4206,
+		0x425e, 0x42b4, 0x4308, 0x435b, 0x43ac, 0x43fc, 0x444a,
+		0x4497, 0x44e2, 0x452d, 0x4576, 0x45bd, 0x4604, 0x4649,
+		0x468e, 0x46d1, 0x4713, 0x4755, 0x4795, 0x47d4, 0x4813,
+		0x4851, 0x488d, 0x48c9, 0x4904, 0x493f, 0x4978, 0x49b1,
+		0x49e9, 0x4a20, 0x4a57
+	};
+
+	dprintk("%s()\n", __func__);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		snr_reading = ds3103_readreg(state, 0xff);
+		snr_reading /= 8;
+		if (snr_reading == 0)
+			*snr = 0x0000;
+		else {
+			if (snr_reading > 20)
+				snr_reading = 20;
+			snr_value = dvbs_snr_tab[snr_reading - 1] * 10 / 23026;
+			/* cook the value to be suitable for szap-s2
+			human readable output */
+			*snr = snr_value * 8 * 655;
+		}
+		dprintk("%s: raw / cooked = 0x%02x / 0x%04x\n", __func__,
+				snr_reading, *snr);
+		break;
+	case SYS_DVBS2:
+		dvbs2_noise_reading = (ds3103_readreg(state, 0x8c) & 0x3f) +
+				(ds3103_readreg(state, 0x8d) << 4);
+		dvbs2_signal_reading = ds3103_readreg(state, 0x8e);
+		tmp = dvbs2_signal_reading * dvbs2_signal_reading >> 1;
+		if (tmp == 0) {
+			*snr = 0x0000;
+			return 0;
+		}
+		if (dvbs2_noise_reading == 0) {
+			snr_value = 0x0013;
+			/* cook the value to be suitable for szap-s2
+			human readable output */
+			*snr = 0xffff;
+			return 0;
+		}
+		if (tmp > dvbs2_noise_reading) {
+			snr_reading = tmp / dvbs2_noise_reading;
+			if (snr_reading > 80)
+				snr_reading = 80;
+			snr_value = dvbs2_snr_tab[snr_reading - 1] / 1000;
+			/* cook the value to be suitable for szap-s2
+			human readable output */
+			*snr = snr_value * 5 * 655;
+		} else {
+			snr_reading = dvbs2_noise_reading / tmp;
+			if (snr_reading > 80)
+				snr_reading = 80;
+			*snr = -(dvbs2_snr_tab[snr_reading] / 1000);
+		}
+		dprintk("%s: raw / cooked = 0x%02x / 0x%04x\n", __func__,
+				snr_reading, *snr);
+		break;
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+
+/* read DS3103 uncorrected blocks */
+static int ds3103_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 data;
+	u16 _ucblocks;
+
+	dprintk("%s()\n", __func__);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		*ucblocks = (ds3103_readreg(state, 0xf5) << 8) |
+				ds3103_readreg(state, 0xf4);
+		data = ds3103_readreg(state, 0xf8);
+		/* clear packet counters */
+		data &= ~0x20;
+		ds3103_writereg(state, 0xf8, data);
+		/* enable packet counters */
+		data |= 0x20;
+		ds3103_writereg(state, 0xf8, data);
+		break;
+	case SYS_DVBS2:
+		_ucblocks = (ds3103_readreg(state, 0xe2) << 8) |
+				ds3103_readreg(state, 0xe1);
+		if (_ucblocks > state->prevUCBS2)
+			*ucblocks = _ucblocks - state->prevUCBS2;
+		else
+			*ucblocks = state->prevUCBS2 - _ucblocks;
+		state->prevUCBS2 = _ucblocks;
+		break;
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+
+static int ds3103_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	u8 data;
+
+	dprintk("%s(%d)\n", __func__, tone);
+	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
+		printk(KERN_ERR "%s: Invalid, tone=%d\n", __func__, tone);
+		return -EINVAL;
+	}
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	ds3103_writereg(state, 0xa2, data);
+
+	switch (tone) {
+	case SEC_TONE_ON:
+		dprintk("%s: setting tone on\n", __func__);
+		data = ds3103_readreg(state, 0xa1);
+		data &= ~0x43;
+		data |= 0x04;
+		ds3103_writereg(state, 0xa1, data);
+		break;
+	case SEC_TONE_OFF:
+		dprintk("%s: setting tone off\n", __func__);
+		data = ds3103_readreg(state, 0xa2);
+		data |= 0x80;
+		ds3103_writereg(state, 0xa2, data);
+		break;
+	}
+
+	return 0;
+}
+
+static int ds3103_send_diseqc_msg(struct dvb_frontend *fe,
+				struct dvb_diseqc_master_cmd *d)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	int i;
+	u8 data;
+
+	/* Dump DiSEqC message */
+	dprintk("%s(", __func__);
+	for (i = 0 ; i < d->msg_len;) {
+		dprintk("0x%02x", d->msg[i]);
+		if (++i < d->msg_len)
+			dprintk(", ");
+	}
+
+	/* enable DiSEqC message send pin */
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data &= ~0x20;
+	ds3103_writereg(state, 0xa2, data);
+
+	/* DiSEqC message */
+	for (i = 0; i < d->msg_len; i++)
+		ds3103_writereg(state, 0xa3 + i, d->msg[i]);
+
+	data = ds3103_readreg(state, 0xa1);
+	/* clear DiSEqC message length and status,
+	enable DiSEqC message send */
+	data &= ~0xf8;
+	/* set DiSEqC mode, modulation active during 33 pulses,
+	set DiSEqC message length */
+	data |= ((d->msg_len - 1) << 3) | 0x07;
+	ds3103_writereg(state, 0xa1, data);
+
+	/* wait up to 150ms for DiSEqC transmission to complete */
+	for (i = 0; i < 15; i++) {
+		data = ds3103_readreg(state, 0xa1);
+		if ((data & 0x40) == 0)
+			break;
+		msleep(10);
+	}
+
+	/* DiSEqC timeout after 150ms */
+	if (i == 15) {
+		data = ds3103_readreg(state, 0xa1);
+		data &= ~0x80;
+		data |= 0x40;
+		ds3103_writereg(state, 0xa1, data);
+
+		data = ds3103_readreg(state, 0xa2);
+		data &= ~0xc0;
+		data |= 0x80;
+		ds3103_writereg(state, 0xa2, data);
+
+		return 1;
+	}
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data |= 0x80;
+	ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+/* Send DiSEqC burst */
+static int ds3103_diseqc_send_burst(struct dvb_frontend *fe,
+					fe_sec_mini_cmd_t burst)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	int i;
+	u8 data;
+
+	dprintk("%s()\n", __func__);
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data &= ~0x20;
+	ds3103_writereg(state, 0xa2, data);
+
+	/* DiSEqC burst */
+	if (burst == SEC_MINI_A)
+		/* Unmodulated tone burst */
+		ds3103_writereg(state, 0xa1, 0x02);
+	else if (burst == SEC_MINI_B)
+		/* Modulated tone burst */
+		ds3103_writereg(state, 0xa1, 0x01);
+	else
+		return -EINVAL;
+
+	msleep(13);
+	for (i = 0; i < 5; i++) {
+		data = ds3103_readreg(state, 0xa1);
+		if ((data & 0x40) == 0)
+			break;
+		msleep(1);
+	}
+
+	if (i == 5) {
+		data = ds3103_readreg(state, 0xa1);
+		data &= ~0x80;
+		data |= 0x40;
+		ds3103_writereg(state, 0xa1, data);
+
+		data = ds3103_readreg(state, 0xa2);
+		data &= ~0xc0;
+		data |= 0x80;
+		ds3103_writereg(state, 0xa2, data);
+
+		return 1;
+	}
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data |= 0x80;
+	ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+static void ds3103_release(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+
+	if (state->config->set_lock_led)
+		state->config->set_lock_led(fe, 0);
+
+	dprintk("%s\n", __func__);
+	kfree(state);
+}
+
+static struct dvb_frontend_ops ds3103_ops;
+
+struct dvb_frontend *ds3103_attach(const struct ds3103_config *config,
+				    struct i2c_adapter *i2c)
+{
+	struct ds3103_state *state = NULL;
+	int ret;
+	u8 val_01, val_02, val_b2;
+
+
+	dprintk("%s\n", __func__);
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct ds3103_state), GFP_KERNEL);
+	if (state == NULL) {
+		printk(KERN_ERR "Unable to kmalloc\n");
+		goto error2;
+	}
+
+	state->config = config;
+	state->i2c = i2c;
+	state->prevUCBS2 = 0;
+
+	/* check if the demod is present */
+	ret = ds3103_readreg(state, 0x00) & 0xfe;
+	if (ret != 0xe0) {
+		printk(KERN_ERR "Invalid probe, probably not a DS3x0x\n");
+		goto error3;
+	}
+
+	/* check demod chip ID */
+	val_01 = ds3103_readreg(state, 0x01);
+	val_02 = ds3103_readreg(state, 0x02);
+	val_b2 = ds3103_readreg(state, 0xb2);
+	if((val_02 == 0x00) &&
+			(val_01 == 0xD0) && ((val_b2 & 0xC0) == 0xC0)) {
+		printk("\tChip ID = [DS3103]!\n");
+	} else if((val_02 == 0x00) &&
+			(val_01 == 0xD0) && ((val_b2 & 0xC0) == 0x00)) {
+		printk("\tChip ID = [DS3002B]!\n");
+	} else if ((val_02 == 0x00) && (val_01 == 0xC0)) {
+		printk("\tChip ID = [DS300X]! Not supported by this module\n");
+		goto error3;
+	} else {
+		printk("\tChip ID = unknow!\n");
+		goto error3;
+	}
+
+	printk(KERN_INFO "DS3103 chip version: %d.%d attached.\n", val_02, val_01);
+
+	memcpy(&state->frontend.ops, &ds3103_ops,
+			sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+
+error3:
+	kfree(state);
+error2:
+	return NULL;
+}
+EXPORT_SYMBOL(ds3103_attach);
+
+static int ds3103_set_carrier_offset(struct dvb_frontend *fe,
+					s32 carrier_offset_khz,
+					u32 target_mclk)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	s32 tmp;
+
+	tmp = carrier_offset_khz;
+	tmp *= 65536;
+	tmp = (2 * tmp + target_mclk) / (2 * target_mclk);
+
+	if (tmp < 0)
+		tmp += 65536;
+
+	ds3103_writereg(state, 0x5f, tmp >> 8);
+	ds3103_writereg(state, 0x5e, tmp & 0xff);
+
+	return 0;
+}
+static int ds3103_set_ts_div(struct ds3103_state *state, u8 tmp1, u8 tmp2)
+{
+	u8 buf;
+	tmp1 -= 1;
+	tmp2 -= 1;
+
+	tmp1 &= 0x3f;
+	tmp2 &= 0x3f;
+
+	buf = ds3103_readreg(state, 0xfe);
+	buf &= 0xf0;
+	buf |= (tmp1 >> 2) & 0x0f;
+	ds3103_writereg(state, 0xfe, buf);
+
+	buf = (u8)((tmp1 & 0x03) << 6);
+	buf |= tmp2;
+	ds3103_writereg(state, 0xea, buf);
+
+	return 0;
+}
+
+u32 ds3103_get_mclk(struct ds3103_state *state)
+{
+	u32 p_mclk_khz = 96000;
+	u8 tmp1, tmp2;
+
+	tmp1 = ds3103_readreg(state, 0x22);
+	tmp2 = ds3103_readreg(state, 0x24);
+
+	tmp1 >>= 6;
+	tmp1 &= 0x03;
+	tmp2 >>= 6;
+	tmp2 &= 0x03;
+
+	if((tmp1 == 0x00) && (tmp2 == 0x01))
+		p_mclk_khz = 144000;
+	else if ((tmp1 == 0x00) && (tmp2 == 0x03))
+		p_mclk_khz = 72000;
+	else if ((tmp1 == 0x01) && (tmp2 == 0x01))
+		p_mclk_khz = 115200;
+	else if ((tmp1 == 0x02) && (tmp2 == 0x01))
+		p_mclk_khz = 96000;
+	else if ((tmp1 == 0x03) && (tmp2 == 0x00))
+		p_mclk_khz = 192000;
+
+	return p_mclk_khz;
+}
+
+static int ds3103_set_clock_ratio(struct ds3103_state *state, u32 target_mclk)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8	mod_fac, tmp1, tmp2;
+	u32	input_datarate;
+	u32 mclk_khz = target_mclk;
+	u16 divid_ratio = 0;
+	u32 sym_rate_kss = p->symbol_rate / 1000;
+
+	if (p->delivery_system == SYS_DVBS2) {
+		switch(p->modulation) {
+		case PSK_8:
+			mod_fac = 3;
+			break;
+		case APSK_16:
+			mod_fac = 4;
+			break;
+		case APSK_32:
+			mod_fac = 5;
+			break;
+		case QPSK:
+		default:
+			mod_fac = 2;
+			break;
+		}
+
+		switch(p->fec_inner) {
+/*		case FEC_1_4:
+ *			input_datarate = sym_rate_kss * mod_fac / 8 / 4;
+ *			break;
+ *		case FEC_1_3:
+ *			input_datarate = sym_rate_kss * mod_fac / 8 / 3;
+ *			break;
+ */
+		case FEC_2_5:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 8 / 5;
+			break;
+		case FEC_1_2:
+			input_datarate = sym_rate_kss * mod_fac / 8 / 2;
+			break;
+		case FEC_3_5:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 8 / 5;
+			break;
+		case FEC_2_3:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 8 / 3;
+			break;
+		case FEC_3_4:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 8 / 4;
+			break;
+		case FEC_4_5:
+			input_datarate = sym_rate_kss * mod_fac * 4 / 8 / 5;
+			break;
+		case FEC_5_6:
+			input_datarate = sym_rate_kss * mod_fac * 5 / 8 / 6;
+			break;
+		case FEC_8_9:
+			input_datarate = sym_rate_kss * mod_fac * 8 / 8 / 9;
+			break;
+		case FEC_9_10:
+			input_datarate = sym_rate_kss * mod_fac * 9 / 8 / 10;
+			break;
+		default:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 8 / 3;
+			break;
+		}
+
+		/* parallel or CI mode for now */
+		if (input_datarate != 0)
+			divid_ratio = mclk_khz / input_datarate;
+		else
+			divid_ratio = 0xff;
+
+		if (divid_ratio > 128)
+			divid_ratio = 128;
+		
+		if (divid_ratio < 2)
+			divid_ratio = 2;
+		
+		tmp1 = divid_ratio / 2;
+		tmp2 = divid_ratio / 2;
+		
+		if ((divid_ratio % 2) != 0)
+			tmp2 += 1;
+
+	} else { /* for dvb-s */
+		mod_fac = 2;
+
+		switch (p->fec_inner) {
+		case FEC_1_2:
+			input_datarate = sym_rate_kss * mod_fac / 2 / 8;
+			break;
+		case FEC_2_3:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 3 / 8;
+			break;
+		case FEC_3_4:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 4 / 8;
+			break;
+		case FEC_5_6:
+			input_datarate = sym_rate_kss * mod_fac * 5 / 6 / 8;
+			break;
+		case FEC_7_8:
+			input_datarate = sym_rate_kss * mod_fac * 7 / 8 / 8;
+			break;
+		default:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 4 / 8;
+			break;
+		}
+
+		if (input_datarate != 0)
+			divid_ratio = mclk_khz / input_datarate;
+		else
+			divid_ratio = 0xff;
+
+		if (divid_ratio > 128)
+			divid_ratio = 128;
+		
+		if (divid_ratio < 2)
+			divid_ratio = 2;
+
+		tmp1 = divid_ratio / 2;
+		tmp2 = divid_ratio / 2;
+
+		if ((divid_ratio % 2) != 0)
+			tmp2 += 1;
+
+	}
+
+	ds3103_set_ts_div(state, tmp1, tmp2);
+
+	return 0;
+}
+
+static int ds3103_set_frontend(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	int i;
+	fe_status_t status;
+	s32 offset_khz;
+	u32 tuner_freq;
+	u16 value;
+	u32 tmp;
+	u8 tmp1, tmp2;
+	u32 target_mclk = 0;
+
+	dprintk("%s() frec=%d symb=%d", __func__, c->frequency, c->symbol_rate);
+
+	if (state->config->set_ts_params)
+		state->config->set_ts_params(fe, 0);
+
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	
+
+	ds3103_writereg(state, 0xb2, 0x01);
+	ds3103_writereg(state, 0x00, 0x01);
+
+	if (fe->ops.tuner_ops.get_frequency)
+		fe->ops.tuner_ops.get_frequency(fe, &tuner_freq);
+
+	offset_khz = tuner_freq - c->frequency;
+
+	value = ds3103_readreg(state, 0x08);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS2:
+		value |= 0x04;
+		ds3103_writereg(state, 0x08, value);
+		for (i = 0; i < sizeof(ds310x_dvbs2_init_tab); i += 2)
+			ds3103_writereg(state,
+				ds310x_dvbs2_init_tab[i],
+				ds310x_dvbs2_init_tab[i + 1]);
+
+		value = ds3103_readreg(state, 0x4d);
+		value &= ~0x02;
+		ds3103_writereg(state, 0x4d, value);
+		value = ds3103_readreg(state, 0x30);
+		value &= ~0x10;
+		ds3103_writereg(state, 0x30, value);
+		if (c->symbol_rate > 28000000) {
+			target_mclk = 192000;
+		} else if (c->symbol_rate > 18000000) {
+			target_mclk = 144000;
+		} else
+			target_mclk = 96000;
+
+		if (c->symbol_rate <= 5000000) {
+			ds3103_writereg(state, 0xc0, 0x04);
+			ds3103_writereg(state, 0x8a, 0x09);
+			ds3103_writereg(state, 0x8b, 0x22);
+			ds3103_writereg(state, 0x8c, 0x88);
+		}
+
+		break;
+	case SYS_DVBS:
+	default:
+		value &= ~0x04;
+		ds3103_writereg(state, 0x08, value);
+		for (i = 0; i < sizeof(ds310x_dvbs_init_tab); i += 2)
+			ds3103_writereg(state,
+					ds310x_dvbs_init_tab[i],
+					ds310x_dvbs_init_tab[i + 1]);
+		
+		target_mclk = 96000;
+		
+		value = ds3103_readreg(state, 0x4d);
+		value &= ~0x02;
+		ds3103_writereg(state, 0x4d, value);
+		value = ds3103_readreg(state, 0x30);
+		value &= ~0x10;
+		ds3103_writereg(state, 0x30, value);
+		
+		break;
+	}
+
+	ds3103_set_clock_ratio(state, target_mclk);
+
+	tmp1 = ds3103_readreg(state, 0x22);
+	tmp2 = ds3103_readreg(state, 0x24);
+
+	switch (target_mclk) {
+	case 192000:
+		tmp1 |= 0xc0;
+		tmp2 &= 0x3f;
+		break;
+
+	case 144000:
+		tmp1 &= 0x3f;
+		tmp2 &= 0x7f;
+		tmp2 |= 0x40;
+		break;
+
+	case 96000:
+	default:
+		tmp1 &= 0xbf;
+		tmp1 |= 0x80;
+
+		tmp2 &= 0x7f;
+		tmp2 |= 0x40;
+		break;
+	}
+
+	ds3103_writereg(state, 0x22, tmp1);
+	ds3103_writereg(state, 0x24, tmp2);
+
+	ds3103_writereg(state, 0x33, 0x99);
+
+	/* enable 27MHz clock output */
+	value = ds3103_readreg(state, 0x29);
+	value &= 0x80;
+	value &= ~0x10;
+	ds3103_writereg(state, 0x29, value);
+
+	/* enable ac coupling */
+	value = ds3103_readreg(state, 0x25);
+	value |= 0x08;
+	ds3103_writereg(state, 0x25, value);
+
+
+	/* enhance symbol rate performance */
+	if ((c->symbol_rate / 1000) <= 3000) {
+		ds3103_writereg(state, 0xc3, 0x08);
+		ds3103_writereg(state, 0xc8, 0x20);
+		ds3103_writereg(state, 0xc4, 0x08);
+		ds3103_writereg(state, 0xc7, 0x00);
+	} else if((c->symbol_rate / 1000) <= 10000) {
+		ds3103_writereg(state, 0xc3, 0x08);
+		ds3103_writereg(state, 0xc8, 0x10);
+		ds3103_writereg(state, 0xc4, 0x08);
+		ds3103_writereg(state, 0xc7, 0x00);
+	} else {
+		ds3103_writereg(state, 0xc3, 0x08);
+		ds3103_writereg(state, 0xc8, 0x06);
+		ds3103_writereg(state, 0xc4, 0x08);
+		ds3103_writereg(state, 0xc7, 0x00);
+	}
+
+	/* normalized symbol rate rounded to the closest integer */
+	tmp = (((c->symbol_rate / 1000) << 15) + 24000) / 48000;
+
+	ds3103_writereg(state, 0x61, tmp & 0x00ff);
+	ds3103_writereg(state, 0x62, (tmp & 0xff00) >> 8);
+
+	/* co-channel interference cancellation disabled */
+	value = ds3103_readreg(state, 0x56);
+	value &= ~0x01;
+	ds3103_writereg(state, 0x56, value);
+	/* equalizer disabled */
+	value = ds3103_readreg(state, 0x76);
+	value &= ~0x80;
+	ds3103_writereg(state, 0x76, value);
+	/* offset */
+	if ((c->symbol_rate / 1000) < 5000)
+		offset_khz += 3000;
+	ds3103_set_carrier_offset(fe, offset_khz, target_mclk);
+
+	/* ds3000 out of software reset */
+	ds3103_writereg(state, 0x00, 0x00);
+	/* start ds3000 build-in uC */
+	ds3103_writereg(state, 0xb2, 0x00);
+
+
+	for (i = 0; i < 30 ; i++) {
+		ds3103_read_status(fe, &status);
+		if (status && FE_HAS_LOCK)
+			break;
+
+		msleep(10);
+	}
+
+	return 0;
+}
+
+static int ds3103_tune(struct dvb_frontend *fe,
+			bool re_tune,
+			unsigned int mode_flags,
+			unsigned int *delay,
+			fe_status_t *status)
+{
+	if (re_tune) {
+		int ret = ds3103_set_frontend(fe);
+		if (ret)
+			return ret;
+	}
+
+	*delay = HZ / 5;
+
+	return ds3103_read_status(fe, status);
+}
+
+static enum dvbfe_algo ds3103_get_algo(struct dvb_frontend *fe)
+{
+	dprintk("%s()\n", __func__);
+	return DVBFE_ALGO_HW;
+}
+
+/*
+ * Initialize or wake up device
+ *
+ * Power config will reset and load initial firmware if required
+ */
+static int ds3103_initfe(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf;
+	u8 val_08;
+
+	dprintk("%s()\n", __func__);
+	/* hard reset */
+	buf = ds3103_readreg(state, 0xb2);
+	if (buf == 0x01) {
+		ds3103_writereg(state, 0x00, 0x00);
+		ds3103_writereg(state, 0xb2, 0x00);
+	}
+
+
+	/* global reset */
+	ds3103_writereg(state, 0x07, 0xe0);
+	ds3103_writereg(state, 0x07, 0x00);
+	ds3103_writereg(state, 0x08, 0x01 | ds3103_readreg(state, 0x08));
+	msleep(1);
+
+	/* Load the firmware if required */
+	ret = ds3103_firmware_ondemand(fe);
+	if (ret != 0) {
+		printk(KERN_ERR "%s: Unable initialize firmware\n", __func__);
+		return ret;
+	}
+	/* ts out mode */
+	val_08 = ds3103_readreg(state, 0x08);
+	buf = ds3103_readreg(state, 0x27);
+	buf &= ~0x01;
+	ds3103_writereg(state, 0x27, buf);
+	/* for dvb-s */
+	buf = val_08 & (~0x04) ;
+	ds3103_writereg(state, 0x08, buf);
+	ds3103_set_ts_div(state, 6, 6);
+
+	/* for dvb-s2 */
+	buf = val_08 | 0x04 ;
+	ds3103_writereg(state, 0x08, buf);
+	ds3103_set_ts_div(state, 8, 9);
+	buf = ds3103_readreg(state, 0xfd);
+	buf |= 0x01;
+	buf &= ~0x04;
+
+	buf &= ~0xba;
+	if (state->config->ci_mode)
+		buf |= 0x40;
+	else
+		buf &= ~0x40;
+
+	ds3103_writereg(state, 0xfd, buf);
+	ds3103_writereg(state, 0x08, val_08);
+	buf = ds3103_readreg(state, 0x27);
+	buf |= 0x11;
+	ds3103_writereg(state, 0x27, buf);
+	buf = ds3103_readreg(state, 0x4d);
+	buf &= ~0x02;
+	ds3103_writereg(state, 0x4d, buf);
+	buf = ds3103_readreg(state, 0x30);
+	buf &= ~0x10;
+	ds3103_writereg(state, 0x30, buf);
+
+	return 0;
+}
+
+/* Put device to sleep */
+static int ds3103_sleep(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+
+	if (state->config->set_lock_led)
+		state->config->set_lock_led(fe, 0);
+
+	dprintk("%s()\n", __func__);
+	return 0;
+}
+
+static struct dvb_frontend_ops ds3103_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 },
+	.info = {
+		.name = "Montage Technology DS3103/TS2022",
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
+		.frequency_tolerance = 5000,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_2G_MODULATION |
+			FE_CAN_QPSK | FE_CAN_RECOVER
+	},
+
+	.release = ds3103_release,
+
+	.init = ds3103_initfe,
+	.sleep = ds3103_sleep,
+	.read_status = ds3103_read_status,
+	.read_ber = ds3103_read_ber,
+	.i2c_gate_ctrl = ds3103_i2c_gate_ctrl,
+	.read_snr = ds3103_read_snr,
+	.read_ucblocks = ds3103_read_ucblocks,
+	.set_voltage = ds3103_set_voltage,
+	.set_tone = ds3103_set_tone,
+	.diseqc_send_master_cmd = ds3103_send_diseqc_msg,
+	.diseqc_send_burst = ds3103_diseqc_send_burst,
+	.get_frontend_algo = ds3103_get_algo,
+
+	.set_frontend = ds3103_set_frontend,
+	.tune = ds3103_tune,
+};
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+MODULE_DESCRIPTION("DVB Frontend module for Montage Technology "
+			"DS3103 hardware");
+MODULE_AUTHOR("Tomazzo Muzumici");
+MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(DS3103_DEFAULT_FIRMWARE);
diff --git a/drivers/media/dvb-frontends/ds3103.h b/drivers/media/dvb-frontends/ds3103.h
new file mode 100644
index 0000000..54270d2
--- /dev/null
+++ b/drivers/media/dvb-frontends/ds3103.h
@@ -0,0 +1,47 @@
+/*
+    Montage Technology DS3103 - DVBS/S2 Demodulator driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef DS3103_H
+#define DS3103_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+
+struct ds3103_config {
+	/* the demodulator's i2c address */
+	u8 demod_address;
+	u8 ci_mode;
+	/* Set device param to start dma */
+	int (*set_ts_params)(struct dvb_frontend *fe, int is_punctured);
+	/* Hook for Lock LED */
+	void (*set_lock_led)(struct dvb_frontend *fe, int offon);
+};
+
+#if IS_ENABLED(CONFIG_DVB_DS3103)
+extern struct dvb_frontend *ds3103_attach(const struct ds3103_config *config,
+					struct i2c_adapter *i2c);
+#else
+static inline
+struct dvb_frontend *ds3103_attach(const struct ds3103_config *config,
+					struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_DS3103 */
+#endif /* DS3103_H */
diff --git a/drivers/media/dvb-frontends/isl6421.c b/drivers/media/dvb-frontends/isl6421.c
index c77002f..0cb3f0f 100644
--- a/drivers/media/dvb-frontends/isl6421.c
+++ b/drivers/media/dvb-frontends/isl6421.c
@@ -89,30 +89,6 @@ static int isl6421_enable_high_lnb_voltage(struct dvb_frontend *fe, long arg)
 	return (i2c_transfer(isl6421->i2c, &msg, 1) == 1) ? 0 : -EIO;
 }
 
-static int isl6421_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
-{
-	struct isl6421 *isl6421 = (struct isl6421 *) fe->sec_priv;
-	struct i2c_msg msg = { .addr = isl6421->i2c_addr, .flags = 0,
-			       .buf = &isl6421->config,
-			       .len = sizeof(isl6421->config) };
-
-	switch (tone) {
-	case SEC_TONE_ON:
-		isl6421->config |= ISL6421_ENT1;
-		break;
-	case SEC_TONE_OFF:
-		isl6421->config &= ~ISL6421_ENT1;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	isl6421->config |= isl6421->override_or;
-	isl6421->config &= isl6421->override_and;
-
-	return (i2c_transfer(isl6421->i2c, &msg, 1) == 1) ? 0 : -EIO;
-}
-
 static void isl6421_release(struct dvb_frontend *fe)
 {
 	/* power off */
@@ -124,7 +100,7 @@ static void isl6421_release(struct dvb_frontend *fe)
 }
 
 struct dvb_frontend *isl6421_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, u8 i2c_addr,
-		   u8 override_set, u8 override_clear, bool override_tone)
+		   u8 override_set, u8 override_clear)
 {
 	struct isl6421 *isl6421 = kmalloc(sizeof(struct isl6421), GFP_KERNEL);
 	if (!isl6421)
@@ -155,8 +131,6 @@ struct dvb_frontend *isl6421_attach(struct dvb_frontend *fe, struct i2c_adapter
 	/* override frontend ops */
 	fe->ops.set_voltage = isl6421_set_voltage;
 	fe->ops.enable_high_lnb_voltage = isl6421_enable_high_lnb_voltage;
-	if (override_tone)
-		fe->ops.set_tone = isl6421_set_tone;
 
 	return fe;
 }
diff --git a/drivers/media/dvb-frontends/isl6421.h b/drivers/media/dvb-frontends/isl6421.h
index 630e7f8..e7ca7d1 100644
--- a/drivers/media/dvb-frontends/isl6421.h
+++ b/drivers/media/dvb-frontends/isl6421.h
@@ -42,10 +42,10 @@
 #if IS_ENABLED(CONFIG_DVB_ISL6421)
 /* override_set and override_clear control which system register bits (above) to always set & clear */
 extern struct dvb_frontend *isl6421_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, u8 i2c_addr,
-			  u8 override_set, u8 override_clear, bool override_tone);
+			  u8 override_set, u8 override_clear);
 #else
 static inline struct dvb_frontend *isl6421_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, u8 i2c_addr,
-						  u8 override_set, u8 override_clear, bool override_tone)
+						  u8 override_set, u8 override_clear)
 {
 	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
 	return NULL;
diff --git a/drivers/media/dvb-frontends/itd1000.c b/drivers/media/dvb-frontends/itd1000.c
index cadcae4..c1c3400 100644
--- a/drivers/media/dvb-frontends/itd1000.c
+++ b/drivers/media/dvb-frontends/itd1000.c
@@ -31,9 +31,6 @@
 #include "itd1000.h"
 #include "itd1000_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static int debug;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "Turn on/off debugging (default:off).");
@@ -55,18 +52,10 @@ MODULE_PARM_DESC(debug, "Turn on/off debugging (default:off).");
 /* don't write more than one byte with flexcop behind */
 static int itd1000_write_regs(struct itd1000_state *state, u8 reg, u8 v[], u8 len)
 {
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[1+len];
 	struct i2c_msg msg = {
 		.addr = state->cfg->i2c_address, .flags = 0, .buf = buf, .len = len+1
 	};
-
-	if (1 + len > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "itd1000: i2c wr reg=%04x: len=%d is too big!\n",
-		       reg, len);
-		return -EINVAL;
-	}
-
 	buf[0] = reg;
 	memcpy(&buf[1], v, len);
 
diff --git a/drivers/media/dvb-frontends/lg2160.h b/drivers/media/dvb-frontends/lg2160.h
index 194a07a..a5f0368 100644
--- a/drivers/media/dvb-frontends/lg2160.h
+++ b/drivers/media/dvb-frontends/lg2160.h
@@ -57,10 +57,10 @@ struct lg2160_config {
 	u16 if_khz;
 
 	/* disable i2c repeater - 0:repeater enabled 1:repeater disabled */
-	unsigned int deny_i2c_rptr:1;
+	int deny_i2c_rptr:1;
 
 	/* spectral inversion - 0:disabled 1:enabled */
-	unsigned int spectral_inversion:1;
+	int spectral_inversion:1;
 
 	unsigned int output_if;
 	enum lg2160_spi_clock spi_clock;
diff --git a/drivers/media/dvb-frontends/mb86a20s.c b/drivers/media/dvb-frontends/mb86a20s.c
index 2c7217f..d04b52e 100644
--- a/drivers/media/dvb-frontends/mb86a20s.c
+++ b/drivers/media/dvb-frontends/mb86a20s.c
@@ -20,8 +20,6 @@
 #include "dvb_frontend.h"
 #include "mb86a20s.h"
 
-#define NUM_LAYERS 3
-
 static int debug = 1;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
@@ -50,7 +48,7 @@ struct mb86a20s_state {
 	bool inversion;
 	u32 subchannel;
 
-	u32 estimated_rate[NUM_LAYERS];
+	u32 estimated_rate[3];
 	unsigned long get_strength_time;
 
 	bool need_init;
@@ -157,6 +155,7 @@ static struct regdata mb86a20s_init2[] = {
 	{ 0x45, 0x04 },				/* CN symbol 4 */
 	{ 0x48, 0x04 },				/* CN manual mode */
 
+	{ 0x50, 0xd5 }, { 0x51, 0x01 },		/* Serial */
 	{ 0x50, 0xd6 }, { 0x51, 0x1f },
 	{ 0x50, 0xd2 }, { 0x51, 0x03 },
 	{ 0x50, 0xd7 }, { 0x51, 0xbf },
@@ -565,13 +564,12 @@ static u32 isdbt_rate[3][5][4] = {
 };
 
 static void mb86a20s_layer_bitrate(struct dvb_frontend *fe, u32 layer,
-				   u32 modulation, u32 forward_error_correction,
-				   u32 interleaving,
+				   u32 modulation, u32 fec, u32 interleaving,
 				   u32 segment)
 {
 	struct mb86a20s_state *state = fe->demodulator_priv;
 	u32 rate;
-	int mod, fec, guard;
+	int m, f, i;
 
 	/*
 	 * If modulation/fec/interleaving is not detected, the default is
@@ -582,54 +580,54 @@ static void mb86a20s_layer_bitrate(struct dvb_frontend *fe, u32 layer,
 	case DQPSK:
 	case QPSK:
 	default:
-		mod = 0;
+		m = 0;
 		break;
 	case QAM_16:
-		mod = 1;
+		m = 1;
 		break;
 	case QAM_64:
-		mod = 2;
+		m = 2;
 		break;
 	}
 
-	switch (forward_error_correction) {
+	switch (fec) {
 	default:
 	case FEC_1_2:
 	case FEC_AUTO:
-		fec = 0;
+		f = 0;
 		break;
 	case FEC_2_3:
-		fec = 1;
+		f = 1;
 		break;
 	case FEC_3_4:
-		fec = 2;
+		f = 2;
 		break;
 	case FEC_5_6:
-		fec = 3;
+		f = 3;
 		break;
 	case FEC_7_8:
-		fec = 4;
+		f = 4;
 		break;
 	}
 
 	switch (interleaving) {
 	default:
 	case GUARD_INTERVAL_1_4:
-		guard = 0;
+		i = 0;
 		break;
 	case GUARD_INTERVAL_1_8:
-		guard = 1;
+		i = 1;
 		break;
 	case GUARD_INTERVAL_1_16:
-		guard = 2;
+		i = 2;
 		break;
 	case GUARD_INTERVAL_1_32:
-		guard = 3;
+		i = 3;
 		break;
 	}
 
 	/* Samples BER at BER_SAMPLING_RATE seconds */
-	rate = isdbt_rate[mod][fec][guard] * segment * BER_SAMPLING_RATE;
+	rate = isdbt_rate[m][f][i] * segment * BER_SAMPLING_RATE;
 
 	/* Avoids sampling too quickly or to overflow the register */
 	if (rate < 256)
@@ -639,18 +637,18 @@ static void mb86a20s_layer_bitrate(struct dvb_frontend *fe, u32 layer,
 
 	dev_dbg(&state->i2c->dev,
 		"%s: layer %c bitrate: %d kbps; counter = %d (0x%06x)\n",
-		__func__, 'A' + layer,
-		segment * isdbt_rate[mod][fec][guard]/1000,
+	       __func__, 'A' + layer, segment * isdbt_rate[m][f][i]/1000,
 		rate, rate);
 
-	state->estimated_rate[layer] = rate;
+	state->estimated_rate[i] = rate;
 }
 
+
 static int mb86a20s_get_frontend(struct dvb_frontend *fe)
 {
 	struct mb86a20s_state *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int layer, rc;
+	int i, rc;
 
 	dev_dbg(&state->i2c->dev, "%s called.\n", __func__);
 
@@ -668,43 +666,43 @@ static int mb86a20s_get_frontend(struct dvb_frontend *fe)
 
 	/* Get per-layer data */
 
-	for (layer = 0; layer < NUM_LAYERS; layer++) {
+	for (i = 0; i < 3; i++) {
 		dev_dbg(&state->i2c->dev, "%s: getting data for layer %c.\n",
-			__func__, 'A' + layer);
+			__func__, 'A' + i);
 
-		rc = mb86a20s_get_segment_count(state, layer);
+		rc = mb86a20s_get_segment_count(state, i);
 		if (rc < 0)
 			goto noperlayer_error;
 		if (rc >= 0 && rc < 14) {
-			c->layer[layer].segment_count = rc;
+			c->layer[i].segment_count = rc;
 		} else {
-			c->layer[layer].segment_count = 0;
-			state->estimated_rate[layer] = 0;
+			c->layer[i].segment_count = 0;
+			state->estimated_rate[i] = 0;
 			continue;
 		}
-		c->isdbt_layer_enabled |= 1 << layer;
-		rc = mb86a20s_get_modulation(state, layer);
+		c->isdbt_layer_enabled |= 1 << i;
+		rc = mb86a20s_get_modulation(state, i);
 		if (rc < 0)
 			goto noperlayer_error;
 		dev_dbg(&state->i2c->dev, "%s: modulation %d.\n",
 			__func__, rc);
-		c->layer[layer].modulation = rc;
-		rc = mb86a20s_get_fec(state, layer);
+		c->layer[i].modulation = rc;
+		rc = mb86a20s_get_fec(state, i);
 		if (rc < 0)
 			goto noperlayer_error;
 		dev_dbg(&state->i2c->dev, "%s: FEC %d.\n",
 			__func__, rc);
-		c->layer[layer].fec = rc;
-		rc = mb86a20s_get_interleaving(state, layer);
+		c->layer[i].fec = rc;
+		rc = mb86a20s_get_interleaving(state, i);
 		if (rc < 0)
 			goto noperlayer_error;
 		dev_dbg(&state->i2c->dev, "%s: interleaving %d.\n",
 			__func__, rc);
-		c->layer[layer].interleaving = rc;
-		mb86a20s_layer_bitrate(fe, layer, c->layer[layer].modulation,
-				       c->layer[layer].fec,
-				       c->layer[layer].interleaving,
-				       c->layer[layer].segment_count);
+		c->layer[i].interleaving = rc;
+		mb86a20s_layer_bitrate(fe, i, c->layer[i].modulation,
+				       c->layer[i].fec,
+				       c->layer[i].interleaving,
+				       c->layer[i].segment_count);
 	}
 
 	rc = mb86a20s_writereg(state, 0x6d, 0x84);
@@ -830,7 +828,7 @@ static int mb86a20s_get_pre_ber(struct dvb_frontend *fe,
 
 	dev_dbg(&state->i2c->dev, "%s called.\n", __func__);
 
-	if (layer >= NUM_LAYERS)
+	if (layer >= 3)
 		return -EINVAL;
 
 	/* Check if the BER measures are already available */
@@ -964,7 +962,7 @@ static int mb86a20s_get_post_ber(struct dvb_frontend *fe,
 
 	dev_dbg(&state->i2c->dev, "%s called.\n", __func__);
 
-	if (layer >= NUM_LAYERS)
+	if (layer >= 3)
 		return -EINVAL;
 
 	/* Check if the BER measures are already available */
@@ -1091,7 +1089,7 @@ static int mb86a20s_get_blk_error(struct dvb_frontend *fe,
 	u32 collect_rate;
 	dev_dbg(&state->i2c->dev, "%s called.\n", __func__);
 
-	if (layer >= NUM_LAYERS)
+	if (layer >= 3)
 		return -EINVAL;
 
 	/* Check if the PER measures are already available */
@@ -1456,7 +1454,7 @@ static int mb86a20s_get_blk_error_layer_CNR(struct dvb_frontend *fe)
 	struct mb86a20s_state *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
 	u32 mer, cnr;
-	int rc, val, layer;
+	int rc, val, i;
 	struct linear_segments *segs;
 	unsigned segs_len;
 
@@ -1478,27 +1476,27 @@ static int mb86a20s_get_blk_error_layer_CNR(struct dvb_frontend *fe)
 	}
 
 	/* Read all layers */
-	for (layer = 0; layer < NUM_LAYERS; layer++) {
-		if (!(c->isdbt_layer_enabled & (1 << layer))) {
-			c->cnr.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;
+	for (i = 0; i < 3; i++) {
+		if (!(c->isdbt_layer_enabled & (1 << i))) {
+			c->cnr.stat[1 + i].scale = FE_SCALE_NOT_AVAILABLE;
 			continue;
 		}
 
-		rc = mb86a20s_writereg(state, 0x50, 0x52 + layer * 3);
+		rc = mb86a20s_writereg(state, 0x50, 0x52 + i * 3);
 		if (rc < 0)
 			return rc;
 		rc = mb86a20s_readreg(state, 0x51);
 		if (rc < 0)
 			return rc;
 		mer = rc << 16;
-		rc = mb86a20s_writereg(state, 0x50, 0x53 + layer * 3);
+		rc = mb86a20s_writereg(state, 0x50, 0x53 + i * 3);
 		if (rc < 0)
 			return rc;
 		rc = mb86a20s_readreg(state, 0x51);
 		if (rc < 0)
 			return rc;
 		mer |= rc << 8;
-		rc = mb86a20s_writereg(state, 0x50, 0x54 + layer * 3);
+		rc = mb86a20s_writereg(state, 0x50, 0x54 + i * 3);
 		if (rc < 0)
 			return rc;
 		rc = mb86a20s_readreg(state, 0x51);
@@ -1506,7 +1504,7 @@ static int mb86a20s_get_blk_error_layer_CNR(struct dvb_frontend *fe)
 			return rc;
 		mer |= rc;
 
-		switch (c->layer[layer].modulation) {
+		switch (c->layer[i].modulation) {
 		case DQPSK:
 		case QPSK:
 			segs = cnr_qpsk_table;
@@ -1524,12 +1522,12 @@ static int mb86a20s_get_blk_error_layer_CNR(struct dvb_frontend *fe)
 		}
 		cnr = interpolate_value(mer, segs, segs_len);
 
-		c->cnr.stat[1 + layer].scale = FE_SCALE_DECIBEL;
-		c->cnr.stat[1 + layer].svalue = cnr;
+		c->cnr.stat[1 + i].scale = FE_SCALE_DECIBEL;
+		c->cnr.stat[1 + i].svalue = cnr;
 
 		dev_dbg(&state->i2c->dev,
 			"%s: CNR for layer %c is %d.%03d dB (MER = %d).\n",
-			__func__, 'A' + layer, cnr / 1000, cnr % 1000, mer);
+			__func__, 'A' + i, cnr / 1000, cnr % 1000, mer);
 
 	}
 
@@ -1557,7 +1555,7 @@ static void mb86a20s_stats_not_ready(struct dvb_frontend *fe)
 {
 	struct mb86a20s_state *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int layer;
+	int i;
 
 	dev_dbg(&state->i2c->dev, "%s called.\n", __func__);
 
@@ -1567,27 +1565,27 @@ static void mb86a20s_stats_not_ready(struct dvb_frontend *fe)
 	c->strength.len = 1;
 
 	/* Per-layer stats - 3 layers + global */
-	c->cnr.len = NUM_LAYERS + 1;
-	c->pre_bit_error.len = NUM_LAYERS + 1;
-	c->pre_bit_count.len = NUM_LAYERS + 1;
-	c->post_bit_error.len = NUM_LAYERS + 1;
-	c->post_bit_count.len = NUM_LAYERS + 1;
-	c->block_error.len = NUM_LAYERS + 1;
-	c->block_count.len = NUM_LAYERS + 1;
+	c->cnr.len = 4;
+	c->pre_bit_error.len = 4;
+	c->pre_bit_count.len = 4;
+	c->post_bit_error.len = 4;
+	c->post_bit_count.len = 4;
+	c->block_error.len = 4;
+	c->block_count.len = 4;
 
 	/* Signal is always available */
 	c->strength.stat[0].scale = FE_SCALE_RELATIVE;
 	c->strength.stat[0].uvalue = 0;
 
 	/* Put all of them at FE_SCALE_NOT_AVAILABLE */
-	for (layer = 0; layer < NUM_LAYERS + 1; layer++) {
-		c->cnr.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;
-		c->pre_bit_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;
-		c->pre_bit_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;
-		c->post_bit_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;
-		c->post_bit_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;
-		c->block_error.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;
-		c->block_count.stat[layer].scale = FE_SCALE_NOT_AVAILABLE;
+	for (i = 0; i < 4; i++) {
+		c->cnr.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->pre_bit_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->pre_bit_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->post_bit_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_error.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
+		c->block_count.stat[i].scale = FE_SCALE_NOT_AVAILABLE;
 	}
 }
 
@@ -1595,7 +1593,7 @@ static int mb86a20s_get_stats(struct dvb_frontend *fe, int status_nr)
 {
 	struct mb86a20s_state *state = fe->demodulator_priv;
 	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
-	int rc = 0, layer;
+	int rc = 0, i;
 	u32 bit_error = 0, bit_count = 0;
 	u32 t_pre_bit_error = 0, t_pre_bit_count = 0;
 	u32 t_post_bit_error = 0, t_post_bit_count = 0;
@@ -1619,90 +1617,90 @@ static int mb86a20s_get_stats(struct dvb_frontend *fe, int status_nr)
 	if (status_nr < 9)
 		return 0;
 
-	for (layer = 0; layer < NUM_LAYERS; layer++) {
-		if (c->isdbt_layer_enabled & (1 << layer)) {
+	for (i = 0; i < 3; i++) {
+		if (c->isdbt_layer_enabled & (1 << i)) {
 			/* Layer is active and has rc segments */
 			active_layers++;
 
 			/* Handle BER before vterbi */
-			rc = mb86a20s_get_pre_ber(fe, layer,
+			rc = mb86a20s_get_pre_ber(fe, i,
 						  &bit_error, &bit_count);
 			if (rc >= 0) {
-				c->pre_bit_error.stat[1 + layer].scale = FE_SCALE_COUNTER;
-				c->pre_bit_error.stat[1 + layer].uvalue += bit_error;
-				c->pre_bit_count.stat[1 + layer].scale = FE_SCALE_COUNTER;
-				c->pre_bit_count.stat[1 + layer].uvalue += bit_count;
+				c->pre_bit_error.stat[1 + i].scale = FE_SCALE_COUNTER;
+				c->pre_bit_error.stat[1 + i].uvalue += bit_error;
+				c->pre_bit_count.stat[1 + i].scale = FE_SCALE_COUNTER;
+				c->pre_bit_count.stat[1 + i].uvalue += bit_count;
 			} else if (rc != -EBUSY) {
 				/*
 					* If an I/O error happened,
 					* measures are now unavailable
 					*/
-				c->pre_bit_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;
-				c->pre_bit_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;
+				c->pre_bit_error.stat[1 + i].scale = FE_SCALE_NOT_AVAILABLE;
+				c->pre_bit_count.stat[1 + i].scale = FE_SCALE_NOT_AVAILABLE;
 				dev_err(&state->i2c->dev,
 					"%s: Can't get BER for layer %c (error %d).\n",
-					__func__, 'A' + layer, rc);
+					__func__, 'A' + i, rc);
 			}
-			if (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)
+			if (c->block_error.stat[1 + i].scale != FE_SCALE_NOT_AVAILABLE)
 				pre_ber_layers++;
 
 			/* Handle BER post vterbi */
-			rc = mb86a20s_get_post_ber(fe, layer,
+			rc = mb86a20s_get_post_ber(fe, i,
 						   &bit_error, &bit_count);
 			if (rc >= 0) {
-				c->post_bit_error.stat[1 + layer].scale = FE_SCALE_COUNTER;
-				c->post_bit_error.stat[1 + layer].uvalue += bit_error;
-				c->post_bit_count.stat[1 + layer].scale = FE_SCALE_COUNTER;
-				c->post_bit_count.stat[1 + layer].uvalue += bit_count;
+				c->post_bit_error.stat[1 + i].scale = FE_SCALE_COUNTER;
+				c->post_bit_error.stat[1 + i].uvalue += bit_error;
+				c->post_bit_count.stat[1 + i].scale = FE_SCALE_COUNTER;
+				c->post_bit_count.stat[1 + i].uvalue += bit_count;
 			} else if (rc != -EBUSY) {
 				/*
 					* If an I/O error happened,
 					* measures are now unavailable
 					*/
-				c->post_bit_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;
-				c->post_bit_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;
+				c->post_bit_error.stat[1 + i].scale = FE_SCALE_NOT_AVAILABLE;
+				c->post_bit_count.stat[1 + i].scale = FE_SCALE_NOT_AVAILABLE;
 				dev_err(&state->i2c->dev,
 					"%s: Can't get BER for layer %c (error %d).\n",
-					__func__, 'A' + layer, rc);
+					__func__, 'A' + i, rc);
 			}
-			if (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)
+			if (c->block_error.stat[1 + i].scale != FE_SCALE_NOT_AVAILABLE)
 				post_ber_layers++;
 
 			/* Handle Block errors for PER/UCB reports */
-			rc = mb86a20s_get_blk_error(fe, layer,
+			rc = mb86a20s_get_blk_error(fe, i,
 						&block_error,
 						&block_count);
 			if (rc >= 0) {
-				c->block_error.stat[1 + layer].scale = FE_SCALE_COUNTER;
-				c->block_error.stat[1 + layer].uvalue += block_error;
-				c->block_count.stat[1 + layer].scale = FE_SCALE_COUNTER;
-				c->block_count.stat[1 + layer].uvalue += block_count;
+				c->block_error.stat[1 + i].scale = FE_SCALE_COUNTER;
+				c->block_error.stat[1 + i].uvalue += block_error;
+				c->block_count.stat[1 + i].scale = FE_SCALE_COUNTER;
+				c->block_count.stat[1 + i].uvalue += block_count;
 			} else if (rc != -EBUSY) {
 				/*
 					* If an I/O error happened,
 					* measures are now unavailable
 					*/
-				c->block_error.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;
-				c->block_count.stat[1 + layer].scale = FE_SCALE_NOT_AVAILABLE;
+				c->block_error.stat[1 + i].scale = FE_SCALE_NOT_AVAILABLE;
+				c->block_count.stat[1 + i].scale = FE_SCALE_NOT_AVAILABLE;
 				dev_err(&state->i2c->dev,
 					"%s: Can't get PER for layer %c (error %d).\n",
-					__func__, 'A' + layer, rc);
+					__func__, 'A' + i, rc);
 
 			}
-			if (c->block_error.stat[1 + layer].scale != FE_SCALE_NOT_AVAILABLE)
+			if (c->block_error.stat[1 + i].scale != FE_SCALE_NOT_AVAILABLE)
 				per_layers++;
 
 			/* Update total preBER */
-			t_pre_bit_error += c->pre_bit_error.stat[1 + layer].uvalue;
-			t_pre_bit_count += c->pre_bit_count.stat[1 + layer].uvalue;
+			t_pre_bit_error += c->pre_bit_error.stat[1 + i].uvalue;
+			t_pre_bit_count += c->pre_bit_count.stat[1 + i].uvalue;
 
 			/* Update total postBER */
-			t_post_bit_error += c->post_bit_error.stat[1 + layer].uvalue;
-			t_post_bit_count += c->post_bit_count.stat[1 + layer].uvalue;
+			t_post_bit_error += c->post_bit_error.stat[1 + i].uvalue;
+			t_post_bit_count += c->post_bit_count.stat[1 + i].uvalue;
 
 			/* Update total PER */
-			t_block_error += c->block_error.stat[1 + layer].uvalue;
-			t_block_count += c->block_count.stat[1 + layer].uvalue;
+			t_block_error += c->block_error.stat[1 + i].uvalue;
+			t_block_count += c->block_count.stat[1 + i].uvalue;
 		}
 	}
 
@@ -1859,15 +1857,16 @@ static int mb86a20s_initfe(struct dvb_frontend *fe)
 	dev_dbg(&state->i2c->dev, "%s: IF=%d, IF reg=0x%06llx\n",
 		__func__, state->if_freq, (long long)pll);
 
-	if (!state->config->is_serial)
+	if (!state->config->is_serial) {
 		regD5 &= ~1;
 
-	rc = mb86a20s_writereg(state, 0x50, 0xd5);
-	if (rc < 0)
-		goto err;
-	rc = mb86a20s_writereg(state, 0x51, regD5);
-	if (rc < 0)
-		goto err;
+		rc = mb86a20s_writereg(state, 0x50, 0xd5);
+		if (rc < 0)
+			goto err;
+		rc = mb86a20s_writereg(state, 0x51, regD5);
+		if (rc < 0)
+			goto err;
+	}
 
 	rc = mb86a20s_writeregdata(state, mb86a20s_init2);
 	if (rc < 0)
@@ -1914,7 +1913,7 @@ static int mb86a20s_set_frontend(struct dvb_frontend *fe)
 	if (!c->isdbt_sb_mode) {
 		state->subchannel = 0;
 	} else {
-		if (c->isdbt_sb_subchannel >= ARRAY_SIZE(mb86a20s_subchannel))
+		if (c->isdbt_sb_subchannel > ARRAY_SIZE(mb86a20s_subchannel))
 			c->isdbt_sb_subchannel = 0;
 
 		state->subchannel = mb86a20s_subchannel[c->isdbt_sb_subchannel];
diff --git a/drivers/media/dvb-frontends/mt312.c b/drivers/media/dvb-frontends/mt312.c
index a74ac0d..ec388c1d 100644
--- a/drivers/media/dvb-frontends/mt312.c
+++ b/drivers/media/dvb-frontends/mt312.c
@@ -36,8 +36,6 @@
 #include "mt312_priv.h"
 #include "mt312.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
 
 struct mt312_state {
 	struct i2c_adapter *i2c;
@@ -98,15 +96,9 @@ static int mt312_write(struct mt312_state *state, const enum mt312_reg_addr reg,
 		       const u8 *src, const size_t count)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[count + 1];
 	struct i2c_msg msg;
 
-	if (1 + count > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "mt312: write: len=%zd is too big!\n", count);
-		return -EINVAL;
-	}
-
 	if (debug) {
 		int i;
 		dprintk("W(%d):", reg & 0x7f);
diff --git a/drivers/media/dvb-frontends/nxt200x.c b/drivers/media/dvb-frontends/nxt200x.c
index 4bf0575..24e76f6 100644
--- a/drivers/media/dvb-frontends/nxt200x.c
+++ b/drivers/media/dvb-frontends/nxt200x.c
@@ -37,11 +37,9 @@
  * /usr/lib/hotplug/firmware/ or /lib/firmware/
  * (depending on configuration of firmware hotplug).
  */
+#undef pr_fmt
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  256
-
 #define NXT2002_DEFAULT_FIRMWARE "dvb-fe-nxt2002.fw"
 #define NXT2004_DEFAULT_FIRMWARE "dvb-fe-nxt2004.fw"
 #define CRC_CCIT_MASK 0x1021
@@ -98,16 +96,10 @@ static int i2c_readbytes(struct nxt200x_state *state, u8 addr, u8 *buf, u8 len)
 static int nxt200x_writebytes (struct nxt200x_state* state, u8 reg,
 			       const u8 *buf, u8 len)
 {
-	u8 buf2[MAX_XFER_SIZE];
+	u8 buf2 [len+1];
 	int err;
 	struct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf2, .len = len + 1 };
 
-	if (1 + len > sizeof(buf2)) {
-		pr_warn("%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 __func__, reg, len);
-		return -EINVAL;
-	}
-
 	buf2[0] = reg;
 	memcpy(&buf2[1], buf, len);
 
diff --git a/drivers/media/dvb-frontends/or51211.c b/drivers/media/dvb-frontends/or51211.c
index 10cfc05..a3bcbd0 100644
--- a/drivers/media/dvb-frontends/or51211.c
+++ b/drivers/media/dvb-frontends/or51211.c
@@ -22,6 +22,7 @@
  *
 */
 
+#undef pr_fmt
 #define pr_fmt(fmt)	KBUILD_MODNAME ": %s: " fmt, __func__
 
 /*
diff --git a/drivers/media/dvb-frontends/rtl2830.c b/drivers/media/dvb-frontends/rtl2830.c
index 7efb796..362d26d 100644
--- a/drivers/media/dvb-frontends/rtl2830.c
+++ b/drivers/media/dvb-frontends/rtl2830.c
@@ -27,30 +27,20 @@
 
 #include "rtl2830_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 /* write multiple hardware registers */
 static int rtl2830_wr(struct rtl2830_priv *priv, u8 reg, const u8 *val, int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[1+len];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = priv->cfg.i2c_addr,
 			.flags = 0,
-			.len = 1 + len,
+			.len = 1+len,
 			.buf = buf,
 		}
 	};
 
-	if (1 + len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 
diff --git a/drivers/media/dvb-frontends/rtl2832.c b/drivers/media/dvb-frontends/rtl2832.c
index b8dd0a1..7388769 100644
--- a/drivers/media/dvb-frontends/rtl2832.c
+++ b/drivers/media/dvb-frontends/rtl2832.c
@@ -22,9 +22,6 @@
 #include "dvb_math.h"
 #include <linux/bitops.h>
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 int rtl2832_debug;
 module_param_named(debug, rtl2832_debug, int, 0644);
 MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
@@ -165,23 +162,16 @@ static const struct rtl2832_reg_entry registers[] = {
 static int rtl2832_wr(struct rtl2832_priv *priv, u8 reg, u8 *val, int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[1+len];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = priv->cfg.i2c_addr,
 			.flags = 0,
-			.len = 1 + len,
+			.len = 1+len,
 			.buf = buf,
 		}
 	};
 
-	if (1 + len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 
@@ -390,41 +380,13 @@ static int rtl2832_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
 	return ret;
 }
 
-
-static int rtl2832_set_if(struct dvb_frontend *fe, u32 if_freq)
-{
-	struct rtl2832_priv *priv = fe->demodulator_priv;
-	int ret;
-	u64 pset_iffreq;
-	u8 en_bbin = (if_freq == 0 ? 0x1 : 0x0);
-
-	/*
-	* PSET_IFFREQ = - floor((IfFreqHz % CrystalFreqHz) * pow(2, 22)
-	*		/ CrystalFreqHz)
-	*/
-
-	pset_iffreq = if_freq % priv->cfg.xtal;
-	pset_iffreq *= 0x400000;
-	pset_iffreq = div_u64(pset_iffreq, priv->cfg.xtal);
-	pset_iffreq = -pset_iffreq;
-	pset_iffreq = pset_iffreq & 0x3fffff;
-	dev_dbg(&priv->i2c->dev, "%s: if_frequency=%d pset_iffreq=%08x\n",
-			__func__, if_freq, (unsigned)pset_iffreq);
-
-	ret = rtl2832_wr_demod_reg(priv, DVBT_EN_BBIN, en_bbin);
-	if (ret)
-		return ret;
-
-	ret = rtl2832_wr_demod_reg(priv, DVBT_PSET_IFFREQ, pset_iffreq);
-
-	return (ret);
-}
-
 static int rtl2832_init(struct dvb_frontend *fe)
 {
 	struct rtl2832_priv *priv = fe->demodulator_priv;
-	const struct rtl2832_reg_value *init;
 	int i, ret, len;
+	u8 en_bbin;
+	u64 pset_iffreq;
+	const struct rtl2832_reg_value *init;
 
 	/* initialization values for the demodulator registers */
 	struct rtl2832_reg_value rtl2832_initial_regs[] = {
@@ -470,10 +432,22 @@ static int rtl2832_init(struct dvb_frontend *fe)
 		{DVBT_TR_THD_SET2,		0x6},
 		{DVBT_TRK_KC_I2,		0x5},
 		{DVBT_CR_THD_SET2,		0x1},
+		{DVBT_SPEC_INV,			0x0},
 	};
 
 	dev_dbg(&priv->i2c->dev, "%s:\n", __func__);
 
+	en_bbin = (priv->cfg.if_dvbt == 0 ? 0x1 : 0x0);
+
+	/*
+	* PSET_IFFREQ = - floor((IfFreqHz % CrystalFreqHz) * pow(2, 22)
+	*		/ CrystalFreqHz)
+	*/
+	pset_iffreq = priv->cfg.if_dvbt % priv->cfg.xtal;
+	pset_iffreq *= 0x400000;
+	pset_iffreq = div_u64(pset_iffreq, priv->cfg.xtal);
+	pset_iffreq = pset_iffreq & 0x3fffff;
+
 	for (i = 0; i < ARRAY_SIZE(rtl2832_initial_regs); i++) {
 		ret = rtl2832_wr_demod_reg(priv, rtl2832_initial_regs[i].reg,
 			rtl2832_initial_regs[i].value);
@@ -498,10 +472,6 @@ static int rtl2832_init(struct dvb_frontend *fe)
 		len = ARRAY_SIZE(rtl2832_tuner_init_e4000);
 		init = rtl2832_tuner_init_e4000;
 		break;
-	case RTL2832_TUNER_R820T:
-		len = ARRAY_SIZE(rtl2832_tuner_init_r820t);
-		init = rtl2832_tuner_init_r820t;
-		break;
 	default:
 		ret = -EINVAL;
 		goto err;
@@ -513,26 +483,14 @@ static int rtl2832_init(struct dvb_frontend *fe)
 			goto err;
 	}
 
-	if (!fe->ops.tuner_ops.get_if_frequency) {
-		ret = rtl2832_set_if(fe, priv->cfg.if_dvbt);
+	/* if frequency settings */
+	ret = rtl2832_wr_demod_reg(priv, DVBT_EN_BBIN, en_bbin);
 		if (ret)
 			goto err;
-	}
-
-	/*
-	 * r820t NIM code does a software reset here at the demod -
-	 * may not be needed, as there's already a software reset at set_params()
-	 */
-#if 1
-	/* soft reset */
-	ret = rtl2832_wr_demod_reg(priv, DVBT_SOFT_RST, 0x1);
-	if (ret)
-		goto err;
 
-	ret = rtl2832_wr_demod_reg(priv, DVBT_SOFT_RST, 0x0);
-	if (ret)
-		goto err;
-#endif
+	ret = rtl2832_wr_demod_reg(priv, DVBT_PSET_IFFREQ, pset_iffreq);
+		if (ret)
+			goto err;
 
 	priv->sleeping = false;
 
@@ -606,19 +564,6 @@ static int rtl2832_set_frontend(struct dvb_frontend *fe)
 	if (fe->ops.tuner_ops.set_params)
 		fe->ops.tuner_ops.set_params(fe);
 
-	/* If the frontend has get_if_frequency(), use it */
-	if (fe->ops.tuner_ops.get_if_frequency) {
-		u32 if_freq;
-
-		ret = fe->ops.tuner_ops.get_if_frequency(fe, &if_freq);
-		if (ret)
-			goto err;
-
-		ret = rtl2832_set_if(fe, if_freq);
-		if (ret)
-			goto err;
-	}
-
 	switch (c->bandwidth_hz) {
 	case 6000000:
 		i = 0;
diff --git a/drivers/media/dvb-frontends/rtl2832.h b/drivers/media/dvb-frontends/rtl2832.h
index 91b2dcf..fefba0e 100644
--- a/drivers/media/dvb-frontends/rtl2832.h
+++ b/drivers/media/dvb-frontends/rtl2832.h
@@ -52,7 +52,6 @@ struct rtl2832_config {
 #define RTL2832_TUNER_FC0012    0x26
 #define RTL2832_TUNER_E4000     0x27
 #define RTL2832_TUNER_FC0013    0x29
-#define RTL2832_TUNER_R820T	0x2a
 	u8 tuner;
 };
 
diff --git a/drivers/media/dvb-frontends/rtl2832_priv.h b/drivers/media/dvb-frontends/rtl2832_priv.h
index b5f2b80..7d97ce9 100644
--- a/drivers/media/dvb-frontends/rtl2832_priv.h
+++ b/drivers/media/dvb-frontends/rtl2832_priv.h
@@ -267,7 +267,6 @@ static const struct rtl2832_reg_value rtl2832_tuner_init_tua9001[] = {
 	{DVBT_OPT_ADC_IQ,                0x1},
 	{DVBT_AD_AVI,                    0x0},
 	{DVBT_AD_AVQ,                    0x0},
-	{DVBT_SPEC_INV,			 0x0},
 };
 
 static const struct rtl2832_reg_value rtl2832_tuner_init_fc0012[] = {
@@ -301,7 +300,6 @@ static const struct rtl2832_reg_value rtl2832_tuner_init_fc0012[] = {
 	{DVBT_GI_PGA_STATE,              0x0},
 	{DVBT_EN_AGC_PGA,                0x1},
 	{DVBT_IF_AGC_MAN,                0x0},
-	{DVBT_SPEC_INV,			 0x0},
 };
 
 static const struct rtl2832_reg_value rtl2832_tuner_init_e4000[] = {
@@ -339,32 +337,6 @@ static const struct rtl2832_reg_value rtl2832_tuner_init_e4000[] = {
 	{DVBT_REG_MONSEL,                0x1},
 	{DVBT_REG_MON,                   0x1},
 	{DVBT_REG_4MSEL,                 0x0},
-	{DVBT_SPEC_INV,			 0x0},
-};
-
-static const struct rtl2832_reg_value rtl2832_tuner_init_r820t[] = {
-	{DVBT_DAGC_TRG_VAL,		0x39},
-	{DVBT_AGC_TARG_VAL_0,		0x0},
-	{DVBT_AGC_TARG_VAL_8_1,		0x40},
-	{DVBT_AAGC_LOOP_GAIN,		0x16},
-	{DVBT_LOOP_GAIN2_3_0,		0x8},
-	{DVBT_LOOP_GAIN2_4,		0x1},
-	{DVBT_LOOP_GAIN3,		0x18},
-	{DVBT_VTOP1,			0x35},
-	{DVBT_VTOP2,			0x21},
-	{DVBT_VTOP3,			0x21},
-	{DVBT_KRF1,			0x0},
-	{DVBT_KRF2,			0x40},
-	{DVBT_KRF3,			0x10},
-	{DVBT_KRF4,			0x10},
-	{DVBT_IF_AGC_MIN,		0x80},
-	{DVBT_IF_AGC_MAX,		0x7f},
-	{DVBT_RF_AGC_MIN,		0x80},
-	{DVBT_RF_AGC_MAX,		0x7f},
-	{DVBT_POLAR_RF_AGC,		0x0},
-	{DVBT_POLAR_IF_AGC,		0x0},
-	{DVBT_AD7_SETTING,		0xe9f4},
-	{DVBT_SPEC_INV,			0x1},
 };
 
 #endif /* RTL2832_PRIV_H */
diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c
index 93eeaf7..e2fec9e 100644
--- a/drivers/media/dvb-frontends/s5h1420.c
+++ b/drivers/media/dvb-frontends/s5h1420.c
@@ -836,16 +836,9 @@ static u32 s5h1420_tuner_i2c_func(struct i2c_adapter *adapter)
 static int s5h1420_tuner_i2c_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)
 {
 	struct s5h1420_state *state = i2c_get_adapdata(i2c_adap);
-	struct i2c_msg m[3];
+	struct i2c_msg m[1 + num];
 	u8 tx_open[2] = { CON_1, state->CON_1_val | 1 }; /* repeater stops once there was a stop condition */
 
-	if (1 + num > ARRAY_SIZE(m)) {
-		printk(KERN_WARNING
-		       "%s: i2c xfer: num=%d is too big!\n",
-		       KBUILD_MODNAME, num);
-		return  -EOPNOTSUPP;
-	}
-
 	memset(m, 0, sizeof(struct i2c_msg) * (1 + num));
 
 	m[0].addr = state->config->demod_address;
@@ -854,7 +847,7 @@ static int s5h1420_tuner_i2c_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c
 
 	memcpy(&m[1], msg, sizeof(struct i2c_msg) * num);
 
-	return i2c_transfer(state->i2c, m, 1 + num) == 1 + num ? num : -EIO;
+	return i2c_transfer(state->i2c, m, 1+num) == 1 + num ? num : -EIO;
 }
 
 static struct i2c_algorithm s5h1420_tuner_i2c_algo = {
diff --git a/drivers/media/dvb-frontends/stb0899_drv.c b/drivers/media/dvb-frontends/stb0899_drv.c
index 2a979cf..cc278b3 100644
--- a/drivers/media/dvb-frontends/stb0899_drv.c
+++ b/drivers/media/dvb-frontends/stb0899_drv.c
@@ -32,9 +32,6 @@
 #include "stb0899_priv.h"
 #include "stb0899_reg.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static unsigned int verbose = 0;//1;
 module_param(verbose, int, 0644);
 
@@ -502,7 +499,7 @@ int stb0899_read_regs(struct stb0899_state *state, unsigned int reg, u8 *buf, u3
 int stb0899_write_regs(struct stb0899_state *state, unsigned int reg, u8 *data, u32 count)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[2 + count];
 	struct i2c_msg i2c_msg = {
 		.addr	= state->config->demod_address,
 		.flags	= 0,
@@ -510,13 +507,6 @@ int stb0899_write_regs(struct stb0899_state *state, unsigned int reg, u8 *data,
 		.len	= 2 + count
 	};
 
-	if (2 + count > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr reg=%04x: len=%d is too big!\n",
-		       KBUILD_MODNAME, reg, count);
-		return -EINVAL;
-	}
-
 	buf[0] = reg >> 8;
 	buf[1] = reg & 0xff;
 	memcpy(&buf[2], data, count);
diff --git a/drivers/media/dvb-frontends/stb6100.c b/drivers/media/dvb-frontends/stb6100.c
index cea175d..45f9523 100644
--- a/drivers/media/dvb-frontends/stb6100.c
+++ b/drivers/media/dvb-frontends/stb6100.c
@@ -31,8 +31,6 @@
 static unsigned int verbose;
 module_param(verbose, int, 0644);
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
 
 #define FE_ERROR		0
 #define FE_NOTICE		1
@@ -185,7 +183,7 @@ static int stb6100_read_reg(struct stb6100_state *state, u8 reg)
 static int stb6100_write_reg_range(struct stb6100_state *state, u8 buf[], int start, int len)
 {
 	int rc;
-	u8 cmdbuf[MAX_XFER_SIZE];
+	u8 cmdbuf[len + 1];
 	struct i2c_msg msg = {
 		.addr	= state->config->tuner_address,
 		.flags	= 0,
@@ -193,13 +191,6 @@ static int stb6100_write_reg_range(struct stb6100_state *state, u8 buf[], int st
 		.len	= len + 1
 	};
 
-	if (1 + len > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr: len=%d is too big!\n",
-		       KBUILD_MODNAME, len);
-		return -EINVAL;
-	}
-
 	if (unlikely(start < 1 || start + len > STB6100_NUMREGS)) {
 		dprintk(verbose, FE_ERROR, 1, "Invalid register range %d:%d",
 			start, len);
diff --git a/drivers/media/dvb-frontends/stv0367.c b/drivers/media/dvb-frontends/stv0367.c
index f6c7277..0c8e459 100644
--- a/drivers/media/dvb-frontends/stv0367.c
+++ b/drivers/media/dvb-frontends/stv0367.c
@@ -33,9 +33,6 @@
 #include "stv0367_regs.h"
 #include "stv0367_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static int stvdebug;
 module_param_named(debug, stvdebug, int, 0644);
 
@@ -770,7 +767,7 @@ static struct st_register def0367cab[STV0367CAB_NBREGS] = {
 static
 int stv0367_writeregs(struct stv0367_state *state, u16 reg, u8 *data, int len)
 {
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[len + 2];
 	struct i2c_msg msg = {
 		.addr = state->config->demod_address,
 		.flags = 0,
@@ -779,14 +776,6 @@ int stv0367_writeregs(struct stv0367_state *state, u16 reg, u8 *data, int len)
 	};
 	int ret;
 
-	if (2 + len > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr reg=%04x: len=%d is too big!\n",
-		       KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
-
 	buf[0] = MSB(reg);
 	buf[1] = LSB(reg);
 	memcpy(buf + 2, data, len);
diff --git a/drivers/media/dvb-frontends/stv090x.c b/drivers/media/dvb-frontends/stv090x.c
index 23e872f..56d470a 100644
--- a/drivers/media/dvb-frontends/stv090x.c
+++ b/drivers/media/dvb-frontends/stv090x.c
@@ -35,9 +35,6 @@
 #include "stv090x.h"
 #include "stv090x_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static unsigned int verbose;
 module_param(verbose, int, 0644);
 
@@ -725,16 +722,9 @@ static int stv090x_write_regs(struct stv090x_state *state, unsigned int reg, u8
 {
 	const struct stv090x_config *config = state->config;
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[2 + count];
 	struct i2c_msg i2c_msg = { .addr = config->address, .flags = 0, .buf = buf, .len = 2 + count };
 
-	if (2 + count > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr reg=%04x: len=%d is too big!\n",
-		       KBUILD_MODNAME, reg, count);
-		return -EINVAL;
-	}
-
 	buf[0] = reg >> 8;
 	buf[1] = reg & 0xff;
 	memcpy(&buf[2], data, count);
diff --git a/drivers/media/dvb-frontends/stv6110.c b/drivers/media/dvb-frontends/stv6110.c
index b142583..20b5fa9 100644
--- a/drivers/media/dvb-frontends/stv6110.c
+++ b/drivers/media/dvb-frontends/stv6110.c
@@ -30,9 +30,6 @@
 
 #include "stv6110.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static int debug;
 
 struct stv6110_priv {
@@ -71,7 +68,7 @@ static int stv6110_write_regs(struct dvb_frontend *fe, u8 buf[],
 {
 	struct stv6110_priv *priv = fe->tuner_priv;
 	int rc;
-	u8 cmdbuf[MAX_XFER_SIZE];
+	u8 cmdbuf[len + 1];
 	struct i2c_msg msg = {
 		.addr	= priv->i2c_address,
 		.flags	= 0,
@@ -81,13 +78,6 @@ static int stv6110_write_regs(struct dvb_frontend *fe, u8 buf[],
 
 	dprintk("%s\n", __func__);
 
-	if (1 + len > sizeof(cmdbuf)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr: len=%d is too big!\n",
-		       KBUILD_MODNAME, len);
-		return -EINVAL;
-	}
-
 	if (start + len > 8)
 		return -EINVAL;
 
diff --git a/drivers/media/dvb-frontends/stv6110x.c b/drivers/media/dvb-frontends/stv6110x.c
index e66154e..f36cab1 100644
--- a/drivers/media/dvb-frontends/stv6110x.c
+++ b/drivers/media/dvb-frontends/stv6110x.c
@@ -32,9 +32,6 @@
 #include "stv6110x.h"
 #include "stv6110x_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static unsigned int verbose;
 module_param(verbose, int, 0644);
 MODULE_PARM_DESC(verbose, "Set Verbosity level");
@@ -64,8 +61,7 @@ static int stv6110x_write_regs(struct stv6110x_state *stv6110x, int start, u8 da
 {
 	int ret;
 	const struct stv6110x_config *config = stv6110x->config;
-	u8 buf[MAX_XFER_SIZE];
-
+	u8 buf[len + 1];
 	struct i2c_msg msg = {
 		.addr = config->addr,
 		.flags = 0,
@@ -73,13 +69,6 @@ static int stv6110x_write_regs(struct stv6110x_state *stv6110x, int start, u8 da
 		.len = len + 1
 	};
 
-	if (1 + len > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr: len=%d is too big!\n",
-		       KBUILD_MODNAME, len);
-		return -EINVAL;
-	}
-
 	if (start + len > 8)
 		return -EINVAL;
 
diff --git a/drivers/media/dvb-frontends/tda10071.c b/drivers/media/dvb-frontends/tda10071.c
index def7812..51e9175 100644
--- a/drivers/media/dvb-frontends/tda10071.c
+++ b/drivers/media/dvb-frontends/tda10071.c
@@ -20,9 +20,6 @@
 
 #include "tda10071_priv.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static struct dvb_frontend_ops tda10071_ops;
 
 /* write multiple registers */
@@ -30,23 +27,16 @@ static int tda10071_wr_regs(struct tda10071_priv *priv, u8 reg, u8 *val,
 	int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[len+1];
 	struct i2c_msg msg[1] = {
 		{
 			.addr = priv->cfg.demod_i2c_addr,
 			.flags = 0,
-			.len = 1 + len,
+			.len = sizeof(buf),
 			.buf = buf,
 		}
 	};
 
-	if (1 + len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	buf[0] = reg;
 	memcpy(&buf[1], val, len);
 
@@ -66,7 +56,7 @@ static int tda10071_rd_regs(struct tda10071_priv *priv, u8 reg, u8 *val,
 	int len)
 {
 	int ret;
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[len];
 	struct i2c_msg msg[2] = {
 		{
 			.addr = priv->cfg.demod_i2c_addr,
@@ -76,18 +66,11 @@ static int tda10071_rd_regs(struct tda10071_priv *priv, u8 reg, u8 *val,
 		}, {
 			.addr = priv->cfg.demod_i2c_addr,
 			.flags = I2C_M_RD,
-			.len = len,
+			.len = sizeof(buf),
 			.buf = buf,
 		}
 	};
 
-	if (len > sizeof(buf)) {
-		dev_warn(&priv->i2c->dev,
-			 "%s: i2c wr reg=%04x: len=%d is too big!\n",
-			 KBUILD_MODNAME, reg, len);
-		return -EINVAL;
-	}
-
 	ret = i2c_transfer(priv->i2c, msg, 2);
 	if (ret == 2) {
 		memcpy(val, buf, len);
diff --git a/drivers/media/dvb-frontends/tda18271c2dd.c b/drivers/media/dvb-frontends/tda18271c2dd.c
index 2c54586..d281f77 100644
--- a/drivers/media/dvb-frontends/tda18271c2dd.c
+++ b/drivers/media/dvb-frontends/tda18271c2dd.c
@@ -34,9 +34,6 @@
 #include "dvb_frontend.h"
 #include "tda18271c2dd.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 struct SStandardParam {
 	s32   m_IFFrequency;
 	u32   m_BandWidth;
@@ -142,18 +139,11 @@ static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
 static int WriteRegs(struct tda_state *state,
 		     u8 SubAddr, u8 *Regs, u16 nRegs)
 {
-	u8 data[MAX_XFER_SIZE];
-
-	if (1 + nRegs > sizeof(data)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr: len=%d is too big!\n",
-		       KBUILD_MODNAME, nRegs);
-		return -EINVAL;
-	}
+	u8 data[nRegs+1];
 
 	data[0] = SubAddr;
 	memcpy(data + 1, Regs, nRegs);
-	return i2c_write(state->i2c, state->adr, data, nRegs + 1);
+	return i2c_write(state->i2c, state->adr, data, nRegs+1);
 }
 
 static int WriteReg(struct tda_state *state, u8 SubAddr, u8 Reg)
diff --git a/drivers/media/dvb-frontends/ts2022.c b/drivers/media/dvb-frontends/ts2022.c
new file mode 100644
index 0000000..b09317c
--- /dev/null
+++ b/drivers/media/dvb-frontends/ts2022.c
@@ -0,0 +1,452 @@
+  /*
+     Driver for Montage ts2022 DVBS/S2 Silicon tuner
+
+     Copyright (C) 2012 Tomazzo Muzumici
+
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+     GNU General Public License for more details.
+
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+  */
+
+#include "dvb_frontend.h"
+#include "ts2022.h"
+
+static int debug;
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(KERN_DEBUG "ts2022: " args); \
+	} while (0)
+
+#define TS2022_XTAL_FREQ   27000 /* in kHz */
+
+struct ts2022_priv {
+	/* i2c details */
+	int i2c_address;
+	struct i2c_adapter *i2c;
+	u32 frequency;
+};
+
+static int ts2022_release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int ts2022_writereg(struct dvb_frontend *fe, int reg, int data)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg[] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.buf = buf,
+			.len = 2
+		}
+	};
+	int err;
+
+	dprintk("%s: write reg 0x%02x, value 0x%02x\n", __func__, reg, data);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	err = i2c_transfer(priv->i2c, msg, 1);
+	if (err != 1) {
+		printk("%s: writereg error(err == %i, reg == 0x%02x,"
+		" value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+}
+
+static int ts2022_readreg(struct dvb_frontend *fe, u8 reg)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.buf = b0,
+			.len = 1
+		}, {
+			.addr = priv->i2c_address,
+			.flags = I2C_M_RD,
+			.buf = b1,
+			.len = 1
+		}
+	};
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	dprintk("%s: read reg 0x%02x, value 0x%02x\n", __func__, reg, b1[0]);
+	
+	return b1[0];
+}
+
+static int ts2022_sleep(struct dvb_frontend *fe)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	int ret;
+	u8 buf[] = { 10, 0 };
+	struct i2c_msg msg = {
+		.addr = priv->i2c_address,
+		.flags = 0,
+		.buf = buf,
+		.len = 2
+	};
+
+	dprintk("%s:\n", __func__);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = i2c_transfer(priv->i2c, &msg, 1);
+	if (ret != 1)
+		dprintk("%s: i2c error\n", __func__);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return (ret == 1) ? 0 : ret;
+}
+
+static int ts2022_set_params(struct dvb_frontend *fe)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 mlpf, mlpf_new, mlpf_max, mlpf_min, nlpf, div4;
+	u16 value, ndiv;
+	u32 f3db;
+
+	dprintk("%s:\n", __func__);
+
+	ts2022_writereg(fe, 0x10, 0x0b);
+	ts2022_writereg(fe, 0x11, 0x40);
+	div4 = 0;
+	if (c->frequency < 1103000) {
+		ts2022_writereg(fe, 0x10, 0x1b);
+		div4 = 1;
+		ndiv = (c->frequency * (6 + 8) * 4)/TS2022_XTAL_FREQ ;
+	} else
+		ndiv = (c->frequency * (6 + 8) * 2)/TS2022_XTAL_FREQ ;
+
+	ndiv = ndiv + ndiv %2 ;
+	if (ndiv < 4095)
+		value = ndiv - 1024;
+	else if (ndiv < 6143 )
+		value = ndiv + 1024;
+	else
+		value = ndiv + 3072;
+
+	ts2022_writereg(fe, 0x01, (value & 0x3f00) >> 8);
+	ts2022_writereg(fe, 0x02, value & 0x00ff);
+	ts2022_writereg(fe, 0x03, 0x06);
+	ts2022_writereg(fe, 0x51, 0x0f);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x10);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	value =  ts2022_readreg(fe, 0x14);
+	value &=0x7f;
+	if (value < 64 ) {
+		value =  ts2022_readreg(fe, 0x10);
+		value |= 0x80;
+		ts2022_writereg(fe, 0x10, value);
+		ts2022_writereg(fe, 0x11, 0x6f);
+
+		ts2022_writereg(fe, 0x51, 0x0f);
+		ts2022_writereg(fe, 0x51, 0x1f);
+		ts2022_writereg(fe, 0x50, 0x10);
+		ts2022_writereg(fe, 0x50, 0x00);
+	}
+	msleep(5);
+	value =  ts2022_readreg(fe, 0x14);
+	value &=0x1f;
+	if (value > 19) {
+		value =  ts2022_readreg(fe, 0x10);
+		value &= 0x1d;
+		ts2022_writereg(fe, 0x10, value);
+	}
+	/*set the RF gain*/
+	ts2022_writereg(fe, 0x60, 0x79);
+
+	ts2022_writereg(fe, 0x51, 0x17);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x08);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	ts2022_writereg(fe, 0x25, 0x00);
+	ts2022_writereg(fe, 0x27, 0x70);
+	ts2022_writereg(fe, 0x41, 0x09);
+
+	ts2022_writereg(fe, 0x08, 0x0b);
+	ts2022_writereg(fe, 0x04, 0x2e);
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	f3db = ((c->symbol_rate / 1000) * 135) / 200 + 2000;
+	if ((c->symbol_rate / 1000) < 5000)
+		f3db += 3000;
+	if (f3db < 7000)
+		f3db = 7000;
+	if (f3db > 40000)
+		f3db = 40000;
+
+	value = ts2022_readreg(fe, 0x26);
+	value &= 0x3f ;
+
+	ts2022_writereg(fe, 0x41, 0x0d);
+
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+	value = (value + (ts2022_readreg(fe, 0x26) & 0x3f)) / 2;
+	mlpf = 0x2e * 207 / ((value << 1) + 151);
+	mlpf_max = mlpf * 135 / 100;
+	mlpf_min = mlpf * 78 / 100;
+	if (mlpf_max > 63)
+		mlpf_max = 63;
+
+
+		value = 3200;
+	nlpf = ((mlpf * f3db * 1000) + (value * TS2022_XTAL_FREQ / 2))
+			/ (value * TS2022_XTAL_FREQ);
+
+	if (nlpf > 23)
+		nlpf = 23;
+	if (nlpf < 1)
+		nlpf = 1;
+
+	/* rounded to the closest integer */
+	mlpf_new = ((TS2022_XTAL_FREQ * nlpf * value) +
+			(1000 * f3db / 2)) / (1000 * f3db);
+
+	if (mlpf_new < mlpf_min) {
+		nlpf++;
+		mlpf_new = ((TS2022_XTAL_FREQ * nlpf * value) +
+				(1000 * f3db / 2)) / (1000 * f3db);
+	}
+
+	if (mlpf_new > mlpf_max)
+		mlpf_new = mlpf_max;
+
+	ts2022_writereg(fe, 0x04, mlpf_new);
+	ts2022_writereg(fe, 0x06, nlpf);
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	value = ts2022_readreg(fe, 0x26);
+	value &= 0x3f;
+	ts2022_writereg(fe, 0x41, 0x09);
+
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+	value = (value + (ts2022_readreg(fe, 0x26)&0x3f))/2;
+
+	value |= 0x80;
+	ts2022_writereg(fe, 0x25, value);
+	ts2022_writereg(fe, 0x27, 0x30);
+	ts2022_writereg(fe, 0x08, 0x09);
+	ts2022_writereg(fe, 0x51, 0x1e);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x01);
+	ts2022_writereg(fe, 0x50, 0x00);
+
+	msleep(60);
+
+	priv->frequency = (u32)(ndiv * TS2022_XTAL_FREQ / (6 + 8) / (div4 + 1) / 2);
+
+	printk("%s: offset %dkhz\n", __func__, priv->frequency - c->frequency);
+	printk("%s:  %dkhz  %dkhz\n", __func__, c->frequency, priv->frequency);
+
+	return 0;
+}
+
+static int ts2022_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	*frequency = priv->frequency;
+	return 0;
+}
+
+static int ts2022_init(struct dvb_frontend *fe)
+{
+	ts2022_writereg(fe, 0x62, 0xec);
+	ts2022_writereg(fe, 0x42, 0x6c);
+	
+	ts2022_writereg(fe, 0x7d, 0x9d);
+	ts2022_writereg(fe, 0x7c, 0x9a);
+	ts2022_writereg(fe, 0x7a, 0x76);
+	
+	ts2022_writereg(fe, 0x3b, 0x01);
+	ts2022_writereg(fe, 0x63, 0x88);
+	
+	ts2022_writereg(fe, 0x61, 0x85);
+	ts2022_writereg(fe, 0x22, 0x30);
+	ts2022_writereg(fe, 0x30, 0x40);
+	ts2022_writereg(fe, 0x20, 0x23);
+	ts2022_writereg(fe, 0x24, 0x02);
+	ts2022_writereg(fe, 0x12, 0xa0);
+
+	return 0;
+}
+
+static int ts2022_read_signal_strength(struct dvb_frontend *fe,
+				       u16 *signal_strength)
+{
+	int sig_reading = 0; 
+	u8 rfgain, bbgain, nngain;
+	u8 rfagc;
+	u32 gain = 0;
+	dprintk("%s()\n", __func__);
+	
+	rfgain = ts2022_readreg(fe, 0x3d) & 0x1f;
+	bbgain = ts2022_readreg(fe, 0x21) & 0x1f;
+	rfagc = ts2022_readreg(fe, 0x3f);
+	sig_reading = rfagc * 16 -670;
+	if (sig_reading<0)
+		sig_reading =0;
+	nngain =ts2022_readreg(fe, 0x66);
+	nngain = (nngain >> 3) & 0x07;
+	
+	if (rfgain < 0)
+		rfgain = 0;
+	if (rfgain > 15)
+		rfgain = 15;
+	if (bbgain < 2)
+		bbgain = 2;
+	if (bbgain > 16)
+		bbgain = 16;
+	if (nngain < 0)
+		nngain = 0;
+	if (nngain > 6)
+		nngain = 6;
+	
+	if (sig_reading < 600)
+		sig_reading = 600;
+	if (sig_reading > 1600)
+		sig_reading = 1600;
+	
+	gain = (u16) rfgain * 265 + (u16) bbgain * 338 + (u16) nngain * 285 + sig_reading * 176 / 100 - 3000;
+	
+	
+	*signal_strength = gain*100;
+	
+	dprintk("%s: raw / cooked = 0x%04x / 0x%04x\n", __func__,
+		sig_reading, *signal_strength);
+	
+	return 0;
+}
+
+static struct dvb_tuner_ops ts2022_tuner_ops = {
+	.info = {
+		.name = "TS2022",
+		.frequency_min = 950000,
+		.frequency_max = 2150000
+	},
+	.init = ts2022_init,
+	.release = ts2022_release,
+	.sleep = ts2022_sleep,
+	.set_params = ts2022_set_params,
+	.get_frequency = ts2022_get_frequency,
+	.get_rf_strength = ts2022_read_signal_strength,
+};
+
+struct dvb_frontend *ts2022_attach(struct dvb_frontend *fe, int addr,
+						struct i2c_adapter *i2c)
+{
+	struct ts2022_priv *priv = NULL;
+	u8 buf;
+
+	dprintk("%s:\n", __func__);
+
+	priv = kzalloc(sizeof(struct ts2022_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+
+	priv->i2c_address = addr;
+	priv->i2c = i2c;
+	fe->tuner_priv = priv;
+
+	/* Wake Up the tuner */
+	buf = ts2022_readreg(fe, 0x00);
+	buf &= 0x03;
+	
+	if (buf == 0x00) {
+		ts2022_writereg(fe, 0x00, 0x01);
+		msleep(2);
+	}
+
+	ts2022_writereg(fe, 0x00, 0x03);
+	msleep(2);
+	
+	/* Check the tuner version */
+	buf = ts2022_readreg(fe, 0x00);
+	if ((buf == 0xc3)|| (buf == 0x83))
+		dprintk(KERN_INFO "%s: Find tuner TS2022!\n", __func__);
+	else {
+		dprintk(KERN_ERR "%s: Read tuner reg[0] = %d\n", __func__, buf);
+		kfree(priv);
+		return NULL;
+	}
+
+	memcpy(&fe->ops.tuner_ops, &ts2022_tuner_ops,
+				sizeof(struct dvb_tuner_ops));
+	fe->ops.read_signal_strength = fe->ops.tuner_ops.get_rf_strength;
+
+	return fe;
+}
+EXPORT_SYMBOL(ts2022_attach);
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+MODULE_DESCRIPTION("DVB ts2022 driver");
+MODULE_AUTHOR("Tomazzo Muzumici");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb-frontends/ts2022.h b/drivers/media/dvb-frontends/ts2022.h
new file mode 100644
index 0000000..618f0d1
--- /dev/null
+++ b/drivers/media/dvb-frontends/ts2022.h
@@ -0,0 +1,50 @@
+  /*
+     Driver for Montage TS2022 DVBS/S2 Silicon tuner
+
+     Copyright (C) 2012 Tomazzo Muzumici
+
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+     GNU General Public License for more details.
+
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+  */
+
+#ifndef TS2022_H
+#define TS2022_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+
+/**
+ * Attach a ts2022 tuner to the supplied frontend structure.
+ *
+ * @param fe Frontend to attach to.
+ * @param addr i2c address of the tuner.
+ * @param i2c i2c adapter to use.
+ * @return FE pointer on success, NULL on failure.
+ */
+#if IS_ENABLED(CONFIG_DVB_TS2022)
+extern struct dvb_frontend *ts2022_attach(struct dvb_frontend *fe, int addr,
+					   struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *ts2022_attach(struct dvb_frontend *fe,
+						  int addr,
+						  struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_TS2022 */
+
+#endif /* TS2022_H */
diff --git a/drivers/media/dvb-frontends/zl10039.c b/drivers/media/dvb-frontends/zl10039.c
index 91b6b2e..eff9c5f 100644
--- a/drivers/media/dvb-frontends/zl10039.c
+++ b/drivers/media/dvb-frontends/zl10039.c
@@ -30,9 +30,6 @@
 
 static int debug;
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 #define dprintk(args...) \
 	do { \
 		if (debug) \
@@ -101,7 +98,7 @@ static int zl10039_write(struct zl10039_state *state,
 			const enum zl10039_reg_addr reg, const u8 *src,
 			const size_t count)
 {
-	u8 buf[MAX_XFER_SIZE];
+	u8 buf[count + 1];
 	struct i2c_msg msg = {
 		.addr = state->i2c_addr,
 		.flags = 0,
@@ -109,13 +106,6 @@ static int zl10039_write(struct zl10039_state *state,
 		.len = count + 1,
 	};
 
-	if (1 + count > sizeof(buf)) {
-		printk(KERN_WARNING
-		       "%s: i2c wr reg=%04x: len=%zd is too big!\n",
-		       KBUILD_MODNAME, reg, count);
-		return -EINVAL;
-	}
-
 	dprintk("%s\n", __func__);
 	/* Write register address and data in one go */
 	buf[0] = reg;
diff --git a/drivers/media/usb/dvb-usb/Kconfig b/drivers/media/usb/dvb-usb/Kconfig
index c5d9566..e0bef50 100644
--- a/drivers/media/usb/dvb-usb/Kconfig
+++ b/drivers/media/usb/dvb-usb/Kconfig
@@ -276,6 +276,8 @@ config DVB_USB_DW2102
 	select DVB_STV6110 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0900 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_M88RS2000 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_DS3103 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_TS2022 if MEDIA_SUBDRV_AUTOSELECT
 	help
 	  Say Y here to support the DvbWorld, TeVii, Prof DVB-S/S2 USB2.0
 	  receivers.
diff --git a/drivers/media/usb/dvb-usb/cxusb.c b/drivers/media/usb/dvb-usb/cxusb.c
index a1c641e..0194682 100644
--- a/drivers/media/usb/dvb-usb/cxusb.c
+++ b/drivers/media/usb/dvb-usb/cxusb.c
@@ -43,9 +43,6 @@
 #include "lgs8gxx.h"
 #include "atbm8830.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 /* debug */
 static int dvb_usb_cxusb_debug;
 module_param_named(debug, dvb_usb_cxusb_debug, int, 0644);
@@ -60,14 +57,7 @@ static int cxusb_ctrl_msg(struct dvb_usb_device *d,
 			  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)
 {
 	int wo = (rbuf == NULL || rlen == 0); /* write-only */
-	u8 sndbuf[MAX_XFER_SIZE];
-
-	if (1 + wlen > sizeof(sndbuf)) {
-		warn("i2c wr: len=%d is too big!\n",
-		     wlen);
-		return -EOPNOTSUPP;
-	}
-
+	u8 sndbuf[1+wlen];
 	memset(sndbuf, 0, 1+wlen);
 
 	sndbuf[0] = cmd;
@@ -169,14 +159,7 @@ static int cxusb_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 
 		if (msg[i].flags & I2C_M_RD) {
 			/* read only */
-			u8 obuf[3], ibuf[MAX_XFER_SIZE];
-
-			if (1 + msg[i].len > sizeof(ibuf)) {
-				warn("i2c rd: len=%d is too big!\n",
-				     msg[i].len);
-				ret = -EOPNOTSUPP;
-				goto unlock;
-			}
+			u8 obuf[3], ibuf[1+msg[i].len];
 			obuf[0] = 0;
 			obuf[1] = msg[i].len;
 			obuf[2] = msg[i].addr;
@@ -190,20 +173,7 @@ static int cxusb_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 		} else if (i+1 < num && (msg[i+1].flags & I2C_M_RD) &&
 			   msg[i].addr == msg[i+1].addr) {
 			/* write to then read from same address */
-			u8 obuf[MAX_XFER_SIZE], ibuf[MAX_XFER_SIZE];
-
-			if (3 + msg[i].len > sizeof(obuf)) {
-				warn("i2c wr: len=%d is too big!\n",
-				     msg[i].len);
-				ret = -EOPNOTSUPP;
-				goto unlock;
-			}
-			if (1 + msg[i + 1].len > sizeof(ibuf)) {
-				warn("i2c rd: len=%d is too big!\n",
-				     msg[i + 1].len);
-				ret = -EOPNOTSUPP;
-				goto unlock;
-			}
+			u8 obuf[3+msg[i].len], ibuf[1+msg[i+1].len];
 			obuf[0] = msg[i].len;
 			obuf[1] = msg[i+1].len;
 			obuf[2] = msg[i].addr;
@@ -222,14 +192,7 @@ static int cxusb_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 			i++;
 		} else {
 			/* write only */
-			u8 obuf[MAX_XFER_SIZE], ibuf;
-
-			if (2 + msg[i].len > sizeof(obuf)) {
-				warn("i2c wr: len=%d is too big!\n",
-				     msg[i].len);
-				ret = -EOPNOTSUPP;
-				goto unlock;
-			}
+			u8 obuf[2+msg[i].len], ibuf;
 			obuf[0] = msg[i].addr;
 			obuf[1] = msg[i].len;
 			memcpy(&obuf[2], msg[i].buf, msg[i].len);
diff --git a/drivers/media/usb/dvb-usb/dib0700_devices.c b/drivers/media/usb/dvb-usb/dib0700_devices.c
index f081360..1179842 100644
--- a/drivers/media/usb/dvb-usb/dib0700_devices.c
+++ b/drivers/media/usb/dvb-usb/dib0700_devices.c
@@ -1431,22 +1431,13 @@ static int dib8090_get_adc_power(struct dvb_frontend *fe)
 	return dib8000_get_adc_power(fe, 1);
 }
 
-static void dib8090_agc_control(struct dvb_frontend *fe, u8 restart)
-{
-	deb_info("AGC control callback: %i\n", restart);
-	dib0090_dcc_freq(fe, restart);
-
-	if (restart == 0) /* before AGC startup */
-		dib0090_set_dc_servo(fe, 1);
-}
-
 static struct dib8000_config dib809x_dib8000_config[2] = {
 	{
 	.output_mpeg2_in_188_bytes = 1,
 
 	.agc_config_count = 2,
 	.agc = dib8090_agc_config,
-	.agc_control = dib8090_agc_control,
+	.agc_control = dib0090_dcc_freq,
 	.pll = &dib8090_pll_config_12mhz,
 	.tuner_is_baseband = 1,
 
@@ -1465,7 +1456,7 @@ static struct dib8000_config dib809x_dib8000_config[2] = {
 
 	.agc_config_count = 2,
 	.agc = dib8090_agc_config,
-	.agc_control = dib8090_agc_control,
+	.agc_control = dib0090_dcc_freq,
 	.pll = &dib8090_pll_config_12mhz,
 	.tuner_is_baseband = 1,
 
@@ -1513,89 +1504,28 @@ static struct dib0090_config dib809x_dib0090_config = {
 	.fref_clock_ratio = 6,
 };
 
-static u8 dib8090_compute_pll_parameters(struct dvb_frontend *fe)
-{
-	u8 optimal_pll_ratio = 20;
-	u32 freq_adc, ratio, rest, max = 0;
-	u8 pll_ratio;
-
-	for (pll_ratio = 17; pll_ratio <= 20; pll_ratio++) {
-		freq_adc = 12 * pll_ratio * (1 << 8) / 16;
-		ratio = ((fe->dtv_property_cache.frequency / 1000) * (1 << 8) / 1000) / freq_adc;
-		rest = ((fe->dtv_property_cache.frequency / 1000) * (1 << 8) / 1000) - ratio * freq_adc;
-
-		if (rest > freq_adc / 2)
-			rest = freq_adc - rest;
-		deb_info("PLL ratio=%i rest=%i\n", pll_ratio, rest);
-		if ((rest > max) && (rest > 717)) {
-			optimal_pll_ratio = pll_ratio;
-			max = rest;
-		}
-	}
-	deb_info("optimal PLL ratio=%i\n", optimal_pll_ratio);
-
-	return optimal_pll_ratio;
-}
-
 static int dib8096_set_param_override(struct dvb_frontend *fe)
 {
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	struct dvb_usb_adapter *adap = fe->dvb->priv;
 	struct dib0700_adapter_state *state = adap->priv;
-	u8 pll_ratio, band = BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency / 1000);
-	u16 target, ltgain, rf_gain_limit;
-	u32 timf;
+	u8 band = BAND_OF_FREQUENCY(p->frequency/1000);
+	u16 target;
 	int ret = 0;
 	enum frontend_tune_state tune_state = CT_SHUTDOWN;
-
-	switch (band) {
-	default:
-			deb_info("Warning : Rf frequency  (%iHz) is not in the supported range, using VHF switch ", fe->dtv_property_cache.frequency);
-	case BAND_VHF:
-			dib8000_set_gpio(fe, 3, 0, 1);
-			break;
-	case BAND_UHF:
-			dib8000_set_gpio(fe, 3, 0, 0);
-			break;
-	}
+	u16 ltgain, rf_gain_limit;
 
 	ret = state->set_param_save(fe);
 	if (ret < 0)
 		return ret;
 
-	if (fe->dtv_property_cache.bandwidth_hz != 6000000) {
-		deb_info("only 6MHz bandwidth is supported\n");
-		return -EINVAL;
-	}
-
-	/** Update PLL if needed ratio **/
-	dib8000_update_pll(fe, &dib8090_pll_config_12mhz, fe->dtv_property_cache.bandwidth_hz / 1000, 0);
-
-	/** Get optimize PLL ratio to remove spurious **/
-	pll_ratio = dib8090_compute_pll_parameters(fe);
-	if (pll_ratio == 17)
-		timf = 21387946;
-	else if (pll_ratio == 18)
-		timf = 20199727;
-	else if (pll_ratio == 19)
-		timf = 19136583;
-	else
-		timf = 18179756;
-
-	/** Update ratio **/
-	dib8000_update_pll(fe, &dib8090_pll_config_12mhz, fe->dtv_property_cache.bandwidth_hz / 1000, pll_ratio);
-
-	dib8000_ctrl_timf(fe, DEMOD_TIMF_SET, timf);
+	target = (dib0090_get_wbd_target(fe) * 8 * 18 / 33 + 1) / 2;
+	dib8000_set_wbd_ref(fe, target);
 
-	if (band != BAND_CBAND) {
-		/* dib0090_get_wbd_target is returning any possible temperature compensated wbd-target */
-		target = (dib0090_get_wbd_target(fe) * 8 * 18 / 33 + 1) / 2;
-		dib8000_set_wbd_ref(fe, target);
-	}
 
 	if (band == BAND_CBAND) {
 		deb_info("tuning in CBAND - soft-AGC startup\n");
 		dib0090_set_tune_state(fe, CT_AGC_START);
-
 		do {
 			ret = dib0090_gain_control(fe);
 			msleep(ret);
@@ -1604,17 +1534,14 @@ static int dib8096_set_param_override(struct dvb_frontend *fe)
 				dib8000_set_gpio(fe, 6, 0, 1);
 			else if (tune_state == CT_AGC_STEP_1) {
 				dib0090_get_current_gain(fe, NULL, NULL, &rf_gain_limit, &ltgain);
-				if (rf_gain_limit < 2000) /* activate the external attenuator in case of very high input power */
+				if (rf_gain_limit == 0)
 					dib8000_set_gpio(fe, 6, 0, 0);
 			}
 		} while (tune_state < CT_AGC_STOP);
-
-		deb_info("switching to PWM AGC\n");
 		dib0090_pwm_gain_reset(fe);
 		dib8000_pwm_agc_reset(fe);
 		dib8000_set_tune_state(fe, CT_DEMOD_START);
 	} else {
-		/* for everything else than CBAND we are using standard AGC */
 		deb_info("not tuning in CBAND - standard AGC startup\n");
 		dib0090_pwm_gain_reset(fe);
 	}
@@ -1887,92 +1814,21 @@ struct dibx090p_adc {
 	u32 pll_prediv;		/* New loopdiv */
 };
 
-struct dibx090p_best_adc {
-	u32 timf;
-	u32 pll_loopdiv;
-	u32 pll_prediv;
+struct dibx090p_adc dib8090p_adc_tab[] = {
+	{ 50000, 17043521, 16, 3}, /* 64 MHz */
+	{878000, 20199729, 9, 1}, /* 60 MHz */
+	{0xffffffff, 0, 0, 0}, /* 60 MHz */
 };
 
-static int dib8096p_get_best_sampling(struct dvb_frontend *fe, struct dibx090p_best_adc *adc)
-{
-	u8 spur = 0, prediv = 0, loopdiv = 0, min_prediv = 1, max_prediv = 1;
-	u16 xtal = 12000;
-	u16 fcp_min = 1900;  /* PLL, Minimum Frequency of phase comparator (KHz) */
-	u16 fcp_max = 20000; /* PLL, Maximum Frequency of phase comparator (KHz) */
-	u32 fmem_max = 140000; /* 140MHz max SDRAM freq */
-	u32 fdem_min = 66000;
-	u32 fcp = 0, fs = 0, fdem = 0, fmem = 0;
-	u32 harmonic_id = 0;
-
-	adc->timf = 0;
-	adc->pll_loopdiv = loopdiv;
-	adc->pll_prediv = prediv;
-
-	deb_info("bandwidth = %d", fe->dtv_property_cache.bandwidth_hz);
-
-	/* Find Min and Max prediv */
-	while ((xtal / max_prediv) >= fcp_min)
-		max_prediv++;
-
-	max_prediv--;
-	min_prediv = max_prediv;
-	while ((xtal / min_prediv) <= fcp_max) {
-		min_prediv--;
-		if (min_prediv == 1)
-			break;
-	}
-	deb_info("MIN prediv = %d : MAX prediv = %d", min_prediv, max_prediv);
-
-	min_prediv = 1;
-
-	for (prediv = min_prediv; prediv < max_prediv; prediv++) {
-		fcp = xtal / prediv;
-		if (fcp > fcp_min && fcp < fcp_max) {
-			for (loopdiv = 1; loopdiv < 64; loopdiv++) {
-				fmem = ((xtal/prediv) * loopdiv);
-				fdem = fmem / 2;
-				fs   = fdem / 4;
-
-				/* test min/max system restrictions */
-				if ((fdem >= fdem_min) && (fmem <= fmem_max) && (fs >= fe->dtv_property_cache.bandwidth_hz / 1000)) {
-					spur = 0;
-					/* test fs harmonics positions */
-					for (harmonic_id = (fe->dtv_property_cache.frequency / (1000 * fs));  harmonic_id <= ((fe->dtv_property_cache.frequency / (1000 * fs)) + 1); harmonic_id++) {
-						if (((fs * harmonic_id) >= (fe->dtv_property_cache.frequency / 1000 - (fe->dtv_property_cache.bandwidth_hz / 2000))) &&  ((fs * harmonic_id) <= (fe->dtv_property_cache.frequency / 1000 + (fe->dtv_property_cache.bandwidth_hz / 2000)))) {
-							spur = 1;
-							break;
-						}
-					}
-
-					if (!spur) {
-						adc->pll_loopdiv = loopdiv;
-						adc->pll_prediv = prediv;
-						adc->timf = (4260880253U / fdem) * (1 << 8);
-						adc->timf += ((4260880253U % fdem) << 8) / fdem;
-
-						deb_info("RF %6d; BW %6d; Xtal %6d; Fmem %6d; Fdem %6d; Fs %6d; Prediv %2d; Loopdiv %2d; Timf %8d;", fe->dtv_property_cache.frequency, fe->dtv_property_cache.bandwidth_hz, xtal, fmem, fdem, fs, prediv, loopdiv, adc->timf);
-						break;
-					}
-				}
-			}
-		}
-		if (!spur)
-			break;
-	}
-
-	if (adc->pll_loopdiv == 0 && adc->pll_prediv == 0)
-		return -EINVAL;
-	return 0;
-}
-
 static int dib8096p_agc_startup(struct dvb_frontend *fe)
 {
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
 	struct dvb_usb_adapter *adap = fe->dvb->priv;
 	struct dib0700_adapter_state *state = adap->priv;
 	struct dibx000_bandwidth_config pll;
-	struct dibx090p_best_adc adc;
 	u16 target;
-	int ret;
+	int better_sampling_freq = 0, ret;
+	struct dibx090p_adc *adc_table = &dib8090p_adc_tab[0];
 
 	ret = state->set_param_save(fe);
 	if (ret < 0)
@@ -1985,27 +1841,23 @@ static int dib8096p_agc_startup(struct dvb_frontend *fe)
 	target = (dib0090_get_wbd_target(fe) * 8  + 1) / 2;
 	dib8000_set_wbd_ref(fe, target);
 
-	if (dib8096p_get_best_sampling(fe, &adc) == 0) {
-		pll.pll_ratio  = adc.pll_loopdiv;
-		pll.pll_prediv = adc.pll_prediv;
 
-		dib0700_set_i2c_speed(adap->dev, 200);
-		dib8000_update_pll(fe, &pll, fe->dtv_property_cache.bandwidth_hz / 1000, 0);
-		dib8000_ctrl_timf(fe, DEMOD_TIMF_SET, adc.timf);
-		dib0700_set_i2c_speed(adap->dev, 1000);
+	while (p->frequency / 1000 > adc_table->freq) {
+		better_sampling_freq = 1;
+		adc_table++;
+	}
+
+	if ((adc_table->freq != 0xffffffff) && better_sampling_freq) {
+		pll.pll_ratio  = adc_table->pll_loopdiv;
+		pll.pll_prediv = adc_table->pll_prediv;
+		dib8000_update_pll(fe, &pll);
+		dib8000_ctrl_timf(fe, DEMOD_TIMF_SET, adc_table->timf);
 	}
 	return 0;
 }
 
 static int tfe8096p_frontend_attach(struct dvb_usb_adapter *adap)
 {
-	struct dib0700_state *st = adap->dev->priv;
-	u32 fw_version;
-
-	dib0700_get_version(adap->dev, NULL, NULL, &fw_version, NULL);
-	if (fw_version >= 0x10200)
-		st->fw_use_new_i2c_api = 1;
-
 	dib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);
 	msleep(20);
 	dib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);
@@ -2390,7 +2242,13 @@ static int nim9090md_tuner_attach(struct dvb_usb_adapter *adap)
 }
 
 /* NIM7090 */
-static int dib7090p_get_best_sampling(struct dvb_frontend *fe , struct dibx090p_best_adc *adc)
+struct dib7090p_best_adc {
+	u32 timf;
+	u32 pll_loopdiv;
+	u32 pll_prediv;
+};
+
+static int dib7090p_get_best_sampling(struct dvb_frontend *fe , struct dib7090p_best_adc *adc)
 {
 	u8 spur = 0, prediv = 0, loopdiv = 0, min_prediv = 1, max_prediv = 1;
 
@@ -2469,7 +2327,7 @@ static int dib7090_agc_startup(struct dvb_frontend *fe)
 	struct dib0700_adapter_state *state = adap->priv;
 	struct dibx000_bandwidth_config pll;
 	u16 target;
-	struct dibx090p_best_adc adc;
+	struct dib7090p_best_adc adc;
 	int ret;
 
 	ret = state->set_param_save(fe);
@@ -2499,16 +2357,36 @@ static int dib7090_agc_restart(struct dvb_frontend *fe, u8 restart)
 	return 0;
 }
 
-static int tfe7790p_update_lna(struct dvb_frontend *fe, u16 agc_global)
+static int dib7090e_update_lna(struct dvb_frontend *fe, u16 agc_global)
 {
-	deb_info("update LNA: agc global=%i", agc_global);
+	u16 agc1 = 0, agc2, wbd = 0, wbd_target, wbd_offset, threshold_agc1;
+	s16 wbd_delta;
 
-	if (agc_global < 25000) {
-		dib7000p_set_gpio(fe, 8, 0, 0);
-		dib7000p_set_agc1_min(fe, 0);
+	if ((fe->dtv_property_cache.frequency) < 400000000)
+		threshold_agc1 = 25000;
+	else
+		threshold_agc1 = 30000;
+
+	wbd_target = (dib0090_get_wbd_target(fe)*8+1)/2;
+	wbd_offset = dib0090_get_wbd_offset(fe);
+	dib7000p_get_agc_values(fe, NULL, &agc1, &agc2, &wbd);
+	wbd_delta = (s16)wbd - (((s16)wbd_offset+10)*4) ;
+
+	deb_info("update lna, agc_global=%d agc1=%d agc2=%d",
+			agc_global, agc1, agc2);
+	deb_info("update lna, wbd=%d wbd target=%d wbd offset=%d wbd delta=%d",
+			wbd, wbd_target, wbd_offset, wbd_delta);
+
+	if ((agc1 < threshold_agc1) && (wbd_delta > 0)) {
+		dib0090_set_switch(fe, 1, 1, 1);
+		dib0090_set_vga(fe, 0);
+		dib0090_update_rframp_7090(fe, 0);
+		dib0090_update_tuning_table_7090(fe, 0);
 	} else {
-		dib7000p_set_gpio(fe, 8, 0, 1);
-		dib7000p_set_agc1_min(fe, 32768);
+		dib0090_set_vga(fe, 1);
+		dib0090_update_rframp_7090(fe, 1);
+		dib0090_update_tuning_table_7090(fe, 1);
+		dib0090_set_switch(fe, 0, 0, 0);
 	}
 
 	return 0;
@@ -2522,6 +2400,15 @@ static struct dib0090_wbd_slope dib7090_wbd_table[] = {
 	{ 0xFFFF, 0,   0, 0,   0,   0},
 };
 
+static struct dib0090_wbd_slope dib7090e_wbd_table[] = {
+	{ 380,   81, 850, 64, 540,	4},
+	{ 700,   51, 866, 21,  320,	4},
+	{ 860,   48, 666, 18,  330,	6},
+	{1700,    0, 250, 0,   100, 6},
+	{2600,    0, 250, 0,   100, 6},
+	{ 0xFFFF, 0,   0, 0,   0,	0},
+};
+
 static struct dibx000_agc_config dib7090_agc_config[2] = {
 	{
 		.band_caps      = BAND_UHF,
@@ -2541,7 +2428,7 @@ static struct dibx000_agc_config dib7090_agc_config[2] = {
 		.wbd_alpha      = 5,
 
 		.agc1_max       = 65535,
-		.agc1_min       = 32768,
+		.agc1_min       = 0,
 
 		.agc2_max       = 65535,
 		.agc2_min       = 0,
@@ -2618,7 +2505,7 @@ static struct dib7000p_config nim7090_dib7000p_config = {
 	.output_mpeg2_in_188_bytes  = 1,
 	.hostbus_diversity			= 1,
 	.tuner_is_baseband			= 1,
-	.update_lna					= tfe7790p_update_lna, /* GPIO used is the same as TFE7790 */
+	.update_lna					= NULL,
 
 	.agc_config_count			= 2,
 	.agc						= dib7090_agc_config,
@@ -2642,26 +2529,12 @@ static struct dib7000p_config nim7090_dib7000p_config = {
 	.enMpegOutput				= 1,
 };
 
-static int tfe7090p_pvr_update_lna(struct dvb_frontend *fe, u16 agc_global)
-{
-	deb_info("TFE7090P-PVR update LNA: agc global=%i", agc_global);
-	if (agc_global < 25000) {
-		dib7000p_set_gpio(fe, 5, 0, 0);
-		dib7000p_set_agc1_min(fe, 0);
-	} else {
-		dib7000p_set_gpio(fe, 5, 0, 1);
-		dib7000p_set_agc1_min(fe, 32768);
-	}
-
-	return 0;
-}
-
 static struct dib7000p_config tfe7090pvr_dib7000p_config[2] = {
 	{
 		.output_mpeg2_in_188_bytes  = 1,
 		.hostbus_diversity			= 1,
 		.tuner_is_baseband			= 1,
-		.update_lna					= tfe7090p_pvr_update_lna,
+		.update_lna					= NULL,
 
 		.agc_config_count			= 2,
 		.agc						= dib7090_agc_config,
@@ -2688,7 +2561,7 @@ static struct dib7000p_config tfe7090pvr_dib7000p_config[2] = {
 		.output_mpeg2_in_188_bytes  = 1,
 		.hostbus_diversity			= 1,
 		.tuner_is_baseband			= 1,
-		.update_lna					= tfe7090p_pvr_update_lna,
+		.update_lna					= NULL,
 
 		.agc_config_count			= 2,
 		.agc						= dib7090_agc_config,
@@ -2714,6 +2587,34 @@ static struct dib7000p_config tfe7090pvr_dib7000p_config[2] = {
 	}
 };
 
+static struct dib7000p_config tfe7090e_dib7000p_config = {
+	.output_mpeg2_in_188_bytes  = 1,
+	.hostbus_diversity			= 1,
+	.tuner_is_baseband			= 1,
+	.update_lna					= dib7090e_update_lna,
+
+	.agc_config_count			= 2,
+	.agc						= dib7090_agc_config,
+
+	.bw							= &dib7090_clock_config_12_mhz,
+
+	.gpio_dir					= DIB7000P_GPIO_DEFAULT_DIRECTIONS,
+	.gpio_val					= DIB7000P_GPIO_DEFAULT_VALUES,
+	.gpio_pwm_pos				= DIB7000P_GPIO_DEFAULT_PWM_POS,
+
+	.pwm_freq_div				= 0,
+
+	.agc_control				= dib7090_agc_restart,
+
+	.spur_protect				= 0,
+	.disable_sample_and_hold	= 0,
+	.enable_current_mirror		= 0,
+	.diversity_delay			= 0,
+
+	.output_mode				= OUTMODE_MPEG2_FIFO,
+	.enMpegOutput				= 1,
+};
+
 static const struct dib0090_config nim7090_dib0090_config = {
 	.io.clock_khz = 12000,
 	.io.pll_bypass = 0,
@@ -2748,11 +2649,47 @@ static const struct dib0090_config nim7090_dib0090_config = {
 	.in_soc = 1,
 };
 
-static struct dib7000p_config tfe7790p_dib7000p_config = {
+static const struct dib0090_config tfe7090e_dib0090_config = {
+	.io.clock_khz = 12000,
+	.io.pll_bypass = 0,
+	.io.pll_range = 0,
+	.io.pll_prediv = 3,
+	.io.pll_loopdiv = 6,
+	.io.adc_clock_ratio = 0,
+	.io.pll_int_loop_filt = 0,
+	.reset = dib7090_tuner_sleep,
+	.sleep = dib7090_tuner_sleep,
+
+	.freq_offset_khz_uhf = 0,
+	.freq_offset_khz_vhf = 0,
+
+	.get_adc_power = dib7090_get_adc_power,
+
+	.clkouttobamse = 1,
+	.analog_output = 0,
+
+	.wbd_vhf_offset = 0,
+	.wbd_cband_offset = 0,
+	.use_pwm_agc = 1,
+	.clkoutdrive = 0,
+
+	.fref_clock_ratio = 0,
+
+	.wbd = dib7090e_wbd_table,
+
+	.ls_cfg_pad_drv = 0,
+	.data_tx_drv = 0,
+	.low_if = NULL,
+	.in_soc = 1,
+	.force_cband_input = 1,
+	.is_dib7090e = 1,
+};
+
+static struct dib7000p_config tfe7790e_dib7000p_config = {
 	.output_mpeg2_in_188_bytes  = 1,
 	.hostbus_diversity			= 1,
 	.tuner_is_baseband			= 1,
-	.update_lna					= tfe7790p_update_lna,
+	.update_lna					= dib7090e_update_lna,
 
 	.agc_config_count			= 2,
 	.agc						= dib7090_agc_config,
@@ -2776,7 +2713,7 @@ static struct dib7000p_config tfe7790p_dib7000p_config = {
 	.enMpegOutput				= 1,
 };
 
-static const struct dib0090_config tfe7790p_dib0090_config = {
+static const struct dib0090_config tfe7790e_dib0090_config = {
 	.io.clock_khz = 12000,
 	.io.pll_bypass = 0,
 	.io.pll_range = 0,
@@ -2802,14 +2739,14 @@ static const struct dib0090_config tfe7790p_dib0090_config = {
 
 	.fref_clock_ratio = 0,
 
-	.wbd = dib7090_wbd_table,
+	.wbd = dib7090e_wbd_table,
 
 	.ls_cfg_pad_drv = 0,
 	.data_tx_drv = 0,
 	.low_if = NULL,
 	.in_soc = 1,
-	.force_cband_input = 0,
-	.is_dib7090e = 0,
+	.force_cband_input = 1,
+	.is_dib7090e = 1,
 	.force_crystal_mode = 1,
 };
 
@@ -3005,11 +2942,37 @@ static int tfe7090pvr_tuner1_attach(struct dvb_usb_adapter *adap)
 	return 0;
 }
 
-static int tfe7790p_frontend_attach(struct dvb_usb_adapter *adap)
+static int tfe7090e_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	dib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);
+	msleep(20);
+	dib0700_set_gpio(adap->dev, GPIO9, GPIO_OUT, 1);
+	dib0700_set_gpio(adap->dev, GPIO4, GPIO_OUT, 1);
+	dib0700_set_gpio(adap->dev, GPIO7, GPIO_OUT, 1);
+	dib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 0);
+
+	msleep(20);
+	dib0700_set_gpio(adap->dev, GPIO10, GPIO_OUT, 1);
+	msleep(20);
+	dib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);
+
+	if (dib7000p_i2c_enumeration(&adap->dev->i2c_adap,
+				1, 0x10, &tfe7090e_dib7000p_config) != 0) {
+		err("%s: dib7000p_i2c_enumeration failed.  Cannot continue\n",
+				__func__);
+		return -ENODEV;
+	}
+	adap->fe_adap[0].fe = dvb_attach(dib7000p_attach, &adap->dev->i2c_adap,
+			0x80, &tfe7090e_dib7000p_config);
+
+	return adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;
+}
+
+static int tfe7790e_frontend_attach(struct dvb_usb_adapter *adap)
 {
 	struct dib0700_state *st = adap->dev->priv;
 
-	/* The TFE7790P requires the dib0700 to not be in master mode */
+	/* The TFE7790E requires the dib0700 to not be in master mode */
 	st->disable_streaming_master_mode = 1;
 
 	dib0700_set_gpio(adap->dev, GPIO6, GPIO_OUT, 1);
@@ -3025,25 +2988,42 @@ static int tfe7790p_frontend_attach(struct dvb_usb_adapter *adap)
 	dib0700_set_gpio(adap->dev, GPIO0, GPIO_OUT, 1);
 
 	if (dib7000p_i2c_enumeration(&adap->dev->i2c_adap,
-				1, 0x10, &tfe7790p_dib7000p_config) != 0) {
+				1, 0x10, &tfe7790e_dib7000p_config) != 0) {
 		err("%s: dib7000p_i2c_enumeration failed.  Cannot continue\n",
 				__func__);
 		return -ENODEV;
 	}
 	adap->fe_adap[0].fe = dvb_attach(dib7000p_attach, &adap->dev->i2c_adap,
-			0x80, &tfe7790p_dib7000p_config);
+			0x80, &tfe7790e_dib7000p_config);
 
 	return adap->fe_adap[0].fe == NULL ?  -ENODEV : 0;
 }
 
-static int tfe7790p_tuner_attach(struct dvb_usb_adapter *adap)
+static int tfe7790e_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	struct dib0700_adapter_state *st = adap->priv;
+	struct i2c_adapter *tun_i2c =
+		dib7090_get_i2c_tuner(adap->fe_adap[0].fe);
+
+	if (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c,
+				&tfe7790e_dib0090_config) == NULL)
+		return -ENODEV;
+
+	dib7000p_set_gpio(adap->fe_adap[0].fe, 8, 0, 1);
+
+	st->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;
+	adap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7090_agc_startup;
+	return 0;
+}
+
+static int tfe7090e_tuner_attach(struct dvb_usb_adapter *adap)
 {
 	struct dib0700_adapter_state *st = adap->priv;
 	struct i2c_adapter *tun_i2c =
 		dib7090_get_i2c_tuner(adap->fe_adap[0].fe);
 
 	if (dvb_attach(dib0090_register, adap->fe_adap[0].fe, tun_i2c,
-				&tfe7790p_dib0090_config) == NULL)
+				&tfe7090e_dib0090_config) == NULL)
 		return -ENODEV;
 
 	dib7000p_set_gpio(adap->fe_adap[0].fe, 8, 0, 1);
@@ -3586,9 +3566,10 @@ struct usb_device_id dib0700_usb_id_table[] = {
 /* 75 */{ USB_DEVICE(USB_VID_MEDION,    USB_PID_CREATIX_CTX1921) },
 	{ USB_DEVICE(USB_VID_PINNACLE,  USB_PID_PINNACLE_PCTV340E) },
 	{ USB_DEVICE(USB_VID_PINNACLE,  USB_PID_PINNACLE_PCTV340E_SE) },
-	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_TFE7790P) },
-	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_TFE8096P) },
-/* 80 */{ USB_DEVICE(USB_VID_ELGATO,	USB_PID_ELGATO_EYETV_DTT_2) },
+	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_TFE7090E) },
+	{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_TFE7790E) },
+/* 80 */{ USB_DEVICE(USB_VID_DIBCOM,    USB_PID_DIBCOM_TFE8096P) },
+	{ USB_DEVICE(USB_VID_ELGATO,	USB_PID_ELGATO_EYETV_DTT_2) },
 	{ 0 }		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, dib0700_usb_id_table);
@@ -3899,7 +3880,7 @@ struct dvb_usb_device_properties dib0700_devices[] = {
 				{ NULL },
 			},
 			{   "Elgato EyeTV DTT rev. 2",
-				{ &dib0700_usb_id_table[80], NULL },
+				{ &dib0700_usb_id_table[81], NULL },
 				{ NULL },
 			},
 		},
@@ -4716,10 +4697,10 @@ struct dvb_usb_device_properties dib0700_devices[] = {
 					.pid_filter_count = 32,
 					.pid_filter = stk70x0p_pid_filter,
 					.pid_filter_ctrl = stk70x0p_pid_filter_ctrl,
-					.frontend_attach  = tfe7790p_frontend_attach,
-					.tuner_attach     = tfe7790p_tuner_attach,
+					.frontend_attach  = tfe7090e_frontend_attach,
+					.tuner_attach     = tfe7090e_tuner_attach,
 
-					DIB0700_DEFAULT_STREAMING_CONFIG(0x03),
+					DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
 				} },
 
 				.size_of_priv =
@@ -4729,7 +4710,7 @@ struct dvb_usb_device_properties dib0700_devices[] = {
 
 		.num_device_descs = 1,
 		.devices = {
-			{   "DiBcom TFE7790P reference design",
+			{   "DiBcom TFE7090E reference design",
 				{ &dib0700_usb_id_table[78], NULL },
 				{ NULL },
 			},
@@ -4754,6 +4735,46 @@ struct dvb_usb_device_properties dib0700_devices[] = {
 					.caps  = DVB_USB_ADAP_HAS_PID_FILTER |
 						DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,
 					.pid_filter_count = 32,
+					.pid_filter = stk70x0p_pid_filter,
+					.pid_filter_ctrl = stk70x0p_pid_filter_ctrl,
+					.frontend_attach  = tfe7790e_frontend_attach,
+					.tuner_attach     = tfe7790e_tuner_attach,
+
+					DIB0700_DEFAULT_STREAMING_CONFIG(0x03),
+				} },
+
+				.size_of_priv =
+					sizeof(struct dib0700_adapter_state),
+			},
+		},
+
+		.num_device_descs = 1,
+		.devices = {
+			{   "DiBcom TFE7790E reference design",
+				{ &dib0700_usb_id_table[79], NULL },
+				{ NULL },
+			},
+		},
+
+		.rc.core = {
+			.rc_interval      = DEFAULT_RC_INTERVAL,
+			.rc_codes         = RC_MAP_DIB0700_RC5_TABLE,
+			.module_name	  = "dib0700",
+			.rc_query         = dib0700_rc_query_old_firmware,
+			.allowed_protos   = RC_BIT_RC5 |
+					    RC_BIT_RC6_MCE |
+					    RC_BIT_NEC,
+			.change_protocol  = dib0700_change_protocol,
+		},
+	}, { DIB0700_DEFAULT_DEVICE_PROPERTIES,
+		.num_adapters = 1,
+		.adapter = {
+			{
+				.num_frontends = 1,
+				.fe = {{
+					.caps  = DVB_USB_ADAP_HAS_PID_FILTER |
+						DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,
+					.pid_filter_count = 32,
 					.pid_filter = stk80xx_pid_filter,
 					.pid_filter_ctrl = stk80xx_pid_filter_ctrl,
 					.frontend_attach  = tfe8096p_frontend_attach,
@@ -4771,7 +4792,7 @@ struct dvb_usb_device_properties dib0700_devices[] = {
 		.num_device_descs = 1,
 		.devices = {
 			{   "DiBcom TFE8096P reference design",
-				{ &dib0700_usb_id_table[79], NULL },
+				{ &dib0700_usb_id_table[80], NULL },
 				{ NULL },
 			},
 		},
diff --git a/drivers/media/usb/dvb-usb/dibusb-common.c b/drivers/media/usb/dvb-usb/dibusb-common.c
index 6d68af0..c2dded9 100644
--- a/drivers/media/usb/dvb-usb/dibusb-common.c
+++ b/drivers/media/usb/dvb-usb/dibusb-common.c
@@ -12,9 +12,6 @@
 #include <linux/kconfig.h>
 #include "dibusb.h"
 
-/* Max transfer size done by I2C transfer functions */
-#define MAX_XFER_SIZE  64
-
 static int debug;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "set debugging level (1=info (|-able))." DVB_USB_DEBUG_STATUS);
@@ -108,16 +105,11 @@ EXPORT_SYMBOL(dibusb2_0_power_ctrl);
 static int dibusb_i2c_msg(struct dvb_usb_device *d, u8 addr,
 			  u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)
 {
-	u8 sndbuf[MAX_XFER_SIZE]; /* lead(1) devaddr,direction(1) addr(2) data(wlen) (len(2) (when reading)) */
+	u8 sndbuf[wlen+4]; /* lead(1) devaddr,direction(1) addr(2) data(wlen) (len(2) (when reading)) */
 	/* write only ? */
 	int wo = (rbuf == NULL || rlen == 0),
 		len = 2 + wlen + (wo ? 0 : 2);
 
-	if (4 + wlen > sizeof(sndbuf)) {
-		warn("i2c wr: len=%d is too big!\n", wlen);
-		return -EOPNOTSUPP;
-	}
-
 	sndbuf[0] = wo ? DIBUSB_REQ_I2C_WRITE : DIBUSB_REQ_I2C_READ;
 	sndbuf[1] = (addr << 1) | (wo ? 0 : 1);
 
diff --git a/drivers/media/usb/dvb-usb/dw2102.c b/drivers/media/usb/dvb-usb/dw2102.c
index 4170a45..c4294da 100644
--- a/drivers/media/usb/dvb-usb/dw2102.c
+++ b/drivers/media/usb/dvb-usb/dw2102.c
@@ -22,13 +22,15 @@
 #include "tda1002x.h"
 #include "mt312.h"
 #include "zl10039.h"
-#include "ts2020.h"
 #include "ds3000.h"
+#include "ds3103.h"
 #include "stv0900.h"
 #include "stv6110.h"
 #include "stb6100.h"
 #include "stb6100_proc.h"
 #include "m88rs2000.h"
+#include "ts2020.h"
+#include "ts2022.h"
 
 /* Max transfer size done by I2C transfer functions */
 #define MAX_XFER_SIZE  64
@@ -85,6 +87,14 @@
 #define USB_PID_GOTVIEW_SAT_HD 0x5456
 #endif
 
+#ifndef USB_PID_TEVII_S482_1
+#define USB_PID_TEVII_S482_1 0xd483
+#endif
+
+#ifndef USB_PID_TEVII_S482_2
+#define USB_PID_TEVII_S482_2 0xd484
+#endif
+
 #define DW210X_READ_MSG 0
 #define DW210X_WRITE_MSG 1
 
@@ -174,6 +184,7 @@ static int dw2102_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 		int num)
 {
 	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int ret;
 	int i = 0;
 	u8 buf6[] = {0x2c, 0x05, 0xc0, 0, 0, 0, 0};
 	u16 value;
@@ -1108,6 +1119,12 @@ static struct ds3000_config su3000_ds3000_config = {
 	.set_lock_led = dw210x_led_ctrl,
 };
 
+static struct ds3103_config su3000_ds3103_config = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.set_lock_led = dw210x_led_ctrl,
+};
+
 static u8 m88rs2000_inittab[] = {
 	DEMOD_WRITE, 0x9a, 0x30,
 	DEMOD_WRITE, 0x00, 0x01,
@@ -1363,14 +1380,24 @@ static int su3000_frontend_attach(struct dvb_usb_adapter *d)
 
 	d->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,
 					&d->dev->i2c_adap);
-	if (d->fe_adap[0].fe == NULL)
-		return -EIO;
+	if (d->fe_adap[0].fe != NULL) {
+		if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,
+					&dw2104_ts2020_config,
+					&d->dev->i2c_adap)) {
+			info("Attached DS3000/TS2020!\n");
+			return 0;
+		}
+	}
 
-	if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,
-				&dw2104_ts2020_config,
+	d->fe_adap[0].fe = dvb_attach(ds3103_attach,
+					&su3000_ds3103_config,
+					&d->dev->i2c_adap);
+	if (d->fe_adap[0].fe != NULL) {
+		if (dvb_attach(ts2022_attach, d->fe_adap[0].fe, 0x60,
 				&d->dev->i2c_adap)) {
-		info("Attached DS3000/TS2020!\n");
-		return 0;
+			info("Attached DS3103/TS2022!\n");
+			return 0;
+		}
 	}
 
 	info("Failed to attach DS3000/TS2020!\n");
diff --git a/drivers/media/usb/dvb-usb/opera1.c b/drivers/media/usb/dvb-usb/opera1.c
index 16ba90a..c8a9504 100644
--- a/drivers/media/usb/dvb-usb/opera1.c
+++ b/drivers/media/usb/dvb-usb/opera1.c
@@ -151,7 +151,7 @@ static int opera1_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 			break;
 		}
 		if (dvb_usb_opera1_debug & 0x10)
-			info("sending i2c message %d %d", tmp, msg[i].len);
+			info("sending i2c mesage %d %d", tmp, msg[i].len);
 	}
 	mutex_unlock(&d->i2c_mutex);
 	return num;
diff --git a/drivers/media/v4l2-core/tuner-core.c b/drivers/media/v4l2-core/tuner-core.c
index ddc9379..cf9a9af 100644
--- a/drivers/media/v4l2-core/tuner-core.c
+++ b/drivers/media/v4l2-core/tuner-core.c
@@ -132,7 +132,7 @@ struct tuner {
 	bool                standby;	/* Standby mode */
 
 	unsigned int        type; /* chip type id */
-	void                *config;
+	unsigned int        config;
 	const char          *name;
 };
 
@@ -218,6 +218,26 @@ static void fe_standby(struct dvb_frontend *fe)
 		fe_tuner_ops->sleep(fe);
 }
 
+static int fe_has_signal(struct dvb_frontend *fe)
+{
+	u16 strength;
+
+	if (fe->ops.tuner_ops.get_rf_strength(fe, &strength) < 0)
+		return 0;
+
+	return strength;
+}
+
+static int fe_get_afc(struct dvb_frontend *fe)
+{
+	s32 afc;
+
+	if (fe->ops.tuner_ops.get_afc(fe, &afc) < 0)
+		return 0;
+
+	return afc;
+}
+
 static int fe_set_config(struct dvb_frontend *fe, void *priv_cfg)
 {
 	struct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;
@@ -250,8 +270,9 @@ static const struct analog_demod_ops tuner_analog_ops = {
  * @c:			i2c_client descriptoy
  * @type:		type of the tuner (e. g. tuner number)
  * @new_mode_mask:	Indicates if tuner supports TV and/or Radio
- * @new_config:		an optional parameter used by a few tuners to adjust
-			internal parameters, like LNA mode
+ * @new_config:		an optional parameter ranging from 0-255 used by
+			a few tuners to adjust an internal parameter,
+			like LNA mode
  * @tuner_callback:	an optional function to be called when switching
  *			to analog mode
  *
@@ -259,7 +280,7 @@ static const struct analog_demod_ops tuner_analog_ops = {
  * by tun_setup structure. It contains several per-tuner initialization "magic"
  */
 static void set_type(struct i2c_client *c, unsigned int type,
-		     unsigned int new_mode_mask, void *new_config,
+		     unsigned int new_mode_mask, unsigned int new_config,
 		     int (*tuner_callback) (void *dev, int component, int cmd, int arg))
 {
 	struct tuner *t = to_tuner(i2c_get_clientdata(c));
@@ -274,7 +295,8 @@ static void set_type(struct i2c_client *c, unsigned int type,
 	}
 
 	t->type = type;
-	t->config = new_config;
+	/* prevent invalid config values */
+	t->config = new_config < 256 ? new_config : 0;
 	if (tuner_callback != NULL) {
 		tuner_dbg("defining GPIO callback\n");
 		t->fe.callback = tuner_callback;
@@ -292,8 +314,11 @@ static void set_type(struct i2c_client *c, unsigned int type,
 		break;
 	case TUNER_PHILIPS_TDA8290:
 	{
+		struct tda829x_config cfg = {
+			.lna_cfg        = t->config,
+		};
 		if (!dvb_attach(tda829x_attach, &t->fe, t->i2c->adapter,
-				t->i2c->addr, t->config))
+				t->i2c->addr, &cfg))
 			goto attach_failed;
 		break;
 	}
@@ -382,6 +407,7 @@ static void set_type(struct i2c_client *c, unsigned int type,
 	case TUNER_NXP_TDA18271:
 	{
 		struct tda18271_config cfg = {
+			.config = t->config,
 			.small_i2c = TDA18271_03_BYTE_CHUNK_INIT,
 		};
 
@@ -426,9 +452,9 @@ static void set_type(struct i2c_client *c, unsigned int type,
 		       sizeof(struct analog_demod_ops));
 
 		if (fe_tuner_ops->get_rf_strength)
-			analog_ops->has_signal = fe_tuner_ops->get_rf_strength;
+			analog_ops->has_signal = fe_has_signal;
 		if (fe_tuner_ops->get_afc)
-			analog_ops->get_afc = fe_tuner_ops->get_afc;
+			analog_ops->get_afc = fe_get_afc;
 
 	} else {
 		t->name = analog_ops->info.name;
@@ -483,7 +509,7 @@ static int tuner_s_type_addr(struct v4l2_subdev *sd,
 	struct tuner *t = to_tuner(sd);
 	struct i2c_client *c = v4l2_get_subdevdata(sd);
 
-	tuner_dbg("Calling set_type_addr for type=%d, addr=0x%02x, mode=0x%02x, config=%p\n",
+	tuner_dbg("Calling set_type_addr for type=%d, addr=0x%02x, mode=0x%02x, config=0x%02x\n",
 			tun_setup->type,
 			tun_setup->addr,
 			tun_setup->mode_mask,
@@ -1050,12 +1076,9 @@ static void tuner_status(struct dvb_frontend *fe)
 		if (tuner_status & TUNER_STATUS_STEREO)
 			tuner_info("Stereo:          yes\n");
 	}
-	if (analog_ops->has_signal) {
-		u16 signal;
-
-		if (!analog_ops->has_signal(fe, &signal))
-			tuner_info("Signal strength: %hu\n", signal);
-	}
+	if (analog_ops->has_signal)
+		tuner_info("Signal strength: %d\n",
+			   analog_ops->has_signal(fe));
 }
 
 /*
@@ -1173,13 +1196,9 @@ static int tuner_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)
 	if (check_mode(t, vt->type) == -EINVAL)
 		return 0;
 	if (vt->type == t->mode && analog_ops->get_afc)
-		analog_ops->get_afc(&t->fe, &vt->afc);
-	if (vt->type == t->mode && analog_ops->has_signal) {
-		u16 signal = (u16)vt->signal;
-
-		if (!analog_ops->has_signal(&t->fe, &signal))
-			vt->signal = signal;
-	}
+		vt->afc = analog_ops->get_afc(&t->fe);
+	if (analog_ops->has_signal)
+		vt->signal = analog_ops->has_signal(&t->fe);
 	if (vt->type != V4L2_TUNER_RADIO) {
 		vt->capability |= V4L2_TUNER_CAP_NORM;
 		vt->rangelow = tv_range[0] * 16;
diff --git a/include/uapi/linux/dvb/dmx.h b/include/uapi/linux/dvb/dmx.h
index cb9fbab..b2a9ad8 100755
--- a/include/uapi/linux/dvb/dmx.h
+++ b/include/uapi/linux/dvb/dmx.h
@@ -51,7 +51,7 @@ typedef enum
 } dmx_input_t;
 
 
-typedef enum dmx_ts_pes
+typedef enum
 {
 	DMX_PES_AUDIO0,
 	DMX_PES_VIDEO0,
@@ -130,10 +130,7 @@ typedef enum {
 	DMX_SOURCE_DVR0   = 16,
 	DMX_SOURCE_DVR1,
 	DMX_SOURCE_DVR2,
-	DMX_SOURCE_DVR3,
-	DMX_SOURCE_FRONT0_OFFSET = 100,
-	DMX_SOURCE_FRONT1_OFFSET,
-	DMX_SOURCE_FRONT2_OFFSET
+	DMX_SOURCE_DVR3
 } dmx_source_t;
 
 struct dmx_stc {
diff --git a/include/uapi/linux/dvb/frontend.h b/include/uapi/linux/dvb/frontend.h
index 60ab5e4..c56d77c 100755
--- a/include/uapi/linux/dvb/frontend.h
+++ b/include/uapi/linux/dvb/frontend.h
@@ -27,26 +27,14 @@
 #define _DVBFRONTEND_H_
 
 #include <linux/types.h>
-#include <linux/videodev2.h>
 
 typedef enum fe_type {
 	FE_QPSK,
 	FE_QAM,
 	FE_OFDM,
-	FE_ATSC,
-	FE_ANALOG,
-	FE_DTMB,
-	FE_ISDBT
+	FE_ATSC
 } fe_type_t;
 
-typedef enum fe_layer {
-	Layer_A_B_C,
-	Layer_A,
-	Layer_B,
-	Layer_C,
-} fe_layer_t;
-
-
 
 typedef enum fe_caps {
 	FE_IS_STUPID			= 0,
@@ -82,7 +70,6 @@ typedef enum fe_caps {
 	FE_CAN_MUTE_TS			= 0x80000000  /* frontend can stop spurious TS data output */
 } fe_caps_t;
 
-#define FE_CAN_3_LAYER FE_CAN_MULTISTREAM
 
 struct dvb_frontend_info {
 	char       name[128];
@@ -119,8 +106,7 @@ struct dvb_diseqc_slave_reply {
 typedef enum fe_sec_voltage {
 	SEC_VOLTAGE_13,
 	SEC_VOLTAGE_18,
-	SEC_VOLTAGE_OFF,
-	SEC_VOLTAGE_ON     // for ISDBT antenna control
+	SEC_VOLTAGE_OFF
 } fe_sec_voltage_t;
 
 
@@ -149,15 +135,14 @@ typedef enum fe_sec_mini_cmd {
  */
 
 typedef enum fe_status {
-	FE_HAS_SIGNAL	= 0x01,   /* found something above the noise level */
-	FE_HAS_CARRIER	= 0x02,   /* found a DVB signal  */
-	FE_HAS_VITERBI	= 0x04,   /* FEC is stable  */
-	FE_HAS_SYNC	= 0x08,   /* found sync bytes  */
-	FE_HAS_LOCK	= 0x10,   /* everything's working... */
-	FE_TIMEDOUT	= 0x20,   /* no lock within the last ~2 seconds */
-	FE_REINIT	= 0x40    /* frontend was reinitialized,  */
-} fe_status_t;			  /* application is recommended to reset */
-				  /* DiSEqC, tone and parameters */
+	FE_HAS_SIGNAL		= 0x01,
+	FE_HAS_CARRIER		= 0x02,
+	FE_HAS_VITERBI		= 0x04,
+	FE_HAS_SYNC		= 0x08,
+	FE_HAS_LOCK		= 0x10,
+	FE_TIMEDOUT		= 0x20,
+	FE_REINIT		= 0x40,
+} fe_status_t;
 
 typedef enum fe_spectral_inversion {
 	INVERSION_OFF,
@@ -212,7 +197,7 @@ typedef enum fe_transmit_mode {
 	TRANSMISSION_MODE_C3780,
 } fe_transmit_mode_t;
 
-//#if defined(__DVB_CORE__) || !defined (__KERNEL__)
+#if defined(__DVB_CORE__) || !defined (__KERNEL__)
 typedef enum fe_bandwidth {
 	BANDWIDTH_8_MHZ,
 	BANDWIDTH_7_MHZ,
@@ -222,7 +207,7 @@ typedef enum fe_bandwidth {
 	BANDWIDTH_10_MHZ,
 	BANDWIDTH_1_712_MHZ,
 } fe_bandwidth_t;
-//#endif
+#endif
 
 typedef enum fe_guard_interval {
 	GUARD_INTERVAL_1_32,
@@ -254,13 +239,7 @@ enum fe_interleaving {
 	INTERLEAVING_720,
 };
 
-typedef enum fe_ofdm_mode
-{
-	OFDM_DVBT,
-	OFDM_DVBT2,
-}fe_ofdm_mode_t;
-
-//#if defined(__DVB_CORE__) || !defined (__KERNEL__)
+#if defined(__DVB_CORE__) || !defined (__KERNEL__)
 struct dvb_qpsk_parameters {
 	__u32		symbol_rate;  /* symbol rate in Symbols per second */
 	fe_code_rate_t	fec_inner;    /* forward error correction (see above) */
@@ -284,19 +263,8 @@ struct dvb_ofdm_parameters {
 	fe_transmit_mode_t  transmission_mode;
 	fe_guard_interval_t guard_interval;
 	fe_hierarchy_t      hierarchy_information;
-	fe_ofdm_mode_t ofdm_mode;
 };
 
-#define ANALOG_FLAG_ENABLE_AFC                 0X00000001
-#define  ANALOG_FLAG_MANUL_SCAN                0x00000011
-struct dvb_analog_parameters {
-	unsigned int         audmode; /*V4L2_TUNER_MODE_MONO,V4L2_TUNER_MODE_STEREO,V4L2_TUNER_MODE_LANG2,V4L2_TUNER_MODE_SAP,V4L2_TUNER_MODE_LANG1,V4L2_TUNER_MODE_LANG1_LANG2*/
-	unsigned int         soundsys;/*A2,BTSC,EIAJ,NICAM*/
-	v4l2_std_id           std;
-	unsigned int         flag;
-                unsigned int         afc_range;
-        unsigned int         reserved;
-};
 
 struct dvb_frontend_parameters {
 	__u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM/ATSC */
@@ -307,7 +275,6 @@ struct dvb_frontend_parameters {
 		struct dvb_qam_parameters  qam;
 		struct dvb_ofdm_parameters ofdm;
 		struct dvb_vsb_parameters vsb;
-		struct dvb_analog_parameters analog;
 	} u;
 };
 
@@ -315,7 +282,7 @@ struct dvb_frontend_event {
 	fe_status_t status;
 	struct dvb_frontend_parameters parameters;
 };
-//#endif
+#endif
 
 /* S2API Commands */
 #define DTV_UNDEFINED		0
@@ -378,8 +345,6 @@ struct dvb_frontend_event {
 
 #define DTV_ENUM_DELSYS		44
 
-#define DTV_DVBT2_PLP_ID    DTV_DVBT2_PLP_ID_LEGACY
-
 /* ATSC-MH */
 #define DTV_ATSCMH_FIC_VER		45
 #define DTV_ATSCMH_PARADE_ID		46
@@ -410,9 +375,7 @@ struct dvb_frontend_event {
 #define DTV_STAT_ERROR_BLOCK_COUNT	68
 #define DTV_STAT_TOTAL_BLOCK_COUNT	69
 
-#define DTV_DVBT2_DATA_PLPS	70
-
-#define DTV_MAX_COMMAND			DTV_DVBT2_DATA_PLPS	
+#define DTV_MAX_COMMAND		DTV_STAT_TOTAL_BLOCK_COUNT
 
 typedef enum fe_pilot {
 	PILOT_ON,
@@ -445,9 +408,8 @@ typedef enum fe_delivery_system {
 	SYS_CMMB,
 	SYS_DAB,
 	SYS_DVBT2,
-	SYS_ANALOG,
 	SYS_TURBO,
-	SYS_DVBC_ANNEX_C
+	SYS_DVBC_ANNEX_C,
 } fe_delivery_system_t;
 
 /* backward compatibility */
@@ -589,85 +551,10 @@ struct dtv_properties {
 	__u32 num;
 	struct dtv_property *props;
 };
-//for atv
-typedef struct tuner_status_s {
-	unsigned int frequency;
-	unsigned int rssi;
-	unsigned char mode;//dtv:0 or atv:1
-	unsigned char tuner_locked;//notlocked:0,locked:1
-	void 		 *ressrved;
-}tuner_status_t;
-
-typedef struct atv_status_s {
-	unsigned char atv_lock;//notlocked:0,locked 1
-	v4l2_std_id	  std;
-	unsigned int  audmode;
-			 int  snr;
-                         int  afc;
-	void     	  *resrvred;
-}atv_status_t;
-
-typedef struct sound_status_s {
-	unsigned short sound_sys;//A2DK/A2BG/NICAM BG/NICAM DK/BTSC/EIAJ
-	unsigned short sound_mode;//SETERO/DUAL/MONO/SAP
-	void     	       *resrvred;
-}sound_status_t;
-typedef enum tuner_param_cmd_e{
-	TUNER_CMD_AUDIO_MUTE = 0x0000,
-	TUNER_CMD_AUDIO_ON,// 0x0001,
-	TUNER_CMD_TUNER_POWER_ON,
-	TUNER_CMD_TUNER_POWER_DOWN,
-	TUNER_CMD_SET_VOLUME,
-	TUNER_CMD_SET_LEAP_SETP_SIZE,
-	TUNER_CMD_GET_MONO_MODE,
-	TUNER_CMD_SET_BEST_LOCK_RANGE,
-	TUNER_CMD_GET_BEST_LOCK_RANGE,
-	TUNER_CMD_SET_CVBS_AMP_OUT,
-	TUNER_CMD_GET_CVBS_AMP_OUT,
-	TUNER_CMD_NULL,
-}tuner_param_cmd_t;
-/*parameter for set param box*/
-typedef struct tuner_param_s {
-	tuner_param_cmd_t cmd;
-	unsigned int      parm;
-	unsigned int 	  resvred;
-}tuner_param_t;
 
 #define FE_SET_PROPERTY		   _IOW('o', 82, struct dtv_properties)
 #define FE_GET_PROPERTY		   _IOR('o', 83, struct dtv_properties)
 
-/* Satellite blind scan settings */
-struct dvbsx_blindscanpara {
-	__u32 minfrequency;			/* minimum tuner frequency in kHz */
-	__u32 maxfrequency;			/* maximum tuner frequency in kHz */
-	__u32 minSymbolRate;		/* minimum symbol rate in sym/sec */
-	__u32 maxSymbolRate;		/* maximum symbol rate in sym/sec */
-	__u32 frequencyRange;		/* search range in kHz. freq -/+freqRange will be searched */
-	__u32 frequencyStep;			/* tuner step frequency in kHz */
-	__s32 timeout;				/* blindscan event timeout*/
-};
-
-/* Satellite blind scan status */
-typedef enum dvbsx_blindscanstatus {
-	BLINDSCAN_NONEDO,
-	BLINDSCAN_UPDATESTARTFREQ,
-	BLINDSCAN_UPDATEPROCESS,
-	BLINDSCAN_UPDATERESULTFREQ
-} dvbsx_blindscanstatus_t;
-
-/* Satellite blind scan event */
-struct dvbsx_blindscanevent {
-	dvbsx_blindscanstatus_t status;
-	union {
-		__u16 m_uiprogress;							/* The percentage completion of the blind scan procedure. A value of 100 indicates that the blind scan is finished. */
-		__u32 m_uistartfreq_khz;					/* The start scan frequency in units of kHz. The minimum value depends on the tuner specification. */
-		struct dvb_frontend_parameters parameters;	/* Blind scan channel info. */
-	} u;
-};
-
-#define FE_SET_BLINDSCAN					_IOW('o', 84, struct dvbsx_blindscanpara)
-#define FE_GET_BLINDSCANEVENT		   		_IOR('o', 85, struct dvbsx_blindscanevent)
-#define FE_SET_BLINDSCANCANCEl				_IO('o', 86)
 
 /**
  * When set, this flag will disable any zigzagging or other "normal" tuning
@@ -703,16 +590,4 @@ struct dvbsx_blindscanevent {
 
 #define FE_DISHNETWORK_SEND_LEGACY_CMD _IO('o', 80) /* unsigned int */
 
-#define FE_SET_DELAY               _IO('o', 100)
-
-
-#define FE_SET_MODE                _IO('o', 90)
-#define FE_READ_AFC                _IOR('o', 91, __u32)
-#define FE_FINE_TUNE               _IOW('o', 92, __u32)
-#define FE_READ_TUNER_STATUS       _IOR('o', 93, tuner_status_t)
-#define FE_READ_ANALOG_STATUS      _IOR('o', 94, atv_status_t)
-#define FE_READ_SD_STATUS          _IOR('o', 95, sound_status_t)
-#define FE_READ_TS                 _IOR('o', 96, int)
-//set & get the tuner parameters only atv
-#define FE_SET_PARAM_BOX           _IOWR('o', 97, tuner_param_t)
 #endif /*_DVBFRONTEND_H_*/
